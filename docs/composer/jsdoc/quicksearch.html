<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"composer-admin_lib_adminconnection.js.html":{"id":"composer-admin_lib_adminconnection.js.html","title":"Source: composer-admin/lib/adminconnection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-admin/lib/adminconnection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ComboConnectionProfileStore = require('composer-common').ComboConnectionProfileStore; const ConnectionProfileManager = require('composer-common').ConnectionProfileManager; const EnvConnectionProfileStore = require('composer-common').EnvConnectionProfileStore; const FSConnectionProfileStore = require('composer-common').FSConnectionProfileStore; const Util = require('composer-common').Util; const fs = require('fs'); /** * This class creates an administration connection to a Hyperledger Composer runtime. The * connection can then be used to: * &lt;ul&gt; * &lt;li&gt;Deploy BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Undeploy BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Update BusinessNetworkDefinitions&lt;/li&gt; * &lt;li&gt;Send a ping message to the runtime to ensure it is running and * correctly configured.&lt;/li&gt; * &lt;li&gt;Store a connection profile document in the connection profile store&lt;/li&gt; * &lt;/ul&gt; * * @class * @memberof module:composer-admin */ class AdminConnection { /** * Create an instance of the AdminConnection class. * @param {Object} [options] - an optional set of options to configure the instance. * @param {Object} [options.fs] - specify an fs implementation to use. */ constructor(options) { options = options || {}; const fsConnectionProfileStore = new FSConnectionProfileStore(options.fs || fs); if (process.env.COMPOSER_CONFIG) { const envConnectionProfileStore = new EnvConnectionProfileStore(); this.connectionProfileStore = new ComboConnectionProfileStore( fsConnectionProfileStore, envConnectionProfileStore ); } else { this.connectionProfileStore = fsConnectionProfileStore; } this.connectionProfileManager = new ConnectionProfileManager(this.connectionProfileStore); this.connection = null; this.securityContext = null; } /** * Connects and logs in to the Hyperledger Fabric using a named connection * profile. The connection profile must exist in the profile store. * @example * // Connect to Hyperledger Fabric * var adminConnection = new AdminConnection(); * adminConnection.connect('testprofile', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(){ * // Connected. * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @param {string} enrollmentID the enrollment ID of the user * @param {string} enrollmentSecret the enrollment secret of the user * @param {string} businessNetworkIdentifier the id of the network (for update) or null * @return {Promise} A promise that indicates the connection is complete */ connect(connectionProfile, enrollmentID, enrollmentSecret, businessNetworkIdentifier) { return this.connectionProfileManager.connect(connectionProfile, businessNetworkIdentifier) .then((connection) =&gt; { this.connection = connection; return connection.login(enrollmentID, enrollmentSecret); }) .then((securityContext) =&gt; { this.securityContext = securityContext; if (businessNetworkIdentifier) { return this.connection.ping(this.securityContext); } }); } /** * Stores a connection profile into the profile store being used by this * AdminConnection. * @example * // Create a connection profile * var adminConnection = new AdminConnection(); * var adminOptions = { * type: 'hlf', * keyValStore: '/tmp/keyValStore', * membershipServicesURL: 'grpc://membersrvc:7054', * peerURL: 'grpc://vp0:7051', * eventHubURL: 'grpc://vp0:7053' * }; * return adminConnection.createProfile('testprofile', adminOptions) * .then(function(){ * // Created profile * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @param {Object} data - The connection profile data * @return {Promise} A promise that indicates that the connection profile is deployed */ createProfile(connectionProfile, data) { return this.connectionProfileManager.getConnectionProfileStore().save(connectionProfile, data); } /** * Deletes the specified connection profile from the profile store being used by this * AdminConnection. * @example * // Delete a connection profile * var adminConnection = new AdminConnection(); * return adminConnection.deleteProfile('testprofile') * .then(function(){ * // Deleted profile * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {string} connectionProfile - The name of the connection profile * @return {Promise} A promise that indicates that the connection profile is deployed */ deleteProfile(connectionProfile) { return this.connectionProfileManager.getConnectionProfileStore().delete(connectionProfile); } /** * Retrieve the specified connection profile from the profile store being * used by this AdminConnection. * @example * // Retrieve the connection profile. * const adminConnection = new AdminConnection(); * return adminConnection.getProfile('testprofile') * .then((profile) =&gt; { * // Retrieved profile * console.log(profile); * }); * @param {string} connectionProfile - The name of the connection profile * @return {Promise} A promise that is resolved with the connection profile data. */ getProfile(connectionProfile) { return this.connectionProfileManager.getConnectionProfileStore().load(connectionProfile); } /** * Retrieve all connection profiles from the profile store being used by this * AdminConnection. * @example * // Retrieve all the connection profiles. * const adminConnection = new AdminConnection(); * return adminConnection.getAllProfiles() * .then((profiles) =&gt; { * // Retrieved profiles * for (let profile in profiles) { * console.log(profile, profiles[profile]); * } * }); * @return {Promise} A promise that is resolved with the connection profile data. */ getAllProfiles() { return this.connectionProfileManager.getConnectionProfileStore().loadAll(); } /** * Disconnects this connection. * @example * // Disconnect from a Business Network * var adminConnection = new AdminConnection(); * return adminConnection.disconnect() * .then(function(){ * // Disconnected. * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be resolved when the connection is * terminated. */ disconnect() { if (!this.connection) { return Promise.resolve(); } return this.connection.disconnect() .then(() =&gt; { this.connection = null; this.securityContext = null; }); } /** * Deploys a new BusinessNetworkDefinition to the Hyperledger Fabric. The connection must * be connected for this method to succeed. * @example * // Deploy a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.deploy(businessNetworkDefinition) * .then(function(){ * // Business network definition deployed * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkDefinition} businessNetworkDefinition - The business network to deploy * @return {Promise} A promise that will be fufilled when the business network has been * deployed. */ deploy(businessNetworkDefinition) { Util.securityCheck(this.securityContext); return this.connection.deploy(this.securityContext, true, businessNetworkDefinition); } /** * Undeploys a BusinessNetworkDefinition from the Hyperledger Fabric. The business network will no * longer be able to process transactions. * @example * // Undeploy a Business Network Definition * var adminConnection = new AdminConnection(); * return adminConnection.undeploy('identifier') * .then(function(){ * // Undeployed Business Network Definition * }) * .catch(function(error){ * // Add optional error handling here. * }) * @param {string} businessNetworkIdentifier - The identifier of the network to undeploy * @return {Promise} A promise that will be fufilled when the business network has been * undeployed. */ undeploy(businessNetworkIdentifier) { Util.securityCheck(this.securityContext); return this.connection.undeploy(this.securityContext, businessNetworkIdentifier); } /** * Updates an existing BusinessNetworkDefinition on the Hyperledger Fabric. The BusinessNetworkDefinition * must have been previously deployed. * @example * // Updates a Business Network Definition * var adminConnection = new AdminConnection(); * var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); * return adminConnection.update(businessNetworkDefinition) * .then(function(){ * // Business network definition updated * }) * .catch(function(error){ * // Add optional error handling here. * }); * @param {BusinessNetworkDefinition} businessNetworkDefinition - The new BusinessNetworkDefinition * @return {Promise} A promise that will be fufilled when the business network has been * updated. */ update(businessNetworkDefinition) { Util.securityCheck(this.securityContext); return this.connection.update(this.securityContext, businessNetworkDefinition); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the node.js module. * @example * // Test the connection to the runtime * var adminConnection = new AdminConnection(); * return adminConnection.ping() * .then(function(){ * // Connection has been tested * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be fufilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ ping() { Util.securityCheck(this.securityContext); return this.connection.ping(this.securityContext); } /** * List all of the deployed business networks. The connection must * be connected for this method to succeed. * @example * // List all of the deployed business networks. * var adminConnection = new AdminConnection(); * return adminConnection.list() * .then((businessNetworks) =&gt; { * // Connection has been tested * return businessNetworks.forEach((businessNetwork) =&gt; { * console.log('Deployed business network', businessNetwork); * }); * }) * .catch(function(error){ * // Add optional error handling here. * }); * @return {Promise} A promise that will be resolved with an array of * business network identifiers, or rejected with an error. */ list() { Util.securityCheck(this.securityContext); return this.connection.list(this.securityContext); } /** * import an identity into a profiles' wallet * * @param {string} connectionProfile Name of the connection profile * @param {string} id The id to associate with this identity * @param {string} publicKey The signer cert in PEM format * @param {string} privateKey The private key in PEM format * @returns {Promise} A promise which is resolved when the identity is imported * * @memberOf AdminConnection */ importIdentity(connectionProfile, id, publicKey, privateKey) { let savedConnectionManager; return this.connectionProfileManager.getConnectionManager(connectionProfile) .then((connectionManager) =&gt; { savedConnectionManager = connectionManager; return this.getProfile(connectionProfile); }) .then((profileData) =&gt; { return savedConnectionManager.importIdentity(profileData, id, publicKey, privateKey); }) .catch((error) =&gt; { throw new Error('failed to import identity. ' + error.message); }); } } module.exports = AdminConnection; × Search results Close "},"composer-runtime_lib_compiledquerybundle.js.html":{"id":"composer-runtime_lib_compiledquerybundle.js.html","title":"Source: composer-runtime/lib/compiledquerybundle.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/compiledquerybundle.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const LOG = Logger.getLog('CompiledQueryBundle'); /** * A script compiler compiles all scripts in a script manager into a compiled * script bundle that can easily be called by the runtime. * @protected */ class CompiledQueryBundle { /** * Constructor. * @param {QueryCompiler} queryCompiler The query compiler to use. * @param {QueryManager} queryManager The query manager to use. * @param {Object[]} compiledQueries The compiled queries to use. */ constructor(queryCompiler, queryManager, compiledQueries) { const method = 'constructor'; LOG.entry(method, queryCompiler, queryManager, compiledQueries); this.queryCompiler = queryCompiler; this.queryManager = queryManager; this.compiledQueries = compiledQueries; this.compiledQueriesByName = {}; compiledQueries.forEach((compiledQuery) =&gt; { this.compiledQueriesByName[compiledQuery.name] = compiledQuery; this.compiledQueriesByName[compiledQuery.hash] = compiledQuery; }); this.dynamicQueryFile = queryManager.createQueryFile('$dynamic_queries.qry', ''); LOG.exit(method); } /** * Build and compile a query for use at a later time. * @param {string} query The query string. * @return {string} An identifier for the query. */ buildQuery(query) { const method = 'buildQuery'; LOG.entry(method, query); // Hash the query string. const sha256 = createHash('sha256'); const hash = sha256.update(query, 'utf8').digest('hex'); LOG.debug(method, 'Calculated query hash', hash); // Check to see if the query exists by name. let compiledQuery = this.compiledQueriesByName[hash]; if (compiledQuery) { LOG.debug(method, 'Compiled query already exists'); LOG.exit(method, hash); return hash; } else { LOG.debug(method, 'Compiled query does not exist, compiling'); } // Create a new query. const newQuery = this.dynamicQueryFile.buildQuery(hash, 'Dynamic query ' + hash, query); compiledQuery = newQuery.accept(this.queryCompiler, {}); // Store the query for later. this.compiledQueriesByName[compiledQuery.name] = compiledQuery; LOG.exit(method, hash); return hash; } /** * Execute the specified query. * @param {DataService} dataService The data service to use. * @param {string} query The name of the query, or the query itself. * @param {Object} [parameters] The parameters provided for the query. * @return {Promise} A promise that is resolved with the results of the * query, or rejected with an error. */ execute(dataService, query, parameters) { const method = 'execute'; LOG.entry(method, dataService, query, parameters); // Check to see if the query exists by name. let compiledQuery = this.compiledQueriesByName[query]; if (!compiledQuery) { throw new Error('The specified query does not exist'); } // Return the results of executing the query. LOG.debug(method, 'Found query by name lookup'); return this.executeInternal(dataService, compiledQuery, parameters) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Execute the specified query. * @param {DataService} dataService The data service to use. * @param {Object} compiledQuery The compiled query. * @param {Object} [parameters] The parameters provided for the query. * @return {Promise} A promise that is resolved with the results of the * query, or rejected with an error. */ executeInternal(dataService, compiledQuery, parameters) { const method = 'executeInternal'; LOG.entry(method, dataService, compiledQuery, parameters); // Set the parameters if not provided. parameters = parameters || {}; // Get the compiled query string. const compiledQueryString = compiledQuery.generator(parameters); // Execute the compiled query string. return dataService.executeQuery(compiledQueryString) .then((result) =&gt; { LOG.exit(method, result); return result; }); } } module.exports = CompiledQueryBundle; × Search results Close "},"composer-runtime_lib_compiledscriptbundle.js.html":{"id":"composer-runtime_lib_compiledscriptbundle.js.html","title":"Source: composer-runtime/lib/compiledscriptbundle.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/compiledscriptbundle.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('CompiledScriptBundle'); /** * A script compiler compiles all scripts in a script manager into a compiled * script bundle that can easily be called by the runtime. * @protected */ class CompiledScriptBundle { /** * Constructor. * @param {FunctionDeclaration[]} functionDeclarations The function declarations to use. * @param {Function} generatorFunction The generator function to use. */ constructor(functionDeclarations, generatorFunction) { this.functionDeclarations = functionDeclarations; this.generatorFunction = generatorFunction; } /** * Execute the specified transaction. * @param {Api} api The API to use. * @param {Resource} resolvedTransaction The resolved transaction to execute. * @return {Promise} A promise that is resolved when the transaction has been * executed, or rejected with an error. */ execute(api, resolvedTransaction) { const method = 'execute'; LOG.entry(method, api, resolvedTransaction); // Find all of the function names. const functionNames = this.findFunctionNames(resolvedTransaction); // If we didn't find any functions to call, then throw an error! if (functionNames.length === 0) { LOG.error(`Could not find any functions to execute for transaction ${resolvedTransaction.getFullyQualifiedIdentifier()}`); throw new Error(`Could not find any functions to execute for transaction ${resolvedTransaction.getFullyQualifiedIdentifier()}`); } // Generate an instance of the compiled script bundle. const bundle = this.generatorFunction(api); // Execute each function for the transaction. return functionNames.reduce((result, functionName) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Executing function', functionName); const func = bundle[functionName]; const funcResult = func(resolvedTransaction); if (funcResult &amp;&amp; typeof funcResult.then === 'function') { return funcResult.then(() =&gt; { LOG.debug(method, 'Function executed (returned promise)'); }); } else { LOG.debug(method, 'Function executed'); } }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method); }); } /** * Find all of the function names that should be executed. * @param {Resource} transaction The transaction to execute. * @return {string[]} All function names to execute. */ findFunctionNames(transaction) { const method = 'findFunctionNames'; LOG.entry(method, transaction); // Look at all the functions. const functionNames = []; this.functionDeclarations.forEach((functionDeclaration) =&gt; { // Is this function annotated with @transaction? LOG.debug(method, 'Looking at function declaration', functionDeclaration.getName()); if (functionDeclaration.getDecorators().indexOf('transaction') !== -1) { // Yes - is the type of the only parameter (validated elsewhere) // the same type as the transaction? LOG.debug(method, 'Function is annotated with @transaction'); if (functionDeclaration.getParameterTypes()[0] === transaction.getFullyQualifiedType()) { LOG.debug(method, 'Function parameter type matches transaction'); functionNames.push(functionDeclaration.getName()); } else { LOG.debug(method, 'Function parameter type does not match transaction'); } // It's not annotated with @transaction, does it start with on&lt;transactionType&gt;? // This is to keep supporting the original transaction processor function format // which went by naming conventions rather than annotations. } else if (functionDeclaration.getTransactionDeclarationName() === transaction.getType()) { LOG.debug(method, 'Function name matches on&lt;transactionType&gt;'); functionNames.push(functionDeclaration.getName()); // Must be a query or utility function. } else { LOG.debug(method, 'Function is query or utility function'); } }); LOG.exit(method, functionNames); return functionNames; } } module.exports = CompiledScriptBundle; × Search results Close "},"composer-common_lib_log_consolelogger.js.html":{"id":"composer-common_lib_log_consolelogger.js.html","title":"Source: composer-common/lib/log/consolelogger.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/consolelogger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const util = require('util'); /** * A functional logger implementation that simply writes to the console. */ class ConsoleLogger { /** * Called to format. * @param {string} method The method. * @param {string} msg The message. * @param {*} [args] The arguments. * @returns {string} The formatted message. */ format(method, msg, args) { if (!args) { return util.format('%s %s', method, msg); } let formattedArguments = args.map((arg) =&gt; { if (typeof(arg) === 'function') { return '&lt;function&gt;'; } else if (arg === Object(arg)) { // It's an object, array, or function, so serialize it as JSON. try { return JSON.stringify(arg); } catch (e) { return arg; } } else { return String(arg); } }).join(', '); return util.format('%s %s %s', method, msg, formattedArguments); } /** * Called to log. * @param {string} level The logging level. * @param {string} method The method. * @param {string} msg The message. * @param {*} [args] The arguments. */ log(level, method, msg, args) { const formattedMessage = this.format(method, msg, args); switch (level) { case 'debug': console.log(formattedMessage); break; case 'warn': console.warn(formattedMessage); break; case 'info': console.info(formattedMessage); break; case 'verbose': console.log(formattedMessage); break; case 'error': console.error(formattedMessage); break; } } } module.exports = ConsoleLogger; × Search results Close "},"composer-common_lib_serializer_valuegenerator.js.html":{"id":"composer-common_lib_serializer_valuegenerator.js.html","title":"Source: composer-common/lib/serializer/valuegenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/valuegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const randomWords = require('random-words'); /** * Factory providing static methods to create ValueGenerator instances. * @private */ class ValueGeneratorFactory { /** * Create a value generator that supplies empty values. * @return {ValueGenerator} a value generator. */ static empty() { return new EmptyValueGenerator(); } /** * Create a value generator that supplies randomly generated sample values. * @return {ValueGenerator} a value generator. */ static sample() { return new SampleValueGenerator(); } } /** * Empty value generator. * @private */ class EmptyValueGenerator { /** * This constructor should not be called directly. * @private */ constructor() { this.currentDate = new Date(); } /** * Get a default DateTime value. * @return {Date} a date value. */ getDateTime() { return this.currentDate; } /** * Get a default Integer value. * @return {number} an Integer value. */ getInteger() { return 0; } /** * Get a default Long value. * @return {number} a Long value. */ getLong() { return 0; } /** * Get a default Double value. * @return {number} a Double value. */ getDouble() { return 0.000; } /** * Get a default Boolean value. * @return {boolean} a Boolean value. */ getBoolean() { return false; } /** * Get a default String value. * @return {string} a String value. */ getString() { return ''; } /** * Get the first enum value from the supplied array. * @param {Array} enumValues Array of possible enum values. * @return {*} an enum value. */ getEnum(enumValues) { return enumValues[0]; } } /** * Sample data value generator. * @private */ class SampleValueGenerator extends EmptyValueGenerator { /** * This constructor should not be called directly. * @private */ constructor() { super(); } /** * Get a randomly generated sample Integer value. * @return {number} an Integer value. */ getInteger() { return Math.round(Math.random() * Math.pow(2, 16)); } /** * Get a randomly generated sample Long value. * @return {number} a Long value. */ getLong() { return Math.round(Math.random() * Math.pow(2, 32)); } /** * Get a randomly generated sample Double value. * @return {number} a Double value. */ getDouble() { return Number((Math.random() * Math.pow(2, 8)).toFixed(3)); } /** * Get a randomly generated sample Boolean value. * @return {boolean} a Boolean value. */ getBoolean() { return Math.round(Math.random()) === 1; } /** * Get a randomly generated sample String value. * @return {string} a String value. */ getString() { return randomWords({min: 1, max: 5}).join(' '); } /** * Get a randomly selected enum value from the supplied array. * @param {Array} enumValues Array of possible enum values. * @return {*} an enum value. */ getEnum(enumValues) { return enumValues[Math.floor(Math.random() * enumValues.length)]; } } module.exports = ValueGeneratorFactory; × Search results Close "},"composer-common_lib_filewallet.js.html":{"id":"composer-common_lib_filewallet.js.html","title":"Source: composer-common/lib/filewallet.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/filewallet.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const homedir = require('homedir'); const Logger = require('./log/logger'); const mkdirp = require('mkdirp'); const path = require('path'); const thenify = require('thenify'); const thenifyAll = require('thenify-all'); const Wallet = require('./wallet'); const LOG = Logger.getLog('FileWallet'); /** * Class implementing a wallet (a container of credentials) that * stores the credentials on the file system. * @protected */ class FileWallet extends Wallet { /** * Get the current home directory. * @return {string} The current home directory. */ static getHomeDirectory() { return homedir(); } /** * Constructor. * @param {Object} [options] The options to use. * @param {string} [options.directory] The directory to store * credentials in. * @param {Object} [fs] The file system implementation to use. */ constructor(options) { super(); const method = 'constructor'; LOG.entry(method, options); // Generate the directory if not specified in the options. options = options || {}; this.directory = options.directory; if (!this.directory) { let h = FileWallet.getHomeDirectory(); if (h) { this.directory = path.resolve(h, '.composer-credentials'); } else { this.directory = path.resolve('/', '.composer-credentials'); } LOG.debug(method, 'Generated directory', this.directory); } // Use the default fs implementation if one is not specified. let theFS = options.fs; if (!theFS) { theFS = fs; } // Promisify all of the APIs that we want to use. this.fs = thenifyAll(theFS, {}); this.mkdirp = thenify((dir, cb) =&gt; { return mkdirp(dir, { fs: theFS }, cb); }); LOG.exit(method); } /** * List all of the credentials in the wallet. * @return {Promise} A promise that is resolved with * an array of credential names, or rejected with an * error. */ list() { const method = 'list'; LOG.entry(method); const result = []; return this.fs.readdir(this.directory) .then((files) =&gt; { files.forEach((file) =&gt; { LOG.debug(method, 'Found file', file); result.push(file); }); result.sort(); }) .catch((error) =&gt; { // Ignore any errors. LOG.debug(method, 'Ignoring error', error); }) .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Check to see if the named credentials are in * the wallet. * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * a boolean; true if the named credentials are in the * wallet, false otherwise. */ contains(name) { const method = 'contains'; LOG.entry(method, name); let result = false; const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then((value) =&gt; { LOG.debug(method, 'Read file successfully'); result = true; }) .catch((error) =&gt; { // Ignore any errors. LOG.debug(method, 'Ignoring error', error); }) .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Get the named credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * the named credentials, or rejected with an error. */ get(name) { const method = 'get'; LOG.entry(method, name); const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then((value) =&gt; { LOG.debug(method, 'Read file successfully'); LOG.exit(method, value); return value; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Add a new credential to the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ add(name, value) { const method = 'add'; LOG.entry(method, name, value); const file = path.resolve(this.directory, name); return this.mkdirp(this.directory) .then(() =&gt; { return this.fs.writeFile(file, value, { flag: 'wx', mode: 0o600 }); }) .then((value) =&gt; { LOG.debug(method, 'Wrote file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Update existing credentials in the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ update(name, value) { const method = 'update'; LOG.entry(method, name, value); const file = path.resolve(this.directory, name); return this.fs.readFile(file, 'utf8') .then(() =&gt; { LOG.debug(method, 'Read file successfully'); return this.fs.writeFile(file, value, { mode: 0o600 }); }) .then((value) =&gt; { LOG.debug(method, 'Wrote file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Remove existing credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ remove(name) { const method = 'remove'; LOG.entry(method, name); const file = path.resolve(this.directory, name); return this.fs.unlink(file) .then((value) =&gt; { LOG.debug(method, 'Removed file successfully'); LOG.exit(method); }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } } module.exports = FileWallet; × Search results Close "},"composer-common_lib_log_winstonInjector.js.html":{"id":"composer-common_lib_log_winstonInjector.js.html","title":"Source: composer-common/lib/log/winstonInjector.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/winstonInjector.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs-extra'); const winston = require('winston'); const sprintf = require('sprintf-js').sprintf; /** * This the default core logger that is used for Hyperledger-Composer. This function * setups up the Winston logging for both file and console output. * * @param {Object} config JSON structure with specific configuration information * @param {Array} configElements JSON struction with the DEBUG env variables for composer * * @returns {Object} object that is the logger to use */ exports.getLogger = function (config,configElements){ let consoleLevel; let fileLevel; // if the length of the configured elements are 0 then put this into a default // only mode. if (configElements.debug.length === 0){ consoleLevel=config.console.alwaysLevel; fileLevel=config.file.alwaysLevel; } else { fileLevel=config.file.enabledLevel; consoleLevel=config.console.enabledLevel; } // setup the formatter functions let formatterFn = function(options) { // Return string will be passed to logger. return sprintf('%s %-7s %-20s %s' ,options.timestamp() ,options.level.toUpperCase() ,options.message ,(JSON.stringify(options.meta,null,'') +'$') ); }; // setup the time stamp function let timestampFn = function() { return new Date(Date.now()).toISOString(); }; // process the file name and make sure the directory has been created let resolvedFilename = config.file.filename.replace(/PID/g, process.pid); let dir = './logs'; fs.ensureDirSync(dir); // create the Winston logger with the two transports. let newWinstonLogger = { transports: [ new(winston.transports.Console)({ name: 'info-file', timestamp: timestampFn, formatter: formatterFn , level: consoleLevel }), new(winston.transports.File)({ name:'debug-file', json:false, filename: dir+ '/' + resolvedFilename, timestamp: timestampFn, formatter: formatterFn , level: fileLevel }) ] }; // add to the winnston system and return winston.loggers.add('Hyperledger-Composer',newWinstonLogger); return winston.loggers.get('Hyperledger-Composer'); }; × Search results Close "},"composer-common_lib_connectionmanager.js.html":{"id":"composer-common_lib_connectionmanager.js.html","title":"Source: composer-common/lib/connectionmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connectionmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileManager = require('./connectionprofilemanager'); /** * Base class representing a connection manager that establishes and manages * connections to one or more business networks. The ConnectionManager loads * connection profiles using the ConnectionProfileManager. * * @private * @abstract * @class * @memberof module:composer-common */ class ConnectionManager { /** * Create the ConnectionManager * @param {ConnectionProfileManager} connectionProfileManager - the ConnectionProfileManager * that controls this instance. */ constructor(connectionProfileManager) { if(!(connectionProfileManager instanceof ConnectionProfileManager)) { throw new Error('Must create ConnectionManager with a ConnectionProfileManager implementation.'); } this.connectionProfileManager = connectionProfileManager; } /** * Returns the ConnectionProfileManager associated with this ConnectionManager * @return {ConnectionProfileManager} the connection profile manager for this * connection manager. */ getConnectionProfileManager() { return this.connectionProfileManager; } /** * Establish a connection to the business network, using connection information * from the connection profile. * * @param {string} connectionProfile The name of the connection profile * @param {string} businessNetworkIdentifier The identifier of the business network, or null if this is an admin connection * @param {object} connectionOptions The connection options loaded from the profile * @return {Promise} A promise that is resolved with a {@link Connection} * object once the connection is established, or rejected with a connection error. * @abstract */ connect(connectionProfile, businessNetworkIdentifier, connectionOptions) { return Promise.reject(new Error('abstract function called')); } /** * Import an identity into a profile wallet or keystore * * @param {object} profileDefinition the profile definition * @param {string} id the id to associate with the identity * @param {string} publicKey the public key * @param {string} privateKey the private key * @returns {Promise} a promise which resolves when the identity is imported * * @memberOf HLFConnectionManager */ importIdentity(profileDefinition, id, publicKey, privateKey) { return Promise.reject(new Error('Import identity not supported by this connection profile')); } } module.exports = ConnectionManager; × Search results Close "},"composer-runtime_lib_identitymanager.js.html":{"id":"composer-runtime_lib_identitymanager.js.html","title":"Source: composer-runtime/lib/identitymanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/identitymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Resource = require('composer-common').Resource; const LOG = Logger.getLog('IdentityManager'); /** * A class for managing and persisting identities. * @protected */ class IdentityManager { /** * Constructor. * @param {DataService} dataService The data service to use. * @param {RegistryManager} registryManager The registry manager to use. * @param {DataCollection} sysidentities The system identities collection. */ constructor(dataService, registryManager, sysidentities) { this.dataService = dataService; this.registryManager = registryManager; this.sysidentities = sysidentities; } /** * Add a new mapping for the specified identity (user ID) to the specified * participant. * @param {(Resource|string)} participant The participant, or the unique * identifier of the participant. * @param {string} userID The identity (user ID) to map to the participant. * @return {Promise} A promise that is resolved when a new mapping for the * specified identity has been created. */ addIdentityMapping(participant, userID) { const method = 'addIdentityMapping'; LOG.entry(method, participant, userID); let participantFQI, participantFQT, participantID; if (participant instanceof Resource) { participantFQI = participant.getFullyQualifiedIdentifier(); participantFQT = participant.getFullyQualifiedType(); participantID = participant.getIdentifier(); } else { participantFQI = participant; let hashIndex = participantFQI.indexOf('#'); if (hashIndex === -1) { throw new Error('Invalid fully qualified participant identifier'); } participantFQT = participantFQI.substring(0, hashIndex); participantID = participantFQI.substring(hashIndex + 1); } LOG.debug(method, 'Looking for participant registry', participantFQT); return this.registryManager.get('Participant', participantFQT) .then((participantRegistry) =&gt; { LOG.debug(method, 'Found participant registry, looking for participant', participantID); return participantRegistry.get(participantID); }) .then((participant) =&gt; { LOG.debug(method, 'Got $sysidentities collection, checking for existing mapping'); return this.sysidentities.exists(userID); }) .then((exists) =&gt; { if (exists) { LOG.error(method, 'Found an existing mapping for user ID', userID); throw new Error(`Found an existing mapping for user ID '${userID}'`); } LOG.debug(method, 'No existing mapping exists for user ID, adding'); return this.sysidentities.add(userID, { participant: participantFQI }); }) .then(() =&gt; { LOG.exit(method); }); } /** * Remove an existing mapping for the specified identity (user ID) to a * participant. * @param {string} userID The identity (user ID). * @return {Promise} A promise that is resolved when a new mapping for the * specified identity has been created. */ removeIdentityMapping(userID) { const method = 'removeIdentityMapping'; LOG.entry(method, userID); LOG.debug(method, 'Got $sysidentities collection, checking for existing mapping'); return this.sysidentities.exists(userID) .then((exists) =&gt; { if (!exists) { LOG.debug('No existing mapping exists for user ID, ignoring'); return; } return this.sysidentities.remove(userID); }) .then(() =&gt; { LOG.exit(method); }); } /** * Retrieve the participant for the specified identity (user ID). * @param {string} userID The identity (user ID). * @return {Promise} A promise that is resolved with a {@link Resource} * representing the participant, or rejected with an error. */ getParticipant(userID) { const method = 'getParticipant'; LOG.entry(method, userID); LOG.debug(method, 'Getting $sysidentities collection'); let participantFQI, participantFQT, participantID; LOG.debug(method, 'Got $sysidentities collection, checking for existing mapping'); return this.sysidentities.get(userID) .then((mapping) =&gt; { participantFQI = mapping.participant; LOG.debug(method, 'Found mapping, participant is', participantFQI); let hashIndex = participantFQI.indexOf('#'); if (hashIndex === -1) { throw new Error('Invalid fully qualified participant identifier'); } participantFQT = participantFQI.substring(0, hashIndex); participantID = participantFQI.substring(hashIndex + 1); LOG.debug(method, 'Looking for participant registry', participantFQT); return this.registryManager.get('Participant', participantFQT); }) .then((participantRegistry) =&gt; { LOG.debug(method, 'Found participant registry, looking for participant', participantID); return participantRegistry.get(participantID); }) .then((participant) =&gt; { LOG.exit(method, participant); return participant; }); } } module.exports = IdentityManager; × Search results Close "},"composer-admin_index.js.html":{"id":"composer-admin_index.js.html","title":"Source: composer-admin/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-admin/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. */ require('composer-common').ConnectionProfileManager.registerConnectionManagerLoader(module); /** * &lt;p&gt; * The composer-admin module. Defines the administration API for Hyperledger Composer. * &lt;/p&gt; * &lt;p&gt; * Hyperledger Composer is a framework for creating blockchain backed digital networks and * exchanging assets between participants via processing transactions. * &lt;/p&gt; * @module composer-admin */ module.exports.AdminConnection = require('./lib/adminconnection'); /** * Expose key composer-common classes to simplify client application dependencies * @ignore */ module.exports.BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; module.exports.Logger = require('composer-common').Logger; module.exports.version = require('./package.json'); × Search results Close "},"composer-client_index.js.html":{"id":"composer-client_index.js.html","title":"Source: composer-client/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. */ require('composer-common').ConnectionProfileManager.registerConnectionManagerLoader(module); /** * &lt;p&gt; * The composer-client module. Defines the client API for Composer. * &lt;/p&gt; * &lt;p&gt; * Composer is a framework for creating blockchain backed digital networks and * exchanging assets between participants via processing transactions. * &lt;/p&gt; * &lt;p&gt; * Applications interact with the framework by instantiating the {@link BusinessNetworkConnection} * class. * &lt;/p&gt; * @module composer-client */ module.exports.BusinessNetworkConnection = require('./lib/businessnetworkconnection'); module.exports.AssetRegistry = require('./lib/assetregistry'); module.exports.ParticipantRegisty = require('./lib/participantregistry'); module.exports.TransactionRegistry = require('./lib/transactionregistry'); /** * Expose key composer-common classes to simplify client application dependencies * @ignore */ module.exports.Logger = require('composer-common').Logger; module.exports.version = require('./package.json'); × Search results Close "},"composer-client_lib_assetregistry.js.html":{"id":"composer-client_lib_assetregistry.js.html","title":"Source: composer-client/lib/assetregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/assetregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Asset'; /** * The AssetRegistry is used to manage a set of assets stored on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/assetregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/assetregistry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class AssetRegistry extends Registry { /** * Get a list of all existing asset registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a list of {@link AssetRegistry} * instances representing the asset registries. */ static getAllAssetRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then((assetRegistries) =&gt; { return assetRegistries.map((assetRegistry) =&gt; { return new AssetRegistry(assetRegistry.id, assetRegistry.name, securityContext, modelManager, factory, serializer); }); }); } /** * Get an existing asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the asset registry. */ static getAssetRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new AssetRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Determine whether an registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a boolean indicating whether the asset registry exists */ static assetRegistryExists(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.existsRegistry(securityContext, REGISTRY_TYPE, id); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {string} name The name of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a {@link AssetRegistry} * instance representing the new asset registry. */ static addAssetRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new AssetRegistry(id, name, securityContext, modelManager, factory, serializer); }); } /** * Create an asset registry. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * @protected * @param {string} id The unique identifier of the asset registry. * @param {string} name The display name for the asset registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } } module.exports = AssetRegistry; × Search results Close "},"composer-runtime_lib_registry.js.html":{"id":"composer-runtime_lib_registry.js.html","title":"Source: composer-runtime/lib/registry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/registry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const EventEmitter = require('events'); const Resource = require('composer-common').Resource; /** * A class for managing and persisting resources. * @protected */ class Registry extends EventEmitter { /** * Remove any internal properties to the specified JSON object before * reinflating it back into a resource. * @param {Object} json The JSON object. * @return {Object} The JSON object. */ static removeInternalProperties(json) { if (!json || typeof json !== 'object' || Array.isArray(json)) { throw new Error('Can only add properties to JSON objects'); } delete json.$registryType; delete json.$registryID; return json; } /** * Constructor. * @param {string} dataCollection The data collection to use. * @param {Serializer} serializer The serializer to use. * @param {AccessController} accessController The access controller to use. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. */ constructor(dataCollection, serializer, accessController, type, id, name) { super(); this.dataCollection = dataCollection; this.serializer = serializer; this.accessController = accessController; this.type = type; this.id = id; this.name = name; } /** * Get all the resources in this registry. * @return {Promise} A promise that will be resolved with an array of {@link * Resource} objects when complete, or rejected with an error. */ getAll() { return this.dataCollection.getAll() .then((objects) =&gt; { return objects.map((object) =&gt; { object = Registry.removeInternalProperties(object); return this.serializer.fromJSON(object); }).filter((resource) =&gt; { try { this.accessController.check(resource, 'READ'); return true; } catch (e) { return false; } }); }); } /** * Get the specified resource in this registry. * @param {string} id The ID of the resource. * @return {Promise} A promise that will be resolved with a {@link Resource} * object when complete, or rejected with an error. */ get(id) { return this.dataCollection.get(id) .then((object) =&gt; { object = Registry.removeInternalProperties(object); let result = this.serializer.fromJSON(object); try { this.accessController.check(result, 'READ'); return result; } catch (e) { throw new Error(`Object with ID '${id}' in collection with ID '${this.type}:${this.id}' does not exist`); } }); } /** * Determine whether the specified resource exists in this registry. * @param {string} id The ID of the resource. * @return {Promise} A promise that will be resolved with a boolean * indicating whether the asset exists. */ exists(id) { return this.dataCollection.exists(id) .then((exists) =&gt; { if (!exists) { return false; } return this.dataCollection.get(id) .then((object) =&gt; { object = Registry.removeInternalProperties(object); let result = this.serializer.fromJSON(object); try { this.accessController.check(result, 'READ'); return true; } catch (e) { return false; } }); }); } /** * An event signalling that a resource has been added to this registry. * @event Registry#resourceadded * @protected * @type {object} * @param {Registry} registry The registry. * @param {Resource} resource The resource. */ /** * Add all of the specified resources to this registry. * @param {Resource[]} resources The resources to add to this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addAll(resources, options) { options = options || {}; return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.add(resource, options); }); }, Promise.resolve()); } /** * Add the specified resource to this registry. * @param {Resource} resource The resource to add to this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ add(resource, options) { this.accessController.check(resource, 'CREATE'); options = options || {}; let id = resource.getIdentifier(); let object = this.serializer.toJSON(resource, { convertResourcesToRelationships: options.convertResourcesToRelationships }); object = this.addInternalProperties(object); return this.dataCollection.add(id, object) .then(() =&gt; { this.emit('resourceadded', { registry: this, resource: resource }); }); } /** * An event signalling that a resource has been updated in this registry. * @event Registry#resourceupdated * @protected * @type {object} * @param {Registry} registry The registry. * @param {Resource} oldResource The old version of the resource. * @param {Resource} newResource The new version of the resource. */ /** * Update all of the specified resources in this registry. * @param {Resource[]} resources The resources to update in this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateAll(resources, options) { options = options || {}; return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.update(resource, options); }); }, Promise.resolve()); } /** * Update the specified resource in this registry. * @param {Resource} resource The resource to update in this registry. * @param {Object} [options] Options for processing the resources. * @param {boolean} [options.convertResourcesToRelationships] Permit resources * in the place of relationships, defaults to false. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ update(resource, options) { options = options || {}; let id = resource.getIdentifier(); let object = this.serializer.toJSON(resource, { convertResourcesToRelationships: options.convertResourcesToRelationships }); object = this.addInternalProperties(object); return this.dataCollection.get(id) .then((oldResource) =&gt; { return this.serializer.fromJSON(oldResource); }) .then((oldResource) =&gt; { // We must perform access control checks on the old version of the resource! this.accessController.check(oldResource, 'UPDATE'); return this.dataCollection.update(id, object) .then(() =&gt; { this.emit('resourceupdated', { registry: this, oldResource: oldResource, newResource: resource }); }); }); } /** * An event signalling that a resource has been removed from this registry. * @event Registry#resourceremoved * @protected * @type {object} * @param {Registry} registry The registry. * @param {string} resourceID The ID of the resource. */ /** * Remove all of the specified resources from this registry. * @param {string[]|Resource[]} resources The resources to remove from this registry. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeAll(resources) { return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { return this.remove(resource); }); }, Promise.resolve()); } /** * Remove the specified resource from this registry. * @param {string|Resource} resource The resource to remove from this registry. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ remove(resource) { return Promise.resolve() .then(() =&gt; { // If the resource is a string, then we need to retrieve // the resource using its ID from the registry. We need to // do this to figure out the type of the resource for // access control. if (resource instanceof Resource) { return resource; } else { return this.dataCollection.get(resource) .then((object) =&gt; { object = Registry.removeInternalProperties(object); return this.serializer.fromJSON(object); }); } }) .then((resource) =&gt; { this.accessController.check(resource, 'DELETE'); let id = resource.getIdentifier(); return this.dataCollection.remove(id) .then(() =&gt; { this.emit('resourceremoved', { registry: this, resourceID: id }); }); }); } /** * Add any internal properties to the specified JSON object before * persisting it into a data collection. * @param {Object} json The JSON object. * @return {Object} The JSON object. */ addInternalProperties(json) { if (!json || typeof json !== 'object' || Array.isArray(json)) { throw new Error('Can only add properties to JSON objects'); } json.$registryType = this.type; json.$registryID = this.id; return json; } /** * Return an object suitable for serialization. * @return {Object} An object suitable for serialization. */ toJSON() { return { type: this.type, id: this.id, name: this.name }; } } module.exports = Registry; × Search results Close "},"composer-client_lib_businessnetworkconnection.js.html":{"id":"composer-client_lib_businessnetworkconnection.js.html","title":"Source: composer-client/lib/businessnetworkconnection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/businessnetworkconnection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetRegistry = require('./assetregistry'); const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const ComboConnectionProfileStore = require('composer-common').ComboConnectionProfileStore; const ConnectionProfileManager = require('composer-common').ConnectionProfileManager; const EnvConnectionProfileStore = require('composer-common').EnvConnectionProfileStore; const EventEmitter = require('events'); const fs = require('fs'); const FSConnectionProfileStore = require('composer-common').FSConnectionProfileStore; const Logger = require('composer-common').Logger; const ParticipantRegistry = require('./participantregistry'); const Query = require('./query'); const Resource = require('composer-common').Resource; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const TransactionRegistry = require('./transactionregistry'); const Util = require('composer-common').Util; const uuid = require('uuid'); const LOG = Logger.getLog('BusinessNetworkConnection'); /** * Use this class to connect to and then interact with a deployed BusinessNetworkDefinition. * Use the AdminConnection class in the composer-admin module to deploy BusinessNetworksDefinitions. * @extends EventEmitter * @see See [EventEmitter]{@link module:composer-client.EventEmitter} * @class * @memberof module:composer-client */ class BusinessNetworkConnection extends EventEmitter { /** * Create an instance of the BusinessNetworkConnection class. * must be called to connect to a deployed BusinessNetworkDefinition. * @param {Object} [options] - an optional set of options to configure the instance. * @param {Object} [options.fs] - specify an fs implementation to use. * @param {boolean} [options.developmentMode] - specify whether or not the instance * is in development mode. Use only for testing purposes! */ constructor(options) { super(); options = options || {}; this.developmentMode = options.developmentMode || false; this.connection = null; const fsConnectionProfileStore = new FSConnectionProfileStore(options.fs || fs); if (process.env.COMPOSER_CONFIG) { const envConnectionProfileStore = new EnvConnectionProfileStore(); this.connectionProfileStore = new ComboConnectionProfileStore( fsConnectionProfileStore, envConnectionProfileStore ); } else { this.connectionProfileStore = fsConnectionProfileStore; } this.connectionProfileManager = new ConnectionProfileManager(this.connectionProfileStore); this.connection = null; this.securityContext = null; this.businessNetwork = null; this.dynamicQueryFile = null; } /** * Returns the currently connected BusinessNetworkDefinition * @example * // Get the Business Network Definition * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getBusinessNetwork(); * }) * .then(function(BusinessNetworkDefinition){ * // Retrieved Business Network Definition * }); * @returns {BusinessNetworkDefinition} the business network */ getBusinessNetwork() { return this.businessNetwork; } /** * Get a list of all existing asset registries. * @example * // Get all asset registries * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAllAssetRegistries(); * }) * .then(function(assetRegistries){ * // Retrieved Asset Registries * }); * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with a list of existing * asset registries */ getAllAssetRegistries() { Util.securityCheck(this.securityContext); return AssetRegistry.getAllAssetRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get an existing asset registry. * @example * // Get a asset registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAssetRegistry('businessNetworkIdentifier.registryId'); * }) * .then(function(assetRegistry){ * // Retrieved Asset Registry * }); * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with the existing asset * registry, or rejected if the asset registry does not exist. */ getAssetRegistry(id) { Util.securityCheck(this.securityContext); return AssetRegistry.getAssetRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Determine whether a asset registry exists. * @example * // Determine whether an asset registry exists * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.assetRegistryExists('businessNetworkIdentifier.registryId'); * }) * .then(function(exists){ * // if (exists === true) { * // logic here... * //} * }); * @param {string} id - The unique identifier of the asset registry * @return {Promise} - A promise that will be resolved with a boolean indicating whether the asset * registry exists. */ assetRegistryExists(id) { Util.securityCheck(this.securityContext); return AssetRegistry.assetRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Add a new asset registry. * @example * // Add a new asset registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.addAssetRegistry('registryId','registryName'); * }); * @param {string} id - The unique identifier of the asset registry * @param {string} name - The name of the asset registry * @return {Promise} - A promise that will be resolved with the new asset * registry after it has been added. */ addAssetRegistry(id, name) { Util.securityCheck(this.securityContext); return AssetRegistry.addAssetRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get a list of all existing participant registries. * @example * // Get all participant registries * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getAllParticipantRegistries(); * }) * .then(function(participantRegistries){ * // Retrieved Participant Registries * }); * @param {SecurityContext} securityContext - The user's security context * @return {Promise} - A promise that will be resolved with a list of existing * participant registries */ getAllParticipantRegistries() { Util.securityCheck(this.securityContext); return ParticipantRegistry.getAllParticipantRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get an existing participant registry. * @example * // Get a participant registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getParticipantRegistry('businessNetworkIdentifier.registryId'); * }) * .then(function(participantRegistry){ * // Retrieved Participant Registry * }); * @param {string} id - The unique identifier of the participant registry * @return {Promise} - A promise that will be resolved with the existing participant * registry, or rejected if the participant registry does not exist. */ getParticipantRegistry(id) { Util.securityCheck(this.securityContext); return ParticipantRegistry.getParticipantRegistry(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Determine whether a participant registry exists. * @example * // Determine whether an asset registry exists * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.participantRegistryExists('businessNetworkIdentifier.registryId'); * }) * .then(function(exists){ * // if (exists === true) { * // logic here... * //} * }); * @param {string} id - The unique identifier of the participant registry * @return {Promise} - A promise that will be resolved with a boolean indicating whether the participant * registry exists. */ participantRegistryExists(id) { Util.securityCheck(this.securityContext); return ParticipantRegistry.participantRegistryExists(this.securityContext, id, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Add a new participant registry. * @example * // Add a new participant registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.addParticipantRegistry('registryId','registryName'); * }); * @param {string} id - The unique identifier of the participant registry * @param {string} name - The name of the participant registry * @return {Promise} - A promise that will be resolved with the new participant * registry after it has been added. */ addParticipantRegistry(id, name) { Util.securityCheck(this.securityContext); return ParticipantRegistry.addParticipantRegistry(this.securityContext, id, name, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()); } /** * Get the transaction registry. * @example * // Get the transaction registry * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.getTransactionRegistry(); * }) * .then(function(transactionRegistry){ * // Retrieved Transaction Registry * }); * @return {Promise} - A promise that will be resolved to the {@link TransactionRegistry} */ getTransactionRegistry() { Util.securityCheck(this.securityContext); return TransactionRegistry .getAllTransactionRegistries(this.securityContext, this.getBusinessNetwork().getModelManager(), this.getBusinessNetwork().getFactory(), this.getBusinessNetwork().getSerializer()) .then((transactionRegistries) =&gt; { if (transactionRegistries.length &gt;= 1) { return transactionRegistries[0]; } else { throw new Error('Failed to find the default transaction registry'); } }); } /** * Connects to a business network using a connection profile, and authenticates to the Hyperledger Fabric. * @example * // Connect and log in to HLF * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * // Connected * }); * @param {string} connectionProfile - The name of the connection profile * @param {string} businessNetwork - The identifier of the business network * @param {string} enrollmentID the enrollment ID of the user * @param {string} enrollmentSecret the enrollment secret of the user * @param {Object} [additionalConnectOptions] Additional configuration options supplied * at runtime that override options set in the connection profile. * which will override those in the specified connection profile. * @return {Promise} A promise to a BusinessNetworkDefinition that indicates the connection is complete */ connect(connectionProfile, businessNetwork, enrollmentID, enrollmentSecret, additionalConnectOptions) { const method = 'connect'; LOG.entry(method, connectionProfile, businessNetwork, enrollmentID, enrollmentSecret, additionalConnectOptions); return this.connectionProfileManager.connect(connectionProfile, businessNetwork, additionalConnectOptions) .then((connection) =&gt; { connection.on('events', (events) =&gt; { events.forEach((event) =&gt; { let serializedEvent = this.getBusinessNetwork().getSerializer().fromJSON(event); this.emit('event', serializedEvent); }); }); this.connection = connection; return connection.login(enrollmentID, enrollmentSecret); }) .then((securityContext) =&gt; { this.securityContext = securityContext; return this.connection.ping(this.securityContext); }) .then(() =&gt; { return Util.queryChainCode(this.securityContext, 'getBusinessNetwork', []); }) .then((buffer) =&gt; { let businessNetworkJSON = JSON.parse(buffer.toString()); let businessNetworkArchive = Buffer.from(businessNetworkJSON.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetwork) =&gt; { this.businessNetwork = businessNetwork; this.dynamicQueryFile = this.businessNetwork.getQueryManager().createQueryFile('$dynamic_queries.qry', ''); LOG.exit(method); return this.businessNetwork; }); } /** * Disconnects from the Hyperledger Fabric. * @example * // Disconnects from HLF * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetworkDefinition.disconnect(); * }) * .then(function(){ * // Disconnected. * }); * @return {Promise} A promise that will be resolved when the connection is * terminated. */ disconnect() { const method = 'disconnect'; LOG.entry(method); if (!this.connection) { return Promise.resolve(); } return this.connection.disconnect() .then(() =&gt; { this.connection.removeListener('events', () =&gt; { LOG.debug(method, 'removeLisener'); }); this.connection = null; this.securityContext = null; this.businessNetwork = null; this.dynamicQueryFile = null; LOG.exit(method); }); } /** * Submit a transaction for processing by the currently connected business network. * @example * // Submits a transaction * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * var factory = businessNetworkDefinition.getBusinessNetwork().getFactory(); * var transaction = factory.newTransaction('network.transactions', 'TransactionType'); * return businessNetworkDefinition.submitTransaction(transaction); * }) * .then(function(){ * // Submitted a transaction. * }); * @param {Resource} transaction - The transaction to submit. Use {@link * Factory#newTransaction newTransaction} to create this object. * @return {Promise} A promise that will be fulfilled when the transaction has * been processed. */ submitTransaction(transaction) { Util.securityCheck(this.securityContext); if (!transaction) { throw new Error('transaction not specified'); } let classDeclaration = transaction.getClassDeclaration(); if (!(classDeclaration instanceof TransactionDeclaration)) { throw new Error(classDeclaration.getFullyQualifiedName() + ' is not a transaction'); } let id = transaction.getIdentifier(); if (id === null || id === undefined) { id = uuid.v4(); transaction.setIdentifier(id); } let timestamp = transaction.timestamp; if (timestamp === null || timestamp === undefined) { timestamp = transaction.timestamp = new Date(); } let data = this.getBusinessNetwork().getSerializer().toJSON(transaction); return this.getTransactionRegistry(this.securityContext) .then((transactionRegistry) =&gt; { return Util.invokeChainCode(this.securityContext, 'submitTransaction', [transactionRegistry.id, JSON.stringify(data)]); }); } /** * Build a query ready for later execution. The specified query string must be written * in the Composer query language. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Build and execute a query. * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function () { * var query = businessNetwork.buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); * return businessNetwork.query(query, { inputValue: 'blue' }) * }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @param {string} query The query string, written using the Composer query language. * @return {Query} The built query, which can be passed in a call to query. */ buildQuery(query) { const method = 'buildQuery'; LOG.entry(method, query); const builtQuery = this.dynamicQueryFile.buildQuery('Dynamic query', 'Dynamic query', query); builtQuery.validate(); const result = new Query(query); LOG.exit(method, result); return result; } /** * Execute a query defined in a Composer query file, or execute a query built with buildQuery. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Execute the query. * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function () { * return query('Q1', { inputValue: 'blue' }) * }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @param {string|Query} query The name of the query, or a built query. * @param {Object} [parameters] The parameters for the query. * @return {Promise} A promise that will be resolved with an array of * {@link module:composer-common.Resource Resource} representing the * resources returned by the query. */ query(query, parameters) { const method = 'query'; LOG.entry(method, query, parameters); let queryType, identifier; if (query instanceof Query) { queryType = 'build'; identifier = query.getIdentifier(); } else if (typeof query === 'string') { queryType = 'named'; identifier = query; } else { throw new Error('Invalid query; expecting a built query or the name of a query'); } parameters = parameters || {}; return Util.queryChainCode(this.securityContext, 'executeQuery', [queryType, identifier, JSON.stringify(parameters)]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resources) =&gt; { const result = resources.map((resource) =&gt; { return this.getBusinessNetwork().getSerializer().fromJSON(resource); }); LOG.exit(method, result); return result; }); } /** * Test the connection to the runtime and verify that the version of the * runtime is compatible with this level of the client node.js module. * @example * // Test the connection to the runtime * var businessNetwork = new BusinessNetworkConnection(); * return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') * .then(function(businessNetworkDefinition){ * return businessNetwork.ping(); * }) * .then(function(){ * // Connection tested. * }); * @return {Promise} A promise that will be fufilled when the connection has * been tested. The promise will be rejected if the version is incompatible. */ ping() { Util.securityCheck(this.securityContext); return this.connection.ping(this.securityContext); } /** * Issue an identity with the specified user ID and map it to the specified * participant. * @param {Resource|string} participant The participant, or the fully qualified * identifier of the participant. The participant must already exist. * @param {string} userID The user ID for the identity. * @param {object} [options] Options for the new identity. * @param {boolean} [options.issuer] Whether or not the new identity should have * permissions to create additional new identities. False by default. * @return {Promise} A promise that will be fulfilled when the identity has * been added to the specified participant. The promise will be rejected if * the participant does not exist, or if the identity is already mapped to * another participant. */ issueIdentity(participant, userID, options) { const method = 'issueIdentity'; LOG.entry(method, participant, userID); if (!participant) { throw new Error('participant not specified'); } else if (!userID) { throw new Error('userID not specified'); } let participantFQI; if (participant instanceof Resource) { participantFQI = participant.getFullyQualifiedIdentifier(); } else { participantFQI = participant; } Util.securityCheck(this.securityContext); return this.connection.createIdentity(this.securityContext, userID, options) .then((identity) =&gt; { return Util.invokeChainCode(this.securityContext, 'addParticipantIdentity', [participantFQI, userID]) .then(() =&gt; { LOG.exit(method, identity); return identity; }); }); } /** * Revoke the specified identity by removing any existing mapping to a participant. * @param {string} identity The identity, for example the enrollment ID. * @return {Promise} A promise that will be fulfilled when the identity has * been removed from the specified participant. The promise will be rejected if * the participant does not exist, or if the identity is not mapped to the * participant. */ revokeIdentity(identity) { const method = 'revokeIdentity'; LOG.entry(method, identity); if (!identity) { throw new Error('identity not specified'); } Util.securityCheck(this.securityContext); // It is not currently possible to revoke the certificate, so we just call // the runtime to remove the mapping. return Util.invokeChainCode(this.securityContext, 'removeIdentity', [identity]) .then(() =&gt; { LOG.exit(method); }); } } module.exports = BusinessNetworkConnection; × Search results Close "},"composer-client_lib_participantregistry.js.html":{"id":"composer-client_lib_participantregistry.js.html","title":"Source: composer-client/lib/participantregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/participantregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Participant'; /** * The ParticipantRegistry is used to manage a set of participants stored on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/participantregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/participantregistry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class ParticipantRegistry extends Registry { /** * Get a list of all existing participant registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @return {Promise} A promise that will be resolved with a list of {@link ParticipantRegistry} * instances representing the participant registries. */ static getAllParticipantRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then((participantRegistries) =&gt; { return participantRegistries.map((participantRegistry) =&gt; { return new ParticipantRegistry(participantRegistry.id, participantRegistry.name, securityContext, modelManager, factory, serializer); }); }); } /** * Get an existing participant registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @return {Promise} A promise that will be resolved with a {@link ParticipantRegistry} * instance representing the participant registry. */ static getParticipantRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new ParticipantRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Determine whether a participant registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the asset registry. * @param {ModelManager} modelManager The ModelManager to use for this asset registry. * @param {Factory} factory The factory to use for this asset registry. * @param {Serializer} serializer The Serializer to use for this asset registry. * @return {Promise} A promise that will be resolved with a boolean indicating whether the asset registry exists */ static participantRegistryExists(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.existsRegistry(securityContext, REGISTRY_TYPE, id); } /** * Add a new participant registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the participant registry. * @param {string} name The name of the participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. * @return {Promise} A promise that will be resolved with a {@link ParticipantRegistry} * instance representing the new participant registry. */ static addParticipantRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new ParticipantRegistry(id, name, securityContext, modelManager, factory, serializer); }); } /** * Create an participant registry. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * @protected * @param {string} id The unique identifier of the participant registry. * @param {string} name The display name for the participant registry. * @param {SecurityContext} securityContext The security context to use for this participant registry. * @param {ModelManager} modelManager The ModelManager to use for this participant registry. * @param {Factory} factory The factory to use for this participant registry. * @param {Serializer} serializer The Serializer to use for this participant registry. */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } } module.exports = ParticipantRegistry; × Search results Close "},"composer-client_lib_query.js.html":{"id":"composer-client_lib_query.js.html","title":"Source: composer-client/lib/query.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/query.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Query'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-client#BusinessNetworkConnection.buildQuery buildQuery} * method instead. * * @class Query * @classdesc A query represents a built query. * @memberof module:composer-client * @public */ /** * The Query class represents a built query. A built query has been parsed and validated. * Do not attempt to create an instance of this class. * You must use the {@link module:composer-client#BusinessNetworkConnection.buildQuery buildQuery} * method instead. * @class * @memberof module:composer-client */ class Query { /** * Constructor. * @param {string} identifier The identifier of the built query. * @private */ constructor(identifier) { const method = 'constructor'; LOG.entry(method, identifier); this.identifier = identifier; LOG.exit(method); } /** * Get the identifier for this built query. * @private * @return {string} The identifier for this built query. */ getIdentifier() { return this.identifier; } } module.exports = Query; × Search results Close "},"composer-client_lib_registry.js.html":{"id":"composer-client_lib_registry.js.html","title":"Source: composer-client/lib/registry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/registry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Resource = require('composer-common').Resource; const Util = require('composer-common').Util; /** * Class representing an Abstract Registry. * &lt;p&gt;&lt;a href=&quot;./diagrams/registry.svg&quot;&gt;&lt;img src=&quot;./diagrams/registry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract * @class * @memberof module:composer-client */ class Registry { /** * Get a list of all existing registries. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the registries. */ static getAllRegistries(securityContext, registryType) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } return Util.queryChainCode(securityContext, 'getAllRegistries', [registryType]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get an existing registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static getRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'getRegistry', [registryType, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Determines whether a registry exists. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @return {Promise} A promise that will be resolved with true/false depending on whether the registry exists */ static existsRegistry(securityContext, registryType, id) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(securityContext, 'existsRegistry', [registryType, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Add a new asset registry. * * @protected * @param {SecurityContext} securityContext The user's security context. * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The name of the registry. * @return {Promise} A promise that will be resolved with a JSON object * representing the registry. */ static addRegistry(securityContext, registryType, id, name) { Util.securityCheck(securityContext); if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } return Util.invokeChainCode(securityContext, 'addRegistry', [registryType, id, name]) .then(() =&gt; { return { id: id, name: name }; }); } /** * Create a registry. * * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @protected * @param {string} registryType The type of this registry. * @param {string} id The unique identifier of the registry. * @param {string} name The display name for the registry. * @param {SecurityContext} securityContext The users security context. * @param {ModelManager} modelManager The ModelManager to use for this registry. * @param {Factory} factory The factory to use for this registry. * @param {Serializer} serializer The Serializer to use for this registry. */ constructor(registryType, id, name, securityContext, modelManager, factory, serializer) { if (!registryType) { throw new Error('registryType not specified'); } else if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!securityContext) { throw new Error('securityContext not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } this.registryType = registryType; this.id = id; this.name = name; this.securityContext = securityContext; this.modelManager = modelManager; this.factory = factory; this.serializer = serializer; } /** * Adds a list of new resources to the registry. * * @param {Resource[]} resources The resources to be added to the registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ addAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let serializedResources = resources.map((resource) =&gt; { return this.serializer.toJSON(resource); }); return Util.invokeChainCode(this.securityContext, 'addAllResourcesToRegistry', [this.registryType, this.id, JSON.stringify(serializedResources)]); } /** * Adds a new resource to the registry. * * @param {Resource} resource The resource to be added to the registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ add(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } let serializedResource = this.serializer.toJSON(resource); return Util.invokeChainCode(this.securityContext, 'addResourceToRegistry', [this.registryType, this.id, JSON.stringify(serializedResource)]); } /** * Updates a list of resources in the registry. * * @param {Resource[]} resources The resources to be updated in the asset registry. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ updateAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let serializedResources = resources.map((resource) =&gt; { return this.serializer.toJSON(resource); }); return Util.invokeChainCode(this.securityContext, 'updateAllResourcesInRegistry', [this.registryType, this.id, JSON.stringify(serializedResources)]); } /** * Updates a resource in the registry. * * @param {Resource} resource The resource to be updated in the registry. * @return {Promise} A promise that will be resolved when the resource is * updated in the registry. */ update(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } let serializedResource = this.serializer.toJSON(resource); return Util.invokeChainCode(this.securityContext, 'updateResourceInRegistry', [this.registryType, this.id, JSON.stringify(serializedResource)]); } /** * Removes a list of resources from the registry. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. * @return {Promise} A promise that will be resolved when the resource is * added to the registry. */ removeAll(resources) { Util.securityCheck(this.securityContext); if (!resources) { throw new Error('resources not specified'); } let data = resources.map((resource) =&gt; { if (resource instanceof Resource) { return resource.getIdentifier(); } else { return resource; } }); return Util.invokeChainCode(this.securityContext, 'removeAllResourcesFromRegistry', [this.registryType, this.id, JSON.stringify(data)]); } /** * Remove an asset with a given type and id from the registry. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. * @return {Promise} A promise that will be resolved when the resource is * removed from the registry. */ remove(resource) { Util.securityCheck(this.securityContext); if (!resource) { throw new Error('resource not specified'); } let id; if (resource instanceof Resource) { id = resource.getIdentifier(); } else { id = resource; } return Util.invokeChainCode(this.securityContext, 'removeResourceFromRegistry', [this.registryType, this.id, id]); } /** * Get all of the resources in the registry. * * @return {Promise} A promise that will be resolved with an array of JSON * objects representing the resources. */ getAll() { Util.securityCheck(this.securityContext); return Util.queryChainCode(this.securityContext, 'getAllResourcesInRegistry', [this.registryType, this.id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return this.serializer.fromJSON(resource); }); }); } /** * Get a specific resource in the registry. * * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved with a JSON object * representing the resource. */ get(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'getResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resource) =&gt; { return this.serializer.fromJSON(resource); }); } /** * Determines whether a specific resource exists in the registry. * * @param {string} id The unique identifier of the resource. * @return {Promise} A promise that will be resolved with true/false depending on whether the resource exists. */ exists(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'existsResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Find resources in the registry that match the specified JSONata expression. * The JSONata expression is applied to each resource in the registry, and * resources are returned if the JSONata expression returns a truthy value for that * resource. * * @param {string} expression The JSONata expression. * @return {Promise} A promise that will be resolved with an array of {@link * Resource} instances representing the assets that match the query. */ find(expression) { Util.securityCheck(this.securityContext); if (!expression) { throw new Error('expression not specified'); } return Util.queryChainCode(this.securityContext, 'findResourcesInRegistry', [this.registryType, this.id, expression]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return this.serializer.fromJSON(resource); }); }); } /** * Execute a query against all resources in the registry. The JSONata * expression is applied to each resource in the registry, and the result * of the JSONata expression is returned if the result is truthy. The result * is a JavaScript object, and should only be used for visualization * purposes. You cannot use the {@link add} or {@link update} functions with * data returned by this function. * * @param {string} expression The JSONata expression. * @return {Promise} A promise that will be resolved with an array of JavaScript * objects representing the resources and all of their resolved relationships. */ query(expression) { Util.securityCheck(this.securityContext); if (!expression) { throw new Error('expression not specified'); } return Util.queryChainCode(this.securityContext, 'queryResourcesInRegistry', [this.registryType, this.id, expression]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get all of the resources in the registry, and resolve all of their relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved resource. * * @return {Promise} A promise that will be resolved with an array of JavaScript * objects representing the resources and all of their resolved relationships. */ resolveAll() { Util.securityCheck(this.securityContext); return Util.queryChainCode(this.securityContext, 'resolveAllResourcesInRegistry', [this.registryType, this.id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } /** * Get a specific resource in the registry, and resolve all of its relationships * to other assets, participants, and transactions. The result is a JavaScript * object, and should only be used for visualization purposes. You cannot use * the {@link add} or {@link update} functions with a resolved resource. * * @param {string} id The unique identifier of the asset. * @return {Promise} A promise that will be resolved with a JavaScript object * representing the resource and all of its resolved relationships. */ resolve(id) { Util.securityCheck(this.securityContext); if (!id) { throw new Error('id not specified'); } return Util.queryChainCode(this.securityContext, 'resolveResourceInRegistry', [this.registryType, this.id, id]) .then((buffer) =&gt; { return JSON.parse(buffer.toString()); }); } } module.exports = Registry; × Search results Close "},"composer-client_lib_transactionregistry.js.html":{"id":"composer-client_lib_transactionregistry.js.html","title":"Source: composer-client/lib/transactionregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-client/lib/transactionregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Registry = require('./registry'); const Util = require('composer-common').Util; const REGISTRY_TYPE = 'Transaction'; /** * The TransactionRegistry is used to store a set of transactions on the blockchain. * &lt;p&gt;&lt;a href=&quot;./diagrams/transactionregistry.svg&quot;&gt;&lt;img src=&quot;./diagrams/transactionregistry.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Registry * @see See [Registry]{@link module:composer-client.Registry} * @class * @memberof module:composer-client */ class TransactionRegistry extends Registry { /** * Get a list of all existing transaction registries. * * @param {SecurityContext} securityContext The user's security context. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a list of {@link TransactionRegistry} * instances representing the transaction registries. */ static getAllTransactionRegistries(securityContext, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getAllRegistries(securityContext, REGISTRY_TYPE) .then((transactionRegistries) =&gt; { return transactionRegistries.map((transactionRegistry) =&gt; { return new TransactionRegistry(transactionRegistry.id, transactionRegistry.name, securityContext, modelManager, factory, serializer); }); }); } /** * Get an existing transaction registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the transaction registry. */ static getTransactionRegistry(securityContext, id, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.getRegistry(securityContext, REGISTRY_TYPE, id) .then((registry) =&gt; { return new TransactionRegistry(registry.id, registry.name, securityContext, modelManager, factory, serializer); }); } /** * Add a new transaction registry. * * @param {SecurityContext} securityContext The user's security context. * @param {string} id The unique identifier of the transaction registry. * @param {string} name The name of the transaction registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @return {Promise} A promise that will be resolved with a {@link TransactionRegistry} * instance representing the new transaction registry. */ static addTransactionRegistry(securityContext, id, name, modelManager, factory, serializer) { Util.securityCheck(securityContext); if (!id) { throw new Error('id not specified'); } else if (!name) { throw new Error('name not specified'); } else if (!modelManager) { throw new Error('modelManager not specified'); } else if (!factory) { throw new Error('factory not specified'); } else if (!serializer) { throw new Error('serializer not specified'); } return Registry.addRegistry(securityContext, REGISTRY_TYPE, id, name) .then(() =&gt; { return new TransactionRegistry(id, name, securityContext, modelManager, factory, serializer); }); } /** * Create an transaction registry. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkConnection}&lt;/strong&gt; * &lt;/p&gt; * * @param {string} id The unique identifier of the transaction registry. * @param {string} name The display name for the transaction registry. * @param {SecurityContext} securityContext The security context to use for this asset registry. * @param {ModelManager} modelManager The ModelManager to use for this transaction registry. * @param {Factory} factory The factory to use for this transaction registry. * @param {Serializer} serializer The Serializer to use for this transaction registry. * @private */ constructor(id, name, securityContext, modelManager, factory, serializer) { super(REGISTRY_TYPE, id, name, securityContext, modelManager, factory, serializer); } /** * Unsupported operation; you cannot add a transaction to a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource} resource The resource to be added to the registry. * @param {string} data The data for the resource. * @private */ add(resource) { throw new Error('cannot add transactions to a transaction registry'); } /** * Unsupported operation; you cannot add a transaction to a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource[]} resources The resources to be added to the registry. * @private */ addAll(resources) { throw new Error('cannot add transactions to a transaction registry'); } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. This method will always throw an exception when called. * * @param {Resource} resource The resource to be updated in the registry. * @private */ update(resource) { throw new Error('cannot update transactions in a transaction registry'); } /** * Unsupported operation; you cannot update a transaction in a transaction * registry. Call {@link BusinessNetworkConnection.submitTransaction} to submit a transaction. * * @param {Resource[]} resources The resources to be updated in the asset registry. * @private */ updateAll(resources) { throw new Error('cannot update transactions in a transaction registry'); } /** * Unsupported operation; you cannot remove a transaction from a transaction * registry. This method will always throw an exception when called. * * @param {(Resource|string)} resource The resource, or the unique identifier of the resource. * @private */ remove(resource) { throw new Error('cannot remove transactions from a transaction registry'); } /** * Unsupported operation; you cannot remove a transaction from a transaction * registry. This method will always throw an exception when called. * * @param {(Resource[]|string[])} resources The resources, or the unique identifiers of the resources. * @private */ removeAll(resources) { throw new Error('cannot remove transactions from a transaction registry'); } } module.exports = TransactionRegistry; × Search results Close "},"composer-common_index.js.html":{"id":"composer-common_index.js.html","title":"Source: composer-common/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Hyperledger-Composer module. Hyperledger-Composer is a framework for creating * blockchain backed digital networks and exchanging assets between participants * via processing transactions. * @module composer-common */ /** * Check whether we're running in a version of node which has the updated Buffer implementation * Used above to fall back to the old version if needed. * @return {boolean} whether the new version is supported */ function nodeHasNewBufferVersion() { try { Buffer.from('b2xkbm9kZQ==', 'base64'); return true; } catch (e) { /* istanbul ignore next */ return false; } } /* istanbul ignore next */ if (!nodeHasNewBufferVersion()) { const originalBufferFrom = Buffer.from; const newBufferFrom = function (str, encoding) { if (arguments.length === 2 &amp;&amp; typeof str === 'string' &amp;&amp; encoding === 'base64') { return new Buffer(str, encoding); } return originalBufferFrom.apply(null, arguments); }; Object.defineProperty(Buffer, 'from', { value: newBufferFrom }); } module.exports.AclFile = require('./lib/acl/aclfile'); module.exports.AclManager = require('./lib/aclmanager'); module.exports.AssetDeclaration = require('./lib/introspect/assetdeclaration'); module.exports.BaseException = require('./lib/baseexception'); module.exports.BaseModelException = require('./lib/introspect/basemodelexception'); module.exports.BusinessNetworkDefinition = require('./lib/businessnetworkdefinition'); module.exports.BusinessNetworkMetadata = require('./lib/businessnetworkmetadata'); module.exports.ClassDeclaration = require('./lib/introspect/classdeclaration'); module.exports.CodeGen = require('./lib/codegen/codegen.js'); module.exports.ComboConnectionProfileStore = require('./lib/comboconnectionprofilestore'); module.exports.Concept = require('./lib/model/concept'); module.exports.ConceptDeclaration = require('./lib/introspect/conceptdeclaration'); module.exports.Connection = require('./lib/connection'); module.exports.ConnectionManager = require('./lib/connectionmanager'); module.exports.ConnectionProfileManager = require('./lib/connectionprofilemanager'); module.exports.ConnectionProfileStore = require('./lib/connectionprofilestore'); module.exports.ConsoleLogger = require('./lib/log/consolelogger'); module.exports.EnvConnectionProfileStore = require('./lib/envconnectionprofilestore'); module.exports.EventDeclaration = require('./lib/introspect/eventdeclaration'); module.exports.Factory = require('./lib/factory'); module.exports.FileWallet = require('./lib/filewallet'); module.exports.FileWriter = require('./lib/codegen/filewriter'); module.exports.FSConnectionProfileStore = require('./lib/fsconnectionprofilestore'); module.exports.Globalize = require('./lib/globalize'); module.exports.Introspector = require('./lib/introspect/introspector'); module.exports.Limit = require('./lib/query/limit'); module.exports.Logger = require('./lib/log/logger'); module.exports.LoopbackVisitor = require('./lib/codegen/fromcto/loopback/loopbackvisitor'); module.exports.ModelFile = require('./lib/introspect/modelfile'); module.exports.ModelManager = require('./lib/modelmanager'); module.exports.OrderBy = require('./lib/query/orderby'); module.exports.ParticipantDeclaration = require('./lib/introspect/participantdeclaration'); module.exports.Property = require('./lib/introspect/property'); module.exports.Query = require('./lib/query/query'); module.exports.QueryFile = require('./lib/query/queryfile'); module.exports.QueryManager = require('./lib/querymanager'); module.exports.Relationship = require('./lib/model/relationship'); module.exports.RelationshipDeclaration = require('./lib/introspect/relationshipdeclaration'); module.exports.Resource = require('./lib/model/resource'); module.exports.ScriptManager = require('./lib/scriptmanager'); module.exports.Script = require('./lib/introspect/script'); module.exports.ScriptManager = require('./lib/scriptmanager'); module.exports.SecurityContext = require('./lib/securitycontext'); module.exports.SecurityException = require('./lib/securityexception'); module.exports.Select = require('./lib/query/select'); module.exports.Serializer = require('./lib/serializer'); module.exports.Skip = require('./lib/query/skip'); module.exports.Sort = require('./lib/query/sort'); module.exports.TransactionDeclaration = require('./lib/introspect/transactiondeclaration'); module.exports.TypescriptVisitor = require('./lib/codegen/fromcto/typescript/typescriptvisitor'); module.exports.Util = require('./lib/util'); module.exports.ModelUtil = require('./lib/modelutil'); module.exports.Wallet = require('./lib/wallet'); module.exports.Where = require('./lib/query/where'); module.exports.Writer = require('./lib/codegen/writer.js'); module.exports.version = require('./package.json'); × Search results Close "},"composer-common_lib_acl_aclfile.js.html":{"id":"composer-common_lib_acl_aclfile.js.html","title":"Source: composer-common/lib/acl/aclfile.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/aclfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const AclRule = require('./aclrule'); const ParseException = require('../introspect/parseexception'); /** * Class representing an ACL File. * @private * @class * @memberof module:composer-common */ class AclFile { /** * Create an AclFile. This should only be called by framework code. * @param {string} id - The identifier of this ACL File (may be a filename for example) * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile and that will be used to validate the rules in the AclFile * @param {string} definitions - The ACL rules as a string. * @throws {IllegalModelException} */ constructor(id, modelManager, definitions) { this.modelManager = modelManager; this.rules = []; this.identifier = id; if(!definitions || typeof definitions !== 'string') { throw new Error('AclFile expects an AclFile as a string as input.'); } this.definitions = definitions; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException(err.message, err.location); } else { throw err; } } for(let n=0; n &lt; this.ast.rules.length; n++ ) { let thing = this.ast.rules[n]; const aclRule = new AclRule(this, thing); // TODO (DCS) check that the id of the AclRule does not already exist this.rules.push(aclRule); } // console.log(JSON.stringify(this.ast)); } /** * Returns the identifier of this ACL File. * @return {string} the identifier of this ACL File */ getIdentifier() { return this.identifier; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this AclFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { const aclRules = {}; this.rules.forEach((aclRule) =&gt; { aclRule.validate(); let name = aclRule.getName(); if (aclRules[name]){ throw new Error(`Found two or more ACL rules with the name '${name}'`); } aclRules[name] = aclRule; }); } /** * Get all declarations in this ACL file * @return {AclRule[]} the AclRules defined in the ACL file */ getAclRules() { return this.rules; } /** * Get the definitions for this ACL file. * @return {string} The definitions for this ACL file. */ getDefinitions() { return this.definitions; } } module.exports = AclFile; × Search results Close "},"composer-common_lib_aclmanager.js.html":{"id":"composer-common_lib_aclmanager.js.html","title":"Source: composer-common/lib/aclmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/aclmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AclFile = require('./acl/aclfile'); /** * &lt;p&gt; * Manages a set of ACL rules. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class AclManager { /** * Create the AclManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this AclManager * @param {AclFile} aclFile - The AclFile that stores the rules */ constructor(modelManager) { this.modelManager = modelManager; this.aclFile = null; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Create an ACL file using the specified ID and contents. * @param {string} identifier The identifier of the ACL file. * @param {string} contents The contents of the ACL file. * @return {AclFile} The new ACL file. */ createAclFile(identifier, contents) { return new AclFile(identifier, this.modelManager, contents); } /** * Set the AclFile for this AclManager * @param {AclFile} aclFile - the AclFile to associate with this AclManager * @private */ setAclFile(aclFile) { aclFile.validate(); this.aclFile = aclFile; } /** * Get the AclFile associated with this AclManager * @return {AclFile} The AclFile for this AclManager or null if it has not been set */ getAclFile() { return this.aclFile; } /** * Get the AclRules associated with this AclManager * @return {AclRule[]} The AclRules for the AclManager or an empty array if not set */ getAclRules() { if(this.aclFile) { return this.aclFile.getAclRules(); } return []; } } module.exports = AclManager; × Search results Close "},"composer-common_lib_acl_aclrule.js.html":{"id":"composer-common_lib_acl_aclrule.js.html","title":"Source: composer-common/lib/acl/aclrule.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/aclrule.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ModelBinding = require('./modelbinding'); const ParticipantDeclaration = require('../introspect/participantdeclaration'); const Predicate = require('./predicate'); const TransactionDeclaration = require('../introspect/transactiondeclaration'); /** * AclRule captures the details of an Access Control Rule. It is defined in terms of * an ACTION performed on a NOUN by a PARTICIPANT with a PREDICATE used to filter the * NOUN/PARTICPANT interaction. * * @private * @class * @memberof module:composer-common */ class AclRule { /** * Create an AclRule from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclFile} aclFile - the AclFile for this rule * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(aclFile, ast) { if(!aclFile || !ast) { throw new IllegalModelException('Invalid AclFile or AST'); } this.ast = ast; this.aclFile = aclFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclFile that owns this AclRule. * * @return {AclFile} the owning AclFile */ getAclFile() { return this.aclFile; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.name = this.ast.id.name; this.noun = new ModelBinding(this, this.ast.noun, this.ast.nounVariable); this.verbs = this.ast.verbs; this.participant = null; if(this.ast.participant &amp;&amp; this.ast.participant !== 'ANY') { this.participant = new ModelBinding(this, this.ast.participant, this.ast.participantVariable); } this.transaction = null; if(this.ast.transaction) { this.transaction = new ModelBinding(this, this.ast.transaction.binding, this.ast.transaction.variableBinding); } this.predicate = null; if(this.ast.predicate) { this.predicate = new Predicate(this, this.ast.predicate); } else { this.predicate = new Predicate(this, 'true'); } this.action = this.ast.action; this.description = this.ast.description; } /** * Semantic validation of the structure of this AclRule. * * @throws {IllegalModelException} * @private */ validate() { this.noun.validate(); const foundVerbs = {}; this.verbs.forEach((verb) =&gt; { if (foundVerbs[verb]) { throw new IllegalModelException(`The verb '${verb}' has been specified more than once in the ACL rule '${this.name}'`); } foundVerbs[verb] = true; }); if(this.participant) { this.participant.validate(); let participantClassDeclaration = this.participant.getClassDeclaration(); if (participantClassDeclaration &amp;&amp; !(participantClassDeclaration instanceof ParticipantDeclaration)) { throw new IllegalModelException(`The participant '${participantClassDeclaration.getName()}' must be a participant`); } } if(this.transaction) { this.transaction.validate(); let transactionClassDeclaration = this.transaction.getClassDeclaration(); if (transactionClassDeclaration &amp;&amp; !(transactionClassDeclaration instanceof TransactionDeclaration)) { throw new IllegalModelException(`The transaction '${transactionClassDeclaration.getName()}' must be a transaction`); } } if(this.predicate) { this.predicate.validate(); } } /** * Returns the name of this AclRule. * * @return {string} the name of the AclRule */ getName() { return this.name; } /** * Returns the noun for this ACL rule. * * @return {ModelBinding} the noun ModelBinding */ getNoun() { return this.noun; } /** * Returns the verb associated with this ACL Rule. * * @return {string} the verb */ getVerbs() { return this.verbs; } /** * Returns the participant for this ACL rule. Returns null if this rule * does not filter based on participant. * * @return {ModelBinding} the participant ModelBinding or null */ getParticipant() { return this.participant; } /** * Returns the transaction for this ACL rule. Returns null if this rule * does not filter based on transaction. * * @return {ModelBinding} the transaction ModelBinding or null */ getTransaction() { return this.transaction; } /** * Returns the predicate associated with this ACL Rule * * @return {Predicate} the predicate */ getPredicate() { return this.predicate; } /** * Returns the action associated with this ACL Rule. * * @return {string} the action */ getAction() { return this.action; } /** * Returns the description associated with this ACL Rule. * * @return {string} the description */ getDescription() { return this.description; } } module.exports = AclRule; × Search results Close "},"composer-common_lib_codegen_fromjs_apisignaturegenerator.js.html":{"id":"composer-common_lib_codegen_fromjs_apisignaturegenerator.js.html","title":"Source: composer-common/lib/codegen/fromjs/apisignaturegenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/fromjs/apisignaturegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const Writer = require('../writer'); /** * Converts the includes, classes and methods in a Javascript * file into an API Signature File called api.txt, stored in the * output directory. * @private * @class * @memberof module:composer-common */ class APISignatureGenerator { /** * @param {Object} program - the program arguments * @param {Object} file - the file instance being processed * @param {Object[]} includes - the includes (require statements) within the file * @param {Object[]} classes - the classes within the file * @param {Object[]} functions - the functions within the file */ generate(program, file, includes, classes, functions) { // generate the output if(classes.length &gt; 0 || functions.length &gt; 0) { let writer = new Writer(); for(let n=0; n &lt; classes.length; n++) { const clazz = classes[n]; let superType = ''; if(clazz.superClass) { superType = ' extends ' + clazz.superClass; } writer.writeLine(0, 'class ' + clazz.name + superType + ' {' ); for(let i=0; i &lt; clazz.methods.length; i++) { const method = clazz.methods[i]; let throws = ''; if(method.throws) { throws = 'throws ' + method.throws; } writer.writeLine(1, method.visibility + ' ' + method.returnType + ' ' + method.name + paramsToString(method.methodArgs) + ' ' + throws ); } writer.writeLine(0, '}'); } for(let n=0; n &lt; functions.length; n++) { const func = functions[n]; let throws = ''; if(func.throws) { throws = 'throws ' + func.throws; } writer.writeLine(1, func.visibility + ' ' + func.returnType + ' ' + func.name + paramsToString(func.methodArgs) + ' ' + throws ); } fs.appendFileSync(program.outputDir + '/api.txt', writer.getBuffer()); } } } /** * Converts an array of parameter types to a string * @param {string[]} paramTypes array of parameter type names * @return {string} - string representation * @private */ function paramsToString(paramTypes) { let result = '('; for(let n=0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if(n &lt; paramTypes.length-1) { result += ','; } } result += ')'; return result; } module.exports = APISignatureGenerator; × Search results Close "},"composer-common_lib_introspect_assetdeclaration.js.html":{"id":"composer-common_lib_introspect_assetdeclaration.js.html","title":"Source: composer-common/lib/introspect/assetdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/assetdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); /** * AssetDeclaration defines the schema (aka model or class) for * an Asset. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class AssetDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return true; } /** * Returns the base system type for Assets from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Asset'; } /** * Semantic validation of the structure of this asset. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Asset') { throw new IllegalModelException('Asset is a reserved type name.', this.modelFile, this.ast.location); } } } module.exports = AssetDeclaration; × Search results Close "},"composer-common_lib_baseexception.js.html":{"id":"composer-common_lib_baseexception.js.html","title":"Source: composer-common/lib/baseexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/baseexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * A base class for all Composer exceptions * &lt;p&gt;&lt;a href=&quot;./diagrams/baseexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/baseexception.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends Error * @class * @memberof module:composer-common */ class BaseException extends Error { /** * Create the BaseException. * @param {string} message - The exception message. */ constructor(message) { super(message); this.name = this.constructor.name; this.message = message; if (typeof Error.captureStackTrace === 'function') { Error.captureStackTrace(this, this.constructor); } } } module.exports = BaseException; × Search results Close "},"composer-common_lib_introspect_basemodelexception.js.html":{"id":"composer-common_lib_introspect_basemodelexception.js.html","title":"Source: composer-common/lib/introspect/basemodelexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/basemodelexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception throws when a composer file is semantically invalid * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class BaseModelException extends BaseException { /** * Create an IllegalModelException * @param {string} message - the message for the exception * @param {string} fileLocation - the optional file location associated with the exception * @param {string} fullMessage - the optional full message text */ constructor(message, fileLocation, fullMessage) { super(fullMessage ? fullMessage : message); this.fileLocation = fileLocation; this.shortMessage = message; } /** * Returns the file location associated with the exception or null * @return {string} the optional location associated with the exception */ getFileLocation() { return this.fileLocation; } /** * Returns the error message without the location of the error * @returns {string} the error message */ getShortMessage() { return this.shortMessage; } } module.exports = BaseModelException; × Search results Close "},"composer-common_lib_businessnetworkdefinition.js.html":{"id":"composer-common_lib_businessnetworkdefinition.js.html","title":"Source: composer-common/lib/businessnetworkdefinition.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/businessnetworkdefinition.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AclFile = require('./acl/aclfile'); const AclManager = require('./aclmanager'); const QueryFile = require('./query/queryfile'); const QueryManager = require('./querymanager'); const BusinessNetworkMetadata = require('./businessnetworkmetadata'); const Factory = require('./factory'); const fs = require('fs'); const fsPath = require('path'); const Introspector = require('./introspect/introspector'); const JSZip = require('jszip'); const Logger = require('./log/logger'); const ModelManager = require('./modelmanager'); const minimatch = require('minimatch'); const ScriptManager = require('./scriptmanager'); const semver = require('semver'); const Serializer = require('./serializer'); const ENCODING = 'utf8'; const LOG = Logger.getLog('BusinessNetworkDefinition'); /** * &lt;p&gt; * A BusinessNetworkDefinition defines a set of Participants that exchange Assets by * sending Transactions. This class manages the metadata and domain-specific types for * the network as well as a set of executable scripts. * &lt;/p&gt; * @class * @memberof module:composer-common */ class BusinessNetworkDefinition { /** * Create the BusinessNetworkDefinition. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition.fromArchive}&lt;/strong&gt; * &lt;/p&gt; * @param {String} identifier - the identifier of the business network. The * identifier is formed from a business network name + '@' + version. The * version is a semver valid version string. If package.json is passed this is ignored. * @param {String} description - the description of the business network. If package.json is passed then this is ignored. * @param {object} packageJson - the JS object for package.json (optional) * @param {String} readme - the readme in markdown for the business network (optional) */ constructor(identifier, description, packageJson, readme) { const method = 'constructor'; LOG.entry(method, identifier, description); // if package.json is not present we generate one based on the metadata passed if(!packageJson) { const atIndex = identifier.lastIndexOf('@'); let name = null; if (atIndex &gt;= 0) { name = identifier.substring(0, atIndex); } else { throw new Error('Malformed business network identifier. It must be &quot;name@major.minor.micro&quot;'); } const version = identifier.substring(atIndex + 1); if (!semver.valid(version)) { throw new Error('Version number is invalid. Should be valid according to semver but found: ' + version); } packageJson = {}; packageJson.name = name; packageJson.version = version; packageJson.description = description; LOG.debug(method, 'Created package.json' + JSON.stringify(packageJson)); } else { LOG.debug(method, 'Using package.json' + JSON.stringify(packageJson)); } this.modelManager = new ModelManager(); this.aclManager = new AclManager(this.modelManager); this.queryManager = new QueryManager(this.modelManager); this.scriptManager = new ScriptManager(this.modelManager); this.introspector = new Introspector(this.modelManager); this.factory = new Factory(this.modelManager); this.serializer = new Serializer(this.factory, this.modelManager); this.metadata = new BusinessNetworkMetadata(packageJson,readme); LOG.exit(method); } /** * Returns the identifier for this business network * @return {String} the identifier of this business network */ getIdentifier() { return this.getMetadata().getIdentifier(); } /** * Returns the metadata for this business network * @return {BusinessNetworkMetadata} the metadata for this business network */ getMetadata() { return this.metadata; } /** * Returns the name for this business network * @return {String} the name of this business network */ getName() { return this.getMetadata().getName(); } /** * Returns the version for this business network * @return {String} the version of this business network. Use semver module * to parse. */ getVersion() { return this.getMetadata().getVersion(); } /** * Returns the description for this business network * @return {String} the description of this business network */ getDescription() { return this.getMetadata().getDescription(); } /** * Create a BusinessNetworkDefinition from an archive. * @param {Buffer} Buffer - the Buffer to a zip archive * @return {Promise} a Promise to the instantiated business network */ static fromArchive(Buffer) { const method = 'fromArchive'; LOG.entry(method, Buffer.length); return JSZip.loadAsync(Buffer).then(function(zip) { let promise = Promise.resolve(); let ctoModelFiles = []; let ctoModelFileNames = []; let jsScriptFiles = []; let permissionsFiles = []; let queriesFiles = []; let businessNetworkDefinition; let readmeContents = null; let packageJsonContents = null; LOG.debug(method, 'Loading README.md'); let readme = zip.file('README.md'); if(readme) { promise = promise.then(() =&gt; { return readme.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded README.md'); readmeContents = contents; }); } LOG.debug(method, 'Loading package.json'); let packageJson = zip.file('package.json'); if (packageJson === null) { throw Error('package.json must exist'); } promise = promise.then(() =&gt; { return packageJson.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded package.json'); packageJsonContents = JSON.parse(contents); }); LOG.debug(method, 'Looking for model files'); let ctoFiles = zip.file(/models\\/.*\\.cto$/); //Matches any file which is in the 'models' folder and has a .cto extension ctoFiles.forEach(function(file) { LOG.debug(method, 'Found model file, loading it', file.name); ctoModelFileNames.push(file.name); promise = promise.then(() =&gt; { return file.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded model file'); ctoModelFiles.push(contents); }); }); LOG.debug(method, 'Looking for JavaScript files'); let jsFiles = zip.file(/lib\\/.*\\.js$/); //Matches any file which is in the 'lib' folder and has a .js extension jsFiles.forEach(function(file) { LOG.debug(method, 'Found JavaScript file, loading it', file.name); promise = promise.then(() =&gt; { return file.async('string'); }).then((contents) =&gt; { LOG.debug(method, 'Loaded JavaScript file'); let tempObj = { 'name': file.name, 'contents': contents }; jsScriptFiles.push(tempObj); }); }); LOG.debug(method, 'Loading permissions.acl'); let aclFile = zip.file('permissions.acl'); if (aclFile !== null) { promise = promise.then(() =&gt; { return aclFile.async('string'); }).then(contents =&gt; { LOG.debug(method, 'Loaded permissions.acl'); permissionsFiles.push(contents); }); } LOG.debug(method, 'Loading query queries.qry'); let queryFile = zip.file('queries.qry'); if (queryFile !== null) { promise = promise.then(() =&gt; { return queryFile.async('string'); }).then(contents =&gt; { LOG.debug(method, 'Loaded queries.qry'); queriesFiles.push(contents); }); } return promise.then(() =&gt; { LOG.debug(method, 'Loaded package.json'); businessNetworkDefinition = new BusinessNetworkDefinition(null, null, packageJsonContents, readmeContents); LOG.debug(method, 'Loaded all model, JavaScript, ACL files and Query files'); LOG.debug(method, 'Adding model files to model manager'); businessNetworkDefinition.modelManager.addModelFiles(ctoModelFiles,ctoModelFileNames); // Adds all cto files to model manager LOG.debug(method, 'Added model files to model manager'); // console.log('What are the jsObjectsArray?',jsObjectArray); LOG.debug(method, 'Adding JavaScript files to script manager'); jsScriptFiles.forEach(function(obj) { let jsObject = businessNetworkDefinition.scriptManager.createScript(obj.name, 'js', obj.contents); businessNetworkDefinition.scriptManager.addScript(jsObject); // Adds all js files to script manager }); LOG.debug(method, 'Added JavaScript files to script manager'); LOG.debug(method, 'Adding ACL files to ACL manager'); permissionsFiles.forEach((permissionFile) =&gt; { businessNetworkDefinition.getAclManager().setAclFile( new AclFile('permissions.acl', businessNetworkDefinition.getModelManager(), permissionFile)); }); LOG.debug(method, 'Added ACL files to ACL manager'); LOG.debug(method, 'Adding Query files to query manager'); queriesFiles.forEach((queryFile) =&gt; { businessNetworkDefinition.getQueryManager().setQueryFile( new QueryFile('queries.qry', businessNetworkDefinition.getModelManager(), queryFile)); }); LOG.debug(method, 'Added Query files to query manager'); LOG.exit(method, businessNetworkDefinition.toString()); return businessNetworkDefinition; // Returns business network (with model manager and script manager) }); }); } /** * Store a BusinessNetworkDefinition as an archive. * @param {Object} [options] - JSZip options * @return {Buffer} buffer - the zlib buffer */ toArchive(options) { let zip = new JSZip(); let packageFileContents = JSON.stringify(this.getMetadata().getPackageJson()); zip.file('package.json', packageFileContents, options); // save the README.md if present if(this.getMetadata().getREADME()) { zip.file('README.md', this.getMetadata().getREADME(), options); } const aclFile = this.getAclManager().getAclFile(); if(aclFile) { zip.file(aclFile.getIdentifier(), aclFile.definitions, options); } const queryFile = this.getQueryManager().getQueryFile(); if(queryFile) { zip.file(queryFile.getIdentifier(), queryFile.definitions, options); } let modelManager = this.getModelManager(); let modelFiles = modelManager.getModelFiles(); zip.file('models/', null, Object.assign({}, options, { dir: true })); modelFiles.forEach(function(file) { let fileName; // ignore the system namespace when creating an archive if (file.isSystemModelFile()){ return; } if (file.fileName === 'UNKNOWN' || file.fileName === null || !file.fileName) { fileName = file.namespace + '.cto'; } else { let fileIdentifier = file.fileName; fileName = fsPath.parse(fileIdentifier).base; } zip.file('models/' + fileName, file.definitions, options); }); let scriptManager = this.getScriptManager(); let scriptFiles = scriptManager.getScripts(); zip.file('lib/', null, Object.assign({}, options, { dir: true })); scriptFiles.forEach(function(file) { let fileIdentifier = file.identifier; let fileName = fsPath.parse(fileIdentifier).base; zip.file('lib/' + fileName, file.contents, options); }); return zip.generateAsync({ type: 'nodebuffer' }).then(something =&gt; { return Promise.resolve(something).then(result =&gt; { return result; }); }); } /** * Builds a BusinessNetworkDefintion from the contents of a directory. * The directory must include a package.json in the root (used to specify * the name, version and description of the business network). This method * is designed to work with business networks that refer to external models * using npm dependencies as well as business networks that statically * package their model files. * &lt;p&gt; * If package.json contains a dependencies property then this method will search for * model (CTO) files under the node_modules directory for each dependency that * passes the options.dependencyGlob pattern. * &lt;/p&gt; * &lt;p&gt; * If the network depends on an npm module its dependencies (transitive closure) * will also be scanned for model (CTO) files. * &lt;/p&gt; * &lt;p&gt; * The directory may optionally contain a README.md file which is accessible from the * BusinessNetworkMetadata.getREADME method. * &lt;/p&gt; * &lt;p&gt; * In addition all model files will be added that are not under node_modules * and that pass the options.modelFileGlob pattern. By default you should put * model files under a directory called 'models'. * &lt;/p&gt; * &lt;p&gt; * All script (js) files will be added that are not under node_modules and * that pass the options.scriptGlob pattern. By default you should put Javascript * files under the 'lib' directory. * &lt;/p&gt; * * @param {String} path to a local directory * @param {Object} [options] - an optional set of options to configure the instance. * @param {Object} [options.dependencyGlob] - specify the glob pattern used to match * the npm dependencies to process. Defaults to ** * @param {boolean} [options.modelFileGlob] - specify the glob pattern used to match * the model files to include. Defaults to **\\/models/**\\/*.cto * @param {boolean} [options.scriptGlob] - specify the glob pattern used to match * the script files to include. Defaults to **\\/lib/**\\/*.js * @return {Promise} a Promise to the instantiated business network */ static fromDirectory(path, options) { if(!options) { options = {}; } if(!options.dependencyGlob) { options.dependencyGlob = '**'; } if(!options.modelFileGlob) { options.modelFileGlob = '**/models/**/*.cto'; } if(!options.scriptGlob) { options.scriptGlob = '**/lib/**/*.js'; } const method = 'fromDirectory'; LOG.entry(method, path); // grab the README.md let readmeContents = null; const readmePath = fsPath.resolve(path, 'README.md'); if(fs.existsSync(readmePath)) { readmeContents = fs.readFileSync(readmePath, ENCODING); if(readmeContents) { LOG.debug(method, 'Loaded README.md', readmeContents); } } // grab the package.json let packageJsonContents = fs.readFileSync( fsPath.resolve(path, 'package.json'), ENCODING); if(!packageJsonContents) { throw new Error('Failed to find package.json'); } LOG.debug(method, 'Loaded package.json', packageJsonContents); // parse the package.json let jsonObject = JSON.parse(packageJsonContents); let packageName = jsonObject.name; // create the business network definition const businessNetwork = new BusinessNetworkDefinition(null, null, jsonObject, readmeContents); const modelFiles = []; const modelFileNames = []; // define a help function that will filter out files // that are inside a node_modules directory under the path // we are processing const isFileInNodeModuleDir = function(file, basePath) { const method = 'isFileInNodeModuleDir'; let filePath = fsPath.parse(file); let subPath = filePath.dir.substring(basePath.length); let result = subPath.split(fsPath.sep).some((element) =&gt; { return element === 'node_modules'; }); LOG.debug(method, file, result); return result; }; // process each module dependency // filtering using a glob on the module dependency name if(jsonObject.dependencies) { LOG.debug(method, 'All dependencies', Object.keys(jsonObject.dependencies).toString()); const dependencies = Object.keys(jsonObject.dependencies).filter(minimatch.filter(options.dependencyGlob, { dot: true })); LOG.debug(method, 'Matched dependencies', dependencies); for( let dep of dependencies) { // find all the *.cto files under the npm install dependency path let dependencyPath = fsPath.resolve(path, 'node_modules', dep); LOG.debug(method, 'Checking dependency path', dependencyPath); if (!fs.existsSync(dependencyPath)) { // need to check to see if this is in a peer directory as well // LOG.debug(method,'trying different path '+path.replace(packageName,'')); dependencyPath = fsPath.resolve(path.replace(packageName,''),dep); if(!fs.existsSync(dependencyPath)){ throw new Error('npm dependency path ' + dependencyPath + ' does not exist. Did you run npm install?'); } } BusinessNetworkDefinition.processDirectory(dependencyPath, { accepts: function(file) { return isFileInNodeModuleDir(file, dependencyPath) === false &amp;&amp; minimatch(file, options.modelFileGlob, { dot: true }); }, acceptsDir: function(dir) { return !isFileInNodeModuleDir(dir, dependencyPath); }, process: function(path,contents) { modelFiles.push(contents); modelFileNames.push(path); LOG.debug(method, 'Found model file', path); } }); } } // find CTO files outside the npm install directory // BusinessNetworkDefinition.processDirectory(path, { accepts: function(file) { return isFileInNodeModuleDir(file, path) === false &amp;&amp; minimatch(file, options.modelFileGlob, { dot: true }); }, acceptsDir: function(dir) { return !isFileInNodeModuleDir(dir, path); }, process: function(path,contents) { modelFiles.push(contents); modelFileNames.push(path); LOG.debug(method, 'Found model file', path); } }); businessNetwork.getModelManager().addModelFiles(modelFiles,modelFileNames); LOG.debug(method, 'Added model files', modelFiles.length); // find script files outside the npm install directory const scriptFiles = []; BusinessNetworkDefinition.processDirectory(path, { accepts: function(file) { return isFileInNodeModuleDir(file, path) === false &amp;&amp; minimatch(file, options.scriptGlob, { dot: true }); }, acceptsDir: function(dir) { return !isFileInNodeModuleDir(dir, path); }, process: function(path,contents) { let filePath = fsPath.parse(path); const jsScript = businessNetwork.getScriptManager().createScript(path, filePath.ext.toLowerCase(), contents); scriptFiles.push(jsScript); LOG.debug(method, 'Found script file ', path); } }); if(modelFiles.length === 0) { throw new Error('Failed to find a model file.'); } for( let script of scriptFiles) { businessNetwork.getScriptManager().addScript(script); } LOG.debug(method, 'Added script files', scriptFiles.length); // grab the permissions.acl const aclPath = fsPath.resolve(path, 'permissions.acl'); if(fs.existsSync(aclPath)) { let permissionsAclContents = fs.readFileSync( aclPath, ENCODING); if(permissionsAclContents) { LOG.debug(method, 'Loaded permissions.acl', permissionsAclContents); const aclFile = new AclFile('permissions.acl', businessNetwork.getModelManager(), permissionsAclContents); businessNetwork.getAclManager().setAclFile(aclFile); } } // grab the query.qry const queryPath = fsPath.resolve(path, 'queries.qry'); if(fs.existsSync(queryPath)) { let queryContents = fs.readFileSync( queryPath, ENCODING); if(queryContents) { LOG.debug(method, 'Loaded queries.qry', queryContents); const queryFile = new QueryFile('queries.qry', businessNetwork.getModelManager(), queryContents); businessNetwork.getQueryManager().setQueryFile(queryFile); } } LOG.exit(method, path); return Promise.resolve(businessNetwork); } /** * @param {String} path - the path to process * @param {Object} fileProcessor - the file processor. It must have * accept and process methods. * @private */ static processDirectory(path, fileProcessor) { const items = BusinessNetworkDefinition.walkSync(path, [], fileProcessor); items.sort(); LOG.debug('processDirectory', 'Path ' + path, items); items.forEach((item) =&gt; { BusinessNetworkDefinition.processFile(item, fileProcessor); }); } /** * @param {String} file - the file to process * @param {Object} fileProcessor - the file processor. It must have * accepts and process methods. * @private */ static processFile(file, fileProcessor) { if (fileProcessor.accepts(file)) { LOG.debug('processFile', 'FileProcessor accepted', file ); let fileContents = fs.readFileSync(file, ENCODING); fileProcessor.process(file, fileContents); } else { LOG.debug('processFile', 'FileProcessor rejected', file ); } } /** * @param {String} dir - the dir to walk * @param {Object[]} filelist - input files * @param {Object} fileProcessor - the file processor. It must have * accepts and process methods. * @return {Object[]} filelist - output files * @private */ static walkSync(dir, filelist, fileProcessor) { let files = fs.readdirSync(dir); files.forEach(function (file) { let nestedPath = fsPath.join(dir, file); if (fs.lstatSync(nestedPath).isDirectory()) { if (fileProcessor.acceptsDir(nestedPath)) { filelist = BusinessNetworkDefinition.walkSync(nestedPath, filelist, fileProcessor); } } else { filelist.push(nestedPath); } }); return filelist; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor, parameters) { return visitor.visit(this, parameters); } /** * Provides access to the Introspector for this business network. The Introspector * is used to reflect on the types defined within this business network. * @return {Introspector} the Introspector for this business network */ getIntrospector() { return this.introspector; } /** * Provides access to the Factory for this business network. The Factory * is used to create the types defined in this business network. * @return {Factory} the Factory for this business network */ getFactory() { return this.factory; } /** * Provides access to the Serializer for this business network. The Serializer * is used to serialize instances of the types defined within this business network. * @return {Serializer} the Serializer for this business network */ getSerializer() { return this.serializer; } /** * Provides access to the ScriptManager for this business network. The ScriptManager * manage access to the scripts that have been defined within this business network. * @return {ScriptManager} the ScriptManager for this business network * @private */ getScriptManager() { return this.scriptManager; } /** * Provides access to the AclManager for this business network. The AclManager * manage access to the access conrol rules that have been defined for this business network. * @return {AclManager} the AclManager for this business network * @private */ getAclManager() { return this.aclManager; } /** * Provides access to the ModelManager for this business network. The ModelManager * manage access to the models that have been defined within this business network. * @return {ModelManager} the ModelManager for this business network * @private */ getModelManager() { return this.modelManager; } /** * Provides access to the QueryManager for this business network. The QueryManager * manage access to the models that have been defined within this business network. * @return {QueryManager} the QueryManager for this business network * @private */ getQueryManager() { return this.queryManager; } } module.exports = BusinessNetworkDefinition; × Search results Close "},"composer-common_lib_businessnetworkmetadata.js.html":{"id":"composer-common_lib_businessnetworkmetadata.js.html","title":"Source: composer-common/lib/businessnetworkmetadata.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/businessnetworkmetadata.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('./log/logger'); const LOG = Logger.getLog('BusinessNetworkMetadata'); /** * &lt;p&gt; * Defines the metadata for a BusinessNeworkDefinition. This includes: * &lt;ul&gt; * &lt;li&gt;package.json&lt;/li&gt; * &lt;li&gt;README.md (optional)&lt;/li&gt; * &lt;/ul&gt; * &lt;/p&gt; * @class * @memberof module:composer-common */ class BusinessNetworkMetadata { /** * Create the BusinessNetworkMetadata. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {object} packageJson - the JS object for package.json (required) * @param {String} readme - the README.md for the business network (may be null) */ constructor(packageJson, readme) { const method = 'constructor'; LOG.entry(method, readme); if(!packageJson || typeof(packageJson) !== 'object') { throw new Error('package.json is required and must be an object'); } if (!packageJson.name || !this._validName(packageJson.name)) { throw new Error ('business network name can only contain lowercase alphanumerics, _ or -'); } this.packageJson = packageJson; if(readme &amp;&amp; typeof(readme) !== 'string') { throw new Error('README must be a string'); } this.readme = readme; LOG.exit(method); } /** * check to see if it is a valid name. for some reason regex is not working when this executes * inside the chaincode runtime, which is why regex hasn't been used. * * @param {string} name the business network name to check * @returns {boolean} true if valid, false otherwise * * @memberOf BusinessNetworkMetadata * @private */ _validName(name) { const validChars = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z', '0','1','2','3','4','5','6','7','8','9','-','_']; for (let i = 0; i&lt;name.length; i++){ const strChar = name.charAt(i); if ( validChars.indexOf(strChar) === -1 ) { return false; } } return true; } /** * Returns the README.md for this business network. This may be null if the business network does not have a README.md * @return {String} the README.md file for the business network or null */ getREADME() { return this.readme; } /** * Returns the package.json for this business network. * @return {object} the Javascript object for package.json */ getPackageJson() { return this.packageJson; } /** * Returns the name for this business network. * @return {string} the name of the business network */ getName() { return this.packageJson.name; } /** * Returns the description for this business network. * @return {string} the description of the business network */ getDescription() { return this.packageJson.description; } /** * Returns the version for this business network. * @return {string} the description of the business network */ getVersion() { return this.packageJson.version; } /** * Returns the identifier for this business network, formed from name@version. * @return {string} the identifier of the business network */ getIdentifier() { return this.packageJson.name + '@' + this.packageJson.version; } } module.exports = BusinessNetworkMetadata; × Search results Close "},"composer-common_lib_introspect_classdeclaration.js.html":{"id":"composer-common_lib_introspect_classdeclaration.js.html","title":"Source: composer-common/lib/introspect/classdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/classdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Field = require('./field'); const EnumValueDeclaration = require('./enumvaluedeclaration'); const RelationshipDeclaration = require('./relationshipdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const Globalize = require('../globalize'); const Introspector = require('./introspector'); const ModelUtil = require('../modelutil'); /** * ClassDeclaration defines the structure (model/schema) of composite data. * It is composed of a set of Properties, may have an identifying field, and may * have a super-type. * A ClassDeclaration is conceptually owned with a ModelFile which * defines all the classes that are part of a namespace. * * @private * @abstract * @class * @memberof module:composer-common */ class ClassDeclaration { /** * Create a ClassDeclaration from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {ModelFile} modelFile - the ModelFile for this class * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { if(!modelFile || !ast) { throw new IllegalModelException(Globalize.formatMessage('classdeclaration-constructor-modelastreq')); } this.ast = ast; this.modelFile = modelFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelFile that defines this class. * * @return {ModelFile} the owning ModelFile */ getModelFile() { return this.modelFile; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.name = this.ast.id.name; this.properties = []; this.superType = null; this.idField = null; this.abstract = false; if(this.ast.abstract) { this.abstract = true; } if(this.ast.classExtension) { this.superType = this.ast.classExtension.class.name; } else { // if we are not a system type, then we should set the // super type to the system type for this class declaration if(!this.isSystemType()) { this.superType = this.getSystemType(); } } if(this.ast.idField) { this.idField = this.ast.idField.name; } for(let n=0; n &lt; this.ast.body.declarations.length; n++ ) { let thing = this.ast.body.declarations[n]; if(thing.type === 'FieldDeclaration') { this.properties.push( new Field(this, thing) ); } else if(thing.type === 'RelationshipDeclaration') { this.properties.push( new RelationshipDeclaration(this, thing) ); } else if(thing.type === 'EnumPropertyDeclaration') { this.properties.push( new EnumValueDeclaration(this, thing) ); } else { let formatter = Globalize.messageFormatter('classdeclaration-process-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type }), this.modelFile, this.ast.location); } } } /** * Semantic validation of the structure of this class. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { const declarations = this.getModelFile().getAllDeclarations(); for(let n=0; n &lt; declarations.length; n++) { let declaration = declarations[n]; // check we don't have an asset with the same name for(let i=n+1; i &lt; declarations.length; i++) { let otherDeclaration = declarations[i]; if(declaration.getFullyQualifiedName() === otherDeclaration.getFullyQualifiedName()) { throw new IllegalModelException(`Duplicate class name ${declaration.getName()}`); } } } // TODO (LG) check that all imported classes exist, rather than just // used imports // if we have a super type make sure it exists if(this.superType!==null) { let classDecl = null; if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType, this.modelFile, this.ast.location); } // TODO (DCS) // else { // // check that assets only inherit from assets etc. // if( Object.getPrototypeOf(classDecl) !== Object.getPrototypeOf(this)) { // throw new Error('Invalid super type for ' + this.name + ' is must be of type ' + Object.getPrototypeOf(this) ); // } // } } if(this.idField) { const field = this.getProperty(this.idField); if(!field) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotproperty'); throw new IllegalModelException(formatter({ 'class': this.name, 'idField': this.idField }), this.modelFile, this.ast.location); } else { // check that identifiers are strings if(field.getType() !== 'String') { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-identifiernotstring'); throw new IllegalModelException( formatter({ 'class': this.name, 'idField': this.idField }),this.modelFile, this.ast.location); } if(field.isOptional()) { throw new IllegalModelException('Identifying fields cannot be optional.',this.modelFile, this.ast.location); } } } else { if( this.isAbstract() === false &amp;&amp; this.isEnum() === false &amp;&amp; this.isConcept() === false) { if( this.getIdentifierFieldName() === null) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-missingidentifier'); throw new IllegalModelException( formatter({ 'class': this.name }),this.modelFile, this.ast.location); } } } // we also have to check fields defined in super classes const properties = this.getProperties(); for(let n=0; n &lt; properties.length; n++) { let field = properties[n]; // check we don't have a field with the same name for(let i=n+1; i &lt; properties.length; i++) { let otherField = properties[i]; if(field.getName() === otherField.getName()) { let formatter = Globalize('en').messageFormatter('classdeclaration-validate-duplicatefieldname'); throw new IllegalModelException( formatter({ 'class': this.name, 'fieldName': field.getName() }),this.modelFile, this.ast.location); } } // we now validate the field, however to ensure that // imports are resolved correctly we validate in the context // of the declared type of the field for non-primitives in a different namespace if(field.isPrimitive() || this.isEnum() || field.getNamespace() === this.getModelFile().getNamespace() ) { field.validate(this); } else { const typeFqn = field.getFullyQualifiedTypeName(); const classDecl = this.modelFile.getModelManager().getType(typeFqn); field.validate(classDecl); } } } /** * Returns the base system type for this type of class declaration. Override * this method in derived classes to specify a base system type. * * @return {string} the short name of the base system type or null */ getSystemType() { return null; } /** * Returns true if this class is declared as abstract in the model file * * @return {boolean} true if the class is abstract */ isAbstract() { return this.abstract; } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return false; } /** * Returns true if this class is the definition of a concept. * * @return {boolean} true if the class is a concept */ isConcept() { return false; } /** * Returns true if this class is the definition of an event. * * @return {boolean} true if the class is an event */ isEvent() { return false; } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return false; } /** * Returns true if this class can be pointed to by a relationship in a * system model * * @return {boolean} true if the class may be pointed to by a relationship */ isSystemType() { return ModelUtil.getSystemNamespace() === this.modelFile.getNamespace(); } /** * Returns the short name of a class. This name does not include the * namespace from the owning ModelFile. * * @return {string} the short name of this class */ getName() { return this.name; } /** * Returns the fully qualified name of this class. * The name will include the namespace if present. * * @return {string} the fully-qualified name of this class */ getFullyQualifiedName() { return this.modelFile.getNamespace() + '.' + this.name; } /** * Returns the name of the identifying field for this class. Note * that the identifying field may come from a super type. * * @return {string} the name of the id field for this class */ getIdentifierFieldName() { if(this.idField) { return this.idField; } else { if(this.getSuperType()) { // we first check our own modelfile, as we may be called from validate // in which case our model file has not yet been added to the model modelManager let classDecl = this.getModelFile().getLocalType(this.getSuperType()); // not a local type, so we try the model manager if(!classDecl) { classDecl = this.modelFile.getModelManager().getType(this.getSuperType()); } return classDecl.getIdentifierFieldName(); } else { return null; } } } /** * Returns the field with a given name or null if it does not exist. * The field must be directly owned by this class -- the super-type is * not introspected. * * @param {string} name the name of the field * @return {Property} the field definition or null if it does not exist. */ getOwnProperty(name) { for(let n=0; n &lt; this.properties.length; n++) { const field = this.properties[n]; if(field.getName() === name) { return field; } } return null; } /** * Returns the fields directly defined by this class. * * @return {Property[]} the array of fields */ getOwnProperties() { return this.properties; } /** * Returns the FQN of the super type for this class or null if this * class does not have a super type. * * @return {string} the FQN name of the super type or null */ getSuperType() { const superTypeDeclaration = this.getSuperTypeDeclaration(); if (superTypeDeclaration) { return superTypeDeclaration.getFullyQualifiedName(); } else { return null; } } /** * Get the super type class declaration for this class. * @return {ClassDeclaration} the super type declaration, or null if there is no super type. */ getSuperTypeDeclaration() { if (!this.superType) { return null; } const supertypeDeclaration = this.getModelFile().getType(this.superType); if (!supertypeDeclaration) { throw new Error('Could not find super type: ' + this.superType); } return supertypeDeclaration; } /** * Get the class declarations for all subclasses of this class, including this class. * @return {ClassDeclaration[]} subclass declarations. */ getAssignableClassDeclarations() { const results = new Set(); const modelManager = this.getModelFile().getModelManager(); const introspector = new Introspector(modelManager); const allClassDeclarations = introspector.getClassDeclarations(); const subclassMap = new Map(); // Build map of all direct subclasses relationships allClassDeclarations.forEach((declaration) =&gt; { const superType = declaration.getSuperType(); if (superType) { const subclasses = subclassMap.get(superType) || new Set(); subclasses.add(declaration); subclassMap.set(superType, subclasses); } }); // Recursive function to collect all direct and indirect subclasses of a given (set) of base classes. const collectSubclasses = (superclasses) =&gt; { superclasses.forEach((declaration) =&gt; { results.add(declaration); const superType = declaration.getFullyQualifiedName(); const subclasses = subclassMap.get(superType); if (subclasses) { collectSubclasses(subclasses); } }); }; collectSubclasses([this]); return Array.from(results); } /** * Get all the super-type declarations for this type. * @return {ClassDeclaration[]} super-type declarations. */ getAllSuperTypeDeclarations() { const results = []; for (let type = this; (type = type.getSuperTypeDeclaration()); ) { results.push(type); } return results; } /** * Returns the property with a given name or null if it does not exist. * Fields defined in super-types are also introspected. * * @param {string} name the name of the field * @return {Property} the field, or null if it does not exist */ getProperty(name) { let result = this.getOwnProperty(name); let classDecl = null; if(result === null &amp;&amp; this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } result = classDecl.getProperty(name); } return result; } /** * Returns the properties defined in this class and all super classes. * * @return {Property[]} the array of fields */ getProperties() { let result = this.getOwnProperties(); let classDecl = null; if(this.superType!==null) { if(this.getModelFile().isImportedType(this.superType)) { let fqnSuper = this.getModelFile().resolveImport(this.superType); classDecl = this.modelFile.getModelManager().getType(fqnSuper); } else { classDecl = this.getModelFile().getType(this.superType); } if(classDecl===null) { throw new IllegalModelException('Could not find super type ' + this.superType,this.modelFile, this.ast.location); } // go get the fields from the super type result = result.concat(classDecl.getProperties()); } else { // console.log('No super type for ' + this.getName() ); } return result; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { let superType = ''; if(this.superType) { superType = ' super=' + this.superType; } return 'ClassDeclaration {id=' + this.getFullyQualifiedName() + superType + ' enum=' + this.isEnum() + ' abstract=' + this.isAbstract() + '}'; } } module.exports = ClassDeclaration; × Search results Close "},"composer-common_lib_comboconnectionprofilestore.js.html":{"id":"composer-common_lib_comboconnectionprofilestore.js.html","title":"Source: composer-common/lib/comboconnectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/comboconnectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileStore = require('./connectionprofilestore'); const Logger = require('./log/logger'); const LOG = Logger.getLog('EnvConnectionProfileStore'); /** * Manages persistence of connection profiles across multiple * connection profile stores. * * @private * @abstract * @class * @memberof module:composer-common */ class ComboConnectionProfileStore extends ConnectionProfileStore { /** * Constructor. */ constructor() { super(); const method = 'constructor'; const args = Array.prototype.slice.call(arguments); LOG.entry(method, arguments); this.connectionProfileStores = args.map((arg) =&gt; { if (arg instanceof ConnectionProfileStore) { return arg; } throw new Error('Specified argument is not a connection profile store instance'); }); LOG.exit(method); } /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { const method = 'load'; LOG.entry(method, connectionProfile); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then((connectionProfileData) =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); if (connectionProfileData) { LOG.debug(method, 'Connection profile already loaded, skipping'); return connectionProfileData; } LOG.debug(method, 'Connection profile not loaded, loading'); return connectionProfileStore.load(connectionProfile) .catch((error) =&gt;{ LOG.debug(method, 'Caught error, ignoring', error); return null; }); }); }, Promise.resolve(null)) .then((connectionProfileData) =&gt; { if (!connectionProfileData) { throw new Error(`The connection profile ${connectionProfile} does not exist`); } LOG.exit(method, connectionProfileData); return connectionProfileData; }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { const method = 'save'; LOG.entry(method, connectionProfile, connectOptions); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then((saved) =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); if (saved) { LOG.debug(method, 'Connection profile already saved, skipping'); return true; } LOG.debug(method, 'Connection profile not saved, saving'); return connectionProfileStore.save(connectionProfile, connectOptions) .then(() =&gt; { LOG.debug(method, 'Saved'); return true; }) .catch((error) =&gt;{ LOG.debug(method, 'Caught error, ignoring', error); return false; }); }); }, Promise.resolve(false)) .then((saved) =&gt; { if (!saved) { throw new Error(`The connection profile ${connectionProfile} could not be saved`); } LOG.exit(method); }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { const method = 'loadAll'; LOG.entry(method); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then((connectionProfiles) =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); return connectionProfileStore.loadAll() .then((thisConnectionProfiles) =&gt; { return Object.assign(thisConnectionProfiles, connectionProfiles); }); }); }, Promise.resolve({})) .then((connectionProfiles) =&gt; { LOG.exit(method, connectionProfiles); return connectionProfiles; }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { const method = 'delete'; LOG.entry(method, connectionProfile); return this.connectionProfileStores .reduce((result, connectionProfileStore) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Looking at connection profile store', connectionProfileStore); // We don't skip if already deleted as we likely want to delete it from everywhere. LOG.debug(method, 'Deleting connection profile'); return connectionProfileStore.delete(connectionProfile) .then(() =&gt; { LOG.debug(method, 'Deleted'); }) .catch((error) =&gt;{ LOG.debug(method, 'Caught error, ignoring', error); }); }); }, Promise.resolve()) .then(() =&gt; { LOG.exit(method); }); } } module.exports = ComboConnectionProfileStore; × Search results Close "},"composer-common_lib_model_concept.js.html":{"id":"composer-common_lib_model_concept.js.html","title":"Source: composer-common/lib/model/concept.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/concept.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Typed = require('./typed'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class Concept extends Typed { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @private */ constructor(modelManager, ns, type) { super(modelManager, ns, type); } /** * Determine if this typed is a concept. * @return {boolean} True if this typed is a concept, * false if not. */ isConcept() { return true; } } module.exports = Concept; × Search results Close "},"composer-common_lib_introspect_conceptdeclaration.js.html":{"id":"composer-common_lib_introspect_conceptdeclaration.js.html","title":"Source: composer-common/lib/introspect/conceptdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/conceptdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * ConceptDeclaration defines the schema (aka model or class) for * an Concept. It extends ClassDeclaration which manages a set of * fields, a super-type and the specification of an * identifying field. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class ConceptDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class is the definition of a concept. * * @return {boolean} true if the class is a concept */ isConcept() { return true; } } module.exports = ConceptDeclaration; × Search results Close "},"composer-common_lib_connection.js.html":{"id":"composer-common_lib_connection.js.html","title":"Source: composer-common/lib/connection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionManager = require('./connectionmanager'); const EventEmitter = require('events'); /** * Base class representing a connection to a business network. * @private * @abstract * @class * @memberof module:composer-common */ class Connection extends EventEmitter { /** * Constructor. * @param {ConnectionManager} connectionManager The owning connection manager. * @param {string} connectionProfile The name of the connection profile associated with this connection * @param {string} businessNetworkIdentifier The identifier of the business network for this connection, or null if an admin connection */ constructor(connectionManager, connectionProfile, businessNetworkIdentifier) { super(); if (!(connectionManager instanceof ConnectionManager)) { throw new Error('connectionManager not specified'); } else if (!connectionProfile) { throw new Error('connectionProfile not specified'); } this.connectionManager = connectionManager; this.connectionProfile = connectionProfile; this.businessNetworkIdentifier = businessNetworkIdentifier; } /** * Get the connection manager that owns this connection. * @return {ConnectionManager} The owning connection manager. */ getConnectionManager() { return this.connectionManager; } /** * Returns a string that can be used to identify this connection. * @return {string} the identifier of this connection */ getIdentifier() { if(this.businessNetworkIdentifier) { return this.businessNetworkIdentifier + '@' + this.connectionProfile; } else { return this.connectionProfile; } } /** * Terminate the connection to the business network. * @abstract * @return {Promise} A promise that is resolved once the connection has been * terminated, or rejected with an error. */ disconnect() { return Promise.reject(new Error('abstract function called')); } /** * Login as a participant on the business network. * @abstract * @param {string} enrollmentID The enrollment ID of the participant. * @param {string} enrollmentSecret The enrollment secret of the participant. * @return {Promise} A promise that is resolved with a {@link SecurityContext} * object representing the logged in participant, or rejected with a login error. */ login(enrollmentID, enrollmentSecret) { return Promise.reject(new Error('abstract function called')); } /** * Deploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {boolean} [force] Force the deployment of the business network artifacts. * @param {BusinessNetworkDefinition} businessNetworkDefinition The BusinessNetworkDefinition to deploy * @return {Promise} A promise that is resolved once the business network * artifacts have been deployed, or rejected with an error. */ deploy(securityContext, force, businessNetworkDefinition) { return Promise.reject(new Error('abstract function called')); } /** * Updates an existing deployed business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {BusinessNetworkDefinition} businessNetworkDefinition The BusinessNetworkDefinition to deploy * @return {Promise} A promise that is resolved once the business network * artifacts have been updated, or rejected with an error. */ update(securityContext, businessNetworkDefinition) { return Promise.reject(new Error('abstract function called')); } /** * Undeploy a business network definition. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} businessNetworkIdentifier The identifier of the business network to remove * @return {Promise} A promise that is resolved once the business network * artifacts have been undeployed, or rejected with an error. */ undeploy(securityContext, businessNetworkIdentifier) { return Promise.reject(new Error('abstract function called')); } /** * Test (&quot;ping&quot;) the connection to the business network. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that is resolved once the connection to the * business network has been tested, or rejected with an error. */ ping(securityContext) { return Promise.reject(new Error('abstract function called')); } /** * Invoke a &quot;query&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that is resolved with the data returned by the * chaincode function once it has been invoked, or rejected with an error. */ queryChainCode(securityContext, functionName, args) { return Promise.reject(new Error('abstract function called')); } /** * Invoke a &quot;invoke&quot; chaincode function with the specified name and arguments. * @abstract * @param {SecurityContext} securityContext The participant's security context. * @param {string} functionName The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that is resolved once the chaincode function * has been invoked, or rejected with an error. */ invokeChainCode(securityContext, functionName, args) { return Promise.reject(new Error('abstract function called')); } /** * Create a new identity for the specified user ID. * @param {SecurityContext} securityContext The participant's security context. * @param {string} userID The user ID. * @param {object} [options] Options for the new identity. * @param {boolean} [options.issuer] Whether or not the new identity should have * permissions to create additional new identities. False by default. * @param {string} [options.affiliation] Specify the affiliation for the new * identity. Defaults to 'institution_a'. * @return {Promise} A promise that is resolved with a generated user * secret once the new identity has been created, or rejected with an error. */ createIdentity(securityContext, userID, options) { return Promise.reject(new Error('abstract function called')); } /** * List all of the deployed business networks. The connection must * be connected for this method to succeed. * @param {SecurityContext} securityContext The participant's security context. * @return {Promise} A promise that will be resolved with an array of * business network identifiers, or rejected with an error. */ list(securityContext) { return Promise.reject(new Error('abstract function called')); } } module.exports = Connection; × Search results Close "},"composer-common_lib_connectionprofilemanager.js.html":{"id":"composer-common_lib_connectionprofilemanager.js.html","title":"Source: composer-common/lib/connectionprofilemanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connectionprofilemanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('./log/logger'); const LOG = Logger.getLog('ConnectionProfileManager'); const connectionManagerLoaders = []; const connectionManagerClasses = {}; const connectionManagers = {}; /** * A connection profile manager that manages a set of connection profiles. Each * connection profile defines an arbitrary set of configuration data and is associated * with a ConnectionManager. * @private * @class * @memberof module:composer-common */ class ConnectionProfileManager { /** * The composer-common module cannot load connector modules from parent modules * when the dependencies are linked together using npm link or lerna. To work * around this, the packages that require the connectors register themselves as * modules that can load connection managers. * @param {Object} module The module that can load connector modules. */ static registerConnectionManagerLoader(module) { connectionManagerLoaders.push(module); } /** * Register a new ConnectionManager class. * @param {string} type - the profile type identifier of the ConnectionManager * @param {function} ctor - the constructor of the ConnectionManager */ static registerConnectionManager(type, ctor) { connectionManagerClasses[type] = ctor; } /** * Create the ConnectionManager and attach a file system * @param {ConnectionProfileStore} connectionProfileStore - Node.js FS implementation, for example BrowserFS */ constructor(connectionProfileStore) { LOG.info('constructor','Created a new ConnectionProfileManager', connectionProfileStore); if(!connectionProfileStore) { throw new Error('Must create ConnectionProfileManager with a ConnectionProfileStore implementation.'); } this.connectionProfileStore = connectionProfileStore; } /** * Returns the ConnectionProfileStore associated with this * instance. * @return {ConnectionProfileStore} the associated store. */ getConnectionProfileStore() { return this.connectionProfileStore; } /** * Adds a ConnectionManager to the mappings of this ConnectionProfileManager * @param {string} type - the profile type identifier of the ConnectionManager * @param {ConnectionManager} connectionManager - the instance */ addConnectionManager(type, connectionManager) { LOG.info('addConnectionManager','Adding a new connection manager', type); connectionManagers[type] = connectionManager; } /** * Retrieves the ConnectionManager for the given connection profile. * * @param {string} connectionProfile The name of the connection profile * @return {Promise} A promise that is resolved with a {@link ConnectionManager} * object once the connection is established, or rejected with a connection error. */ getConnectionManager(connectionProfile) { const METHOD = 'getConnectionManager'; LOG.info(METHOD,'Looking up a connection manager for profile', connectionProfile); return this.connectionProfileStore.load(connectionProfile) .then((data) =&gt; { LOG.debug(METHOD,data); let connectionManager = connectionManagers[data.type]; if(!connectionManager) { const mod = `composer-connector-${data.type}`; LOG.debug(METHOD,'Looking for module',mod); try { // Check for the connection manager class registered using // registerConnectionManager (used by the web connector). let connectionManagerClass = connectionManagerClasses[data.type]; if (connectionManagerClass) { connectionManager = new(connectionManagerClass)(this); } else { // Not registered using registerConnectionManager, we now // need to search for the connector module in our module // and all of the parent modules (the ones who require'd // us) as we do not depend on any connector modules. let curmod = module; while (curmod) { try { connectionManager = new(curmod.require(mod))(this); break; } catch (e) { LOG.error(METHOD,'No yet located the module ',e.message); // Continue to search the parent. } curmod = curmod.parent; } LOG.info(METHOD,'Using this connection manager ',connectionManager); if (!connectionManager) { connectionManagerLoaders.some((connectionManagerLoader) =&gt; { try { connectionManager = new(connectionManagerLoader.require(mod))(this); return true; } catch (e) { // Search the next one. LOG.debug(METHOD,e); return false; } }); } if (!connectionManager) { LOG.verbose(METHOD,'not located the module - final try '); // We still didn't find it, so try plain old require // one last time. connectionManager = new(require(mod))(this); } } } catch (e) { LOG.debug(METHOD,e); throw new Error(`Failed to load connector module &quot;${mod}&quot; for connection profile &quot;${connectionProfile}&quot;`); } connectionManagers[data.type] = connectionManager; } return connectionManager; }); } /** * Establish a connection to the business network, using connection information * from the connection profile. * * @param {string} connectionProfile The name of the connection profile * @param {string} businessNetworkIdentifier The identifier of the business network, or null if this is an admin connection * @param {Object} [additionalConnectOptions] Additional configuration options supplied * at runtime that override options set in the connection profile. * @return {Promise} A promise that is resolved with a {@link Connection} * object once the connection is established, or rejected with a connection error. * @abstract */ connect(connectionProfile, businessNetworkIdentifier, additionalConnectOptions) { LOG.info('connect','Connecting using ' + connectionProfile, businessNetworkIdentifier); let connectOptions; return this.connectionProfileStore.load(connectionProfile) .then((connectOptions_) =&gt; { connectOptions = connectOptions_; if (additionalConnectOptions) { connectOptions = Object.assign(connectOptions, additionalConnectOptions); } return this.getConnectionManager(connectionProfile); }) .then((connectionManager) =&gt; { return connectionManager.connect(connectionProfile, businessNetworkIdentifier, connectOptions); }); } /** * Clear the static object containing all the connection managers */ static removeAllConnectionManagers() { connectionManagerLoaders.length = 0; Object.keys(connectionManagerClasses).forEach((key) =&gt; { connectionManagerClasses[key] = null; }); Object.keys(connectionManagers).forEach((key) =&gt; { connectionManagers[key] = null; }); } } module.exports = ConnectionProfileManager; × Search results Close "},"composer-common_lib_connectionprofilestore.js.html":{"id":"composer-common_lib_connectionprofilestore.js.html","title":"Source: composer-common/lib/connectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/connectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Manages persistence of connection profiles. * * @private * @abstract * @class * @memberof module:composer-common */ class ConnectionProfileStore { /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { return Promise.reject(new Error('abstract function called')); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { return Promise.reject(new Error('abstract function called')); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { return Promise.reject(new Error('abstract function called')); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { return Promise.reject(new Error('abstract function called')); } } module.exports = ConnectionProfileStore; × Search results Close "},"composer-common_lib_introspect_enumdeclaration.js.html":{"id":"composer-common_lib_introspect_enumdeclaration.js.html","title":"Source: composer-common/lib/introspect/enumdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/enumdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); /** * EnumDeclaration defines an enumeration of static values. * @private * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @class * @memberof module:composer-common */ class EnumDeclaration extends ClassDeclaration { /** * Create an AssetDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class is an enumeration. * * @return {boolean} true if the class is an enumerated type */ isEnum() { return true; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'EnumDeclaration {id=' + this.getFullyQualifiedName() + '}'; } } module.exports = EnumDeclaration; × Search results Close "},"composer-common_lib_envconnectionprofilestore.js.html":{"id":"composer-common_lib_envconnectionprofilestore.js.html","title":"Source: composer-common/lib/envconnectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/envconnectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileStore = require('./connectionprofilestore'); const Logger = require('./log/logger'); const LOG = Logger.getLog('EnvConnectionProfileStore'); /** * Manages persistence of connection profiles in the environment. * * @private * @abstract * @class * @memberof module:composer-common */ class EnvConnectionProfileStore extends ConnectionProfileStore { /** * Constructor. */ constructor() { super(); const method = 'constructor'; LOG.entry(method); if (process.env.COMPOSER_CONFIG) { try { this.env = JSON.parse(process.env.COMPOSER_CONFIG); } catch (e) { LOG.error(method, 'Failed to parse the value of the COMPOSER_CONFIG environment variable', e); throw new Error('Failed to parse the value of the COMPOSER_CONFIG environment variable'); } } else { this.env = {}; } this.env.connectionProfiles = this.env.connectionProfiles || {}; LOG.debug(method, 'Loaded environment', this.env); LOG.exit(method); } /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { const method = 'load'; LOG.entry(method, connectionProfile); return Promise.resolve() .then(() =&gt; { const connectionProfileData = this.env.connectionProfiles[connectionProfile]; if (!connectionProfileData) { throw new Error(`The connection profile ${connectionProfile} does not exist in the environment`); } LOG.exit(method, connectionProfileData); return connectionProfileData; }) .catch((e) =&gt; { LOG.error(method, e); throw e; }); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { const method = 'save'; LOG.entry(method, connectionProfile, connectOptions); const e = new Error(`Cannot save connection profile ${connectionProfile} into the environment`); LOG.error(method, e); return Promise.reject(e); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { const method = 'loadAll'; LOG.entry(method); return Promise.resolve() .then(() =&gt; { const connectionProfiles = Object.keys(this.env.connectionProfiles).sort(); const result = {}; connectionProfiles.forEach((connectionProfile) =&gt; { const connectionProfileData = this.env.connectionProfiles[connectionProfile]; result[connectionProfile] = connectionProfileData; }); LOG.exit(method, result); return result; }); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { const method = 'delete'; LOG.entry(method, connectionProfile); const e = new Error(`Cannot delete connection profile ${connectionProfile} from the environment`); LOG.error(method, e); return Promise.reject(e); } } module.exports = EnvConnectionProfileStore; × Search results Close "},"composer-common_lib_introspect_eventdeclaration.js.html":{"id":"composer-common_lib_introspect_eventdeclaration.js.html","title":"Source: composer-common/lib/introspect/eventdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/eventdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); /** Class representing the definition of an Event. * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @private * @class * @memberof module:composer-common */ class EventDeclaration extends ClassDeclaration { /** * Create an EventDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {InvalidModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns the base system type for Events from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Event'; } /** * Semantic validation of the structure of this event. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Event') { throw new IllegalModelException('Event is a reserved type name.', this.modelFile, this.ast.location); } } /** * Returns true if this class is the definition of an event * * @return {boolean} true if the class is an event */ isEvent() { return true; } } module.exports = EventDeclaration; × Search results Close "},"composer-common_lib_factory.js.html":{"id":"composer-common_lib_factory.js.html","title":"Source: composer-common/lib/factory.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/factory.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const debug = require('debug')('ibm-concerto'); const Globalize = require('./globalize'); const ModelUtil = require('./modelutil'); const InstanceGenerator = require('./serializer/instancegenerator'); const ValueGeneratorFactory = require('./serializer/valuegenerator'); const ResourceValidator = require('./serializer/resourcevalidator'); const TypedStack = require('./serializer/typedstack'); const Relationship = require('./model/relationship'); const Resource = require('./model/resource'); const ValidatedResource = require('./model/validatedresource'); const Concept = require('./model/concept'); const ValidatedConcept = require('./model/validatedconcept'); const TransactionDeclaration = require('./introspect/transactiondeclaration'); const EventDeclaration = require('./introspect/eventdeclaration'); const uuid = require('uuid'); /** * Use the Factory to create instances of Resource: transactions, participants * and assets. * &lt;p&gt;&lt;a href=&quot;./diagrams/factory.svg&quot;&gt;&lt;img src=&quot;./diagrams/factory.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @class * @memberof module:composer-common */ class Factory { /** * Create the factory. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Hyperledger-Composer}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this registry */ constructor(modelManager) { this.modelManager = modelManager; } /** * Create a new Resource with a given namespace, type name and id * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @param {Object} [options] - an optional set of options * @param {boolean} [options.disableValidation] - pass true if you want the factory to * return a {@link Resource} instead of a {@link ValidatedResource}. Defaults to false. * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @return {Resource} the new instance * @throws {TypeNotFoundException} if the type is not registered with the ModelManager */ newResource(ns, type, id, options) { if(!id || typeof(id) !== 'string') { let formatter = Globalize.messageFormatter('factory-newinstance-invalididentifier'); throw new Error(formatter({ namespace: ns, type: type })); } if(id.trim().length === 0) { let formatter = Globalize.messageFormatter('factory-newinstance-missingidentifier'); throw new Error(formatter({ namespace: ns, type: type })); } const qualifiedName = ModelUtil.getFullyQualifiedName(ns, type); const classDecl = this.modelManager.getType(qualifiedName); if(classDecl.isAbstract()) { let formatter = Globalize.messageFormatter('factory-newinstance-abstracttype'); throw new Error(formatter({ namespace: ns, type: type })); } if(classDecl.isConcept()) { throw new Error('Use newConcept to create concepts ' + classDecl.getFullyQualifiedName()); } let newObj = null; options = options || {}; if(options.disableValidation) { newObj = new Resource(this.modelManager, ns, type, id); } else { newObj = new ValidatedResource(this.modelManager, ns, type, id, new ResourceValidator()); } newObj.assignFieldDefaults(); if(options.generate) { let generator; let includeOptionalFields; if ((/^empty$/i).test(options.generate)) { generator = ValueGeneratorFactory.empty(); includeOptionalFields = false; } else { generator = ValueGeneratorFactory.sample(); includeOptionalFields = true; } const visitor = new InstanceGenerator(); const parameters = { stack: new TypedStack(newObj), modelManager: this.modelManager, factory: this, valueGenerator: generator, includeOptionalFields: includeOptionalFields }; classDecl.accept(visitor, parameters); } // if we have an identifier, we set it now let idField = classDecl.getIdentifierFieldName(); newObj[idField] = id; debug('Factory.newResource created %s', id ); return newObj; } /** * Create a new Resource with a given namespace, type name and id * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {Object} [options] - an optional set of options * @param {boolean} [options.disableValidation] - pass true if you want the factory to * return a {@link Resource} instead of a {@link ValidatedResource}. Defaults to false. * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @return {Resource} the new instance * @throws {TypeNotFoundException} if the type is not registered with the ModelManager */ newConcept(ns, type, options) { const qualifiedName = ModelUtil.getFullyQualifiedName(ns, type); const classDecl = this.modelManager.getType(qualifiedName); if(classDecl.isAbstract()) { let formatter = Globalize.messageFormatter('factory-newinstance-abstracttype'); throw new Error(formatter({ namespace: ns, type: type })); } if(!classDecl.isConcept()) { throw new Error('Class is not a concept ' + classDecl.getFullyQualifiedName()); } let newObj = null; options = options || {}; if(options.disableValidation) { newObj = new Concept(this.modelManager,ns,type); } else { newObj = new ValidatedConcept(this.modelManager,ns,type, new ResourceValidator()); } newObj.assignFieldDefaults(); if(options.generate) { const visitor = new InstanceGenerator(); const generator = (/^empty$/i).test(options.generate) ? ValueGeneratorFactory.empty() : ValueGeneratorFactory.sample(); const parameters = { stack: new TypedStack(newObj), modelManager: this.modelManager, factory: this, valueGenerator: generator }; classDecl.accept(visitor, parameters); } debug('Factory.newResource created concept %s', classDecl.getFullyQualifiedName() ); return newObj; } /** * Create a new Relationship with a given namespace, type and identifier. * A relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates` * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * * @param {string} ns - the namespace of the Resource * @param {string} type - the type of the Resource * @param {string} id - the identifier * @return {Relationship} - the new relationship instance * @throws {TypeNotFoundException} if the type is not registered with the ModelManager */ newRelationship(ns, type, id) { // Load the type declaration to force an error if it doesn't exist const fqn = ModelUtil.getFullyQualifiedName(ns, type); this.modelManager.getType(fqn); return new Relationship(this.modelManager, ns, type, id); } /** * Create a new transaction object. The identifier of the transaction is * set to a UUID. * @param {string} ns - the namespace of the transaction. * @param {string} type - the type of the transaction. * @param {string} [id] - an optional identifier for the transaction; if you do not specify * one then an identifier will be automatically generated. * @param {Object} [options] - an optional set of options * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @return {Resource} A resource for the new transaction. */ newTransaction(ns, type, id, options) { if (!ns) { throw new Error('ns not specified'); } else if (!type) { throw new Error('type not specified'); } id = id || uuid.v4(); let transaction = this.newResource(ns, type, id, options); const classDeclaration = transaction.getClassDeclaration(); if (!(classDeclaration instanceof TransactionDeclaration)) { throw new Error(transaction.getClassDeclaration().getFullyQualifiedName() + ' is not a transaction'); } // set the timestamp transaction.timestamp = new Date(); return transaction; } /** * Create a new event object. The identifier of the event is * set to a UUID. * @param {string} ns - the namespace of the event. * @param {string} type - the type of the event. * @param {string} [id] - an optional identifier for the event; if you do not specify * one then an identifier will be automatically generated. * @param {Object} [options] - an optional set of options * @param {string} [options.generate] - Pass one of: &lt;dl&gt; * &lt;dt&gt;sample&lt;/dt&gt;&lt;dd&gt;return a resource instance with generated sample data.&lt;/dd&gt; * &lt;dt&gt;empty&lt;/dt&gt;&lt;dd&gt;return a resource instance with empty property values.&lt;/dd&gt;&lt;/dl&gt; * @return {Resource} A resource for the new event. */ newEvent(ns, type, id, options) { if (!ns) { throw new Error('ns not specified'); } else if (!type) { throw new Error('type not specified'); } id = id || 'valid'; let event = this.newResource(ns, type, id, options); const classDeclaration = event.getClassDeclaration(); if (!(classDeclaration instanceof EventDeclaration)) { throw new Error(event.getClassDeclaration().getFullyQualifiedName() + ' is not an event'); } // set the timestamp event.timestamp = new Date(); return event; } } module.exports = Factory; × Search results Close "},"composer-common_lib_introspect_field.js.html":{"id":"composer-common_lib_introspect_field.js.html","title":"Source: composer-common/lib/introspect/field.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/field.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Property = require('./property'); const NumberValidator = require('./numbervalidator'); const StringValidator = require('./stringvalidator'); /** * Class representing the definition of a Field. A Field is owned * by a ClassDeclaration and has a name, type and additional metadata * (see below). * @private * @extends Property * @see See [Property]{@link module:composer-common.Property} * @class * @memberof module:composer-common */ class Field extends Property { /** * Create an Field. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Process the AST and build the model * @throws {IllegalModelException} * @private */ process() { super.process(); this.validator = null; switch(this.getType()) { case 'Integer': case 'Double': case 'Long': if(this.ast.range) { this.validator = new NumberValidator(this, this.ast.range); } break; case 'String': if(this.ast.regex) { this.validator = new StringValidator(this, this.ast.regex); } break; } if(this.ast.default) { this.defaultValue = this.ast.default; } else { this.defaultValue = null; } } /** * Returns the validator string for this field * @return {string} the validator for the field or null */ getValidator() { return this.validator; } /** * Returns the default value for the field or null * @return {string} the default value for the field or null */ getDefaultValue() { if(this.defaultValue) { return this.defaultValue; } else { return null; } } /** * Returns a string representation of this property§ * @return {String} the string version of the property. */ toString() { return 'Field {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; } } module.exports = Field; × Search results Close "},"composer-common_lib_codegen_filewriter.js.html":{"id":"composer-common_lib_codegen_filewriter.js.html","title":"Source: composer-common/lib/codegen/filewriter.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/filewriter.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const mkdirp = require('mkdirp'); const path = require('path'); const Writer = require('./writer'); /** * FileWriter creates text files under a directory tree. It can be used * by code generators to create source files for example. * Basic usage is: openFile(fileName), writeLine(...), closeFile(). * * @private * @extends Writer * @see See [Writer]{@link module:composer-common.Writer} * @class * @memberof module:composer-common */ class FileWriter extends Writer { /** * Create a FileWriter. * * @param {string} outputDirectory - the path to an output directory * that will be used to store generated files. */ constructor(outputDirectory) { super(); this.outputDirectory = outputDirectory; this.relativeDir = null; this.fileName = null; mkdirp.sync(outputDirectory); } /** * Opens a file for writing. The file will be created in the * root directory of this FileWriter. * * @param {string} fileName - the name of the file to open */ openFile(fileName) { this.fileName = fileName; this.relativeDir = null; } /** * Opens a file for writing, with a location relative to the * root directory of this FileWriter. * * @param {string} relativeDir - the relative directory to use * @param {string} fileName - the name of the file to open */ openRelativeFile(relativeDir, fileName) { this.relativeDir = relativeDir; this.fileName = fileName; } /** * Writes text to the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { if (this.fileName) { super.writeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Writes text to the start of the current open file * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { if (this.fileName) { super.writeBeforeLine(tabs,text); } else { throw Error('File has not been opened!'); } } /** * Closes the current open file */ closeFile() { if (!this.fileName) { throw new Error('No file open'); } let filePath = this.outputDirectory; if (this.relativeDir) { filePath = path.resolve(filePath, this.relativeDir); } filePath = path.resolve(filePath, this.fileName); //console.log('Writing to ' + filePath ); mkdirp.sync(path.dirname(filePath)); fs.writeFileSync(filePath, this.getBuffer()); this.fileName = null; this.relativeDir = null; this.clearBuffer(); } } module.exports = FileWriter; × Search results Close "},"composer-common_lib_fsconnectionprofilestore.js.html":{"id":"composer-common_lib_fsconnectionprofilestore.js.html","title":"Source: composer-common/lib/fsconnectionprofilestore.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/fsconnectionprofilestore.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ConnectionProfileStore = require('./connectionprofilestore'); const homedir = require('homedir'); const mkdirp = require('mkdirp'); const path = require('path'); const rimraf = require('rimraf'); const thenify = require('thenify'); const thenifyAll = require('thenify-all'); const PROFILE_ROOT = (() =&gt; { const h = homedir(); if (h) { return path.resolve(h, '.composer-connection-profiles'); } else { return path.resolve('/', '.composer-connection-profiles'); } })(); const CONNECTION_FILE = 'connection.json'; const ENCODING = 'utf8'; const LOG = require('./log/logger').getLog('FSConnectionProfileStore'); /** * Stores connection profiles on an attached fs fs. * The connection profiles are loaded from the ''&lt;HOME_DIR&gt;/composer-connection-profiles/' * directory. * * @private * @extends ConnectionProfileStore * @see See [ConnectionProfileStore]{@link module:composer-common.ConnectionProfileStore} * @class * @memberof module:composer-common */ class FSConnectionProfileStore extends ConnectionProfileStore { /** * Create the ConnectionManager and attach a file system * @param {fs} fs - Node.js FS implementation, for example BrowserFS */ constructor(fs) { super(); if (!fs) { throw new Error('Must create FSConnectionProfileStore with an fs implementation.'); } this.fs = thenifyAll(fs, {}); this.mkdirp = thenify((dir, cb) =&gt; { return mkdirp(dir, { fs: fs }, cb); }); this.rimraf = thenify((dir, cb) =&gt; { return rimraf(dir, fs, cb); }); } /** * Loads connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to load * @return {Promise} A promise that is resolved with a JS Object for the * data in the connection profile. */ load(connectionProfile) { const options = { flag : 'r', encoding : ENCODING }; return this.fs.readFile(path.resolve(PROFILE_ROOT, connectionProfile, CONNECTION_FILE), options) .then((contents) =&gt; { LOG.info('load','Loaded connection profile ' + connectionProfile, contents); return JSON.parse(contents); }) .catch((err) =&gt; { LOG.error('load','Failed to loaded connection profile ' + connectionProfile, err); throw new Error('Failed to load connection profile ' + connectionProfile + '. Error was ' + err); }); } /** * Save connectOptions for a given connection profile. * * @param {string} connectionProfile The name of the connection profile to save * @param {Object} connectOptions The connection options object * @return {Promise} A promise that once the data is written */ save(connectionProfile, connectOptions) { const DIR = path.resolve(PROFILE_ROOT, connectionProfile); return this.mkdirp(DIR) .then(() =&gt; { const options = { flag : 'w', encoding : ENCODING }; return this.fs.writeFile(path.resolve(DIR, CONNECTION_FILE), JSON.stringify(connectOptions, null, 4), options); }) .then(() =&gt; { LOG.info('save','Saved connection profile ' + connectionProfile); }) .catch((err) =&gt; { LOG.error('save','Failed to save connection profile ' + connectionProfile, err); throw new Error('Failed to save connection profile ' + connectionProfile); }); } /** * Loads all of the connection profiles. * * @return {Promise} A promise that is resolved with a JS Object where the * keys are the connection profiles, and the values are the connection options. */ loadAll() { const result = {}; return this.fs.readdir(PROFILE_ROOT) .then((files) =&gt; { return files.reduce((promise, file) =&gt; { return promise.then(() =&gt; { return this.load(file); }) .then((profile) =&gt; { result[file] = profile; }) .catch((error) =&gt; { // Ignore any errors. }); }, Promise.resolve()); }) .catch((error) =&gt; { // Ignore any errors. }) .then(() =&gt; { return result; }); } /** * Delete the given connection profile. * * @param {string} connectionProfile The name of the connection profile to delete * @return {Promise} A promise that is resolved when the connection profile * is deleted. */ delete(connectionProfile) { const DIR = path.resolve(PROFILE_ROOT, connectionProfile); return this.rimraf(DIR); } } module.exports = FSConnectionProfileStore; × Search results Close "},"composer-common_lib_introspect_functiondeclaration.js.html":{"id":"composer-common_lib_introspect_functiondeclaration.js.html","title":"Source: composer-common/lib/introspect/functiondeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/functiondeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const TransactionDeclaration = require('./transactiondeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); //const Globalize = require('../globalize'); /** * FunctionDeclaration defines a function that has been defined * in a model file. If the name of the function starts with 'on' * then the name of the function denotes the name of a transaction * declaration that the function processes. * @private * @class * @memberof module:composer-common */ class FunctionDeclaration { /** * Create a FunctionDeclaration * * @param {ModelManager} modelManager - the ModelManager used to validate this function * @param {string} language - the language that the function is written in. E.g. JS. * @param {string} name - the name of the function * @param {string} visibility - the visibility of the function * @param {string} returnType - the return type of the function * @param {string} throws - the type that is thrown by the function * @param {string[]} parameterNames - the names of parameters of the function * @param {string[]} parameterTypes - the type names of parameters of the function * @param {string[]} decorators - the function decorators * @param {string} functionText - the function as text * @throws {IllegalModelException} */ constructor(modelManager, language, name, visibility, returnType, throws, parameterNames, parameterTypes, decorators, functionText) { if(modelManager === null) { throw new Error('ModelManager is required.'); } this.modelManager = modelManager; this.name = name; this.language = language; this.visibility = visibility; this.returnType = returnType; this.throws = throws; this.decorators = decorators; this.parameterNames = parameterNames; this.parameterTypes = parameterTypes; this.functionText = functionText; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the text of this function. * * @return {string} the text that defines the function */ getFunctionText() { return this.functionText; } /** * Returns the type thrown by this function * * @return {string} the type thrown by the function */ getThrows() { return this.throws; } /** * Returns the programming language that the function is written in * * @return {string} the language of the function */ getLanguage() { return this.language; } /** * Returns the decorators that the function was tagged with * * @return {string[]} the @ prefixed decorators for the function */ getDecorators() { return this.decorators; } /** * Returns the visibility of this function * * @return {string} the visibility of the function (+ is public), * (- is private) */ getVisibility() { return this.visibility; } /** * Returns the return type for this function * * @return {string} the return type for the function */ getReturnType() { return this.returnType; } /** * Semantic validation of the structure of this function. * * @throws {IllegalModelException} * @private */ validate() { if(this.decorators.indexOf('transaction') &gt; -1) { if(this.decorators.indexOf('query') &gt; -1) { throw new Error('A function cannot be decorated with both @transaction and @query.'); } if(this.parameterTypes.length !== 1) { throw new IllegalModelException('Transaction processing function ' + this.name + ' must have 1 function argument of type transaction.' ); } const transactionClassName = this.parameterTypes[0]; if (ModelUtil.isPrimitiveType(transactionClassName) || !(this.modelManager.getType(transactionClassName) instanceof TransactionDeclaration)) { throw new IllegalModelException('Function ' + this.getName() + ' processes ' + transactionClassName + ' which is not a transaction.'); } } } /** * Returns the name of the function * * @return {string} the name of the function. */ getName() { return this.name; } /** * Returns the short name of the transaction declaration * that is being processed. This is calculated by removing * the 'on' prefix from the function name. * If the function name does not start with 'on' then null * * @return {string} the name of the transaction declaration. */ getTransactionDeclarationName() { if(this.name.startsWith('on')) { return this.name.substring(2); } else { return null; } } /** * Returns the names of the parameters processed by the function. * * @return {string[]} the names of the parameters. */ getParameterNames() { return this.parameterNames; } /** * Returns the types of the parameters processed by the function. * * @return {string[]} the types of the parameters. */ getParameterTypes() { return this.parameterTypes; } } module.exports = FunctionDeclaration; × Search results Close "},"composer-common_lib_model_identifiable.js.html":{"id":"composer-common_lib_model_identifiable.js.html","title":"Source: composer-common/lib/model/identifiable.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/identifiable.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Typed = require('./typed'); /** * Identifiable is an entity with a namespace, type and an identifier. * * This class is abstract. * @abstract * @class * @memberof module:composer-common */ class Identifiable extends Typed{ /** * Create an instance. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type); this.$identifier = id; } /** * Get the identifier of this instance * @return {string} The identifier for this object */ getIdentifier() { return this.$identifier; } /** * Set the identifier of this instance * @param {string} id - the new identifier for this object */ setIdentifier(id) { this.$identifier = id; const modelFile = this.$modelManager.getModelFile(this.getNamespace()); const typeDeclaration = modelFile.getType(this.getFullyQualifiedType()); const idField = typeDeclaration.getIdentifierFieldName(); this[idField] = id; } /** * Get the fully qualified identifier of this instance. * (namespace '.' type '#' identifier). * @return {string} the fully qualified identifier of this instance */ getFullyQualifiedIdentifier() { return this.getFullyQualifiedType() + '#' + this.$identifier; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Identifiable {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Determine if this identifiable is a relationship. * @return {boolean} True if this identifiable is a relationship, * false if not. */ isRelationship() { return false; } /** * Determine if this identifiable is a resource. * @return {boolean} True if this identifiable is a resource, * false if not. */ isResource() { return false; } /** * Returns a URI representation of a reference to this identifiable * @return {String} the URI for the identifiable */ toURI() { const result = 'resource:' + this.getFullyQualifiedType() + '#' + encodeURI(this.getIdentifier()); //console.log( '***** URI for ' + this.toString() + ' is ' + result ); return result; } } module.exports = Identifiable; × Search results Close "},"composer-common_lib_introspect_illegalmodelexception.js.html":{"id":"composer-common_lib_introspect_illegalmodelexception.js.html","title":"Source: composer-common/lib/introspect/illegalmodelexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/illegalmodelexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseModelException = require('./basemodelexception'); /** * Exception throws when a composer file is semantically invalid * @extends BaseModelException * @see See [BaseModelException]{@link module:composer-common.BaseModelException} * @class * @memberof module:composer-common */ class IllegalModelException extends BaseModelException { /** * Create an IllegalModelException. * @param {String} message - the message for the exception * @param {ModelFile} [modelFile] - the optional modelfile associated with the exception * @param {Object} [fileLocation] - location details of the error within the model file. * @param {String} fileLocation.start.line - start line of the error location. * @param {String} fileLocation.start.column - start column of the error location. * @param {String} fileLocation.end.line - end line of the error location. * @param {String} fileLocation.end.column - end column of the error location. */ constructor(message, modelFile, fileLocation) { let messageSuffix = ''; if(modelFile &amp;&amp; modelFile.getName()) { messageSuffix = 'File \\'' + modelFile.getName() + '\\': ' ; } if(fileLocation) { messageSuffix = messageSuffix + 'line ' + fileLocation.start.line + ' column ' + fileLocation.start.column + ', to line ' + fileLocation.end.line + ' column ' + fileLocation.end.column + '. '; } // First character to be uppercase messageSuffix = messageSuffix.charAt(0).toUpperCase() + messageSuffix.slice(1); super(message, fileLocation, message + ' ' + messageSuffix); this.modelFile = modelFile; } /** * Returns the modelfile associated with the exception or null * @return {string} the optional filename associated with the model */ getModelFile() { return this.modelFile; } } module.exports = IllegalModelException; × Search results Close "},"composer-common_lib_serializer_instancegenerator.js.html":{"id":"composer-common_lib_serializer_instancegenerator.js.html","title":"Source: composer-common/lib/serializer/instancegenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/instancegenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const EnumDeclaration = require('../introspect/enumdeclaration'); const Field = require('../introspect/field'); const leftPad = require('left-pad'); const ModelUtil = require('../modelutil'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Util = require('../util'); const ValueGeneratorFactory = require('./valuegenerator'); const Globalize = require('../globalize'); /** * Generate sample instance data for the specified class declaration * and resource instance. The specified resource instance will be * updated with either default values or generated sample data. * @private * @class * @memberof module:composer-common */ class InstanceGenerator { /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const obj = parameters.stack.pop(); const properties = classDeclaration.getProperties(); for (const property of properties) { if (!parameters.includeOptionalFields &amp;&amp; property.isOptional()) { continue; } const value = obj[property.getName()]; if(Util.isNull(value)) { obj[property.getName()] = property.accept(this,parameters); } } return obj; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { if (field.isArray()) { let result = []; for (let i = 0; i &lt; 3; i++) { result.push(this.getFieldValue(field, parameters)); } return result; } else { return this.getFieldValue(field, parameters); } } /** * Get a value for the specified field. * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {*} A value for the specified field. */ getFieldValue(field, parameters) { let type = field.getFullyQualifiedTypeName(); let valueGenerator = parameters.valueGenerator || ValueGeneratorFactory.sample(); if (ModelUtil.isPrimitiveType(type)) { switch(type) { case 'DateTime': return valueGenerator.getDateTime(); case 'Integer': return valueGenerator.getInteger(); case 'Long': return valueGenerator.getLong(); case 'Double': return valueGenerator.getDouble(); case 'Boolean': return valueGenerator.getBoolean(); default: return valueGenerator.getString(); } } let classDeclaration = parameters.modelManager.getType(type); if (classDeclaration instanceof EnumDeclaration) { let enumValues = classDeclaration.getOwnProperties(); return valueGenerator.getEnum(enumValues).getName(); } if (classDeclaration.isAbstract()) { const newClassDecl = this.findConcreteSubclass(classDeclaration); classDeclaration = newClassDecl; type = newClassDecl.getName(); } if (classDeclaration.isConcept()) { let concept = parameters.factory.newConcept(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName()); parameters.stack.push(concept); return classDeclaration.accept(this, parameters); } else { let identifierFieldName = classDeclaration.getIdentifierFieldName(); let idx = Math.round(Math.random() * 9999).toString(); idx = leftPad(idx, 4, '0'); let id = `${identifierFieldName}:${idx}`; let resource = parameters.factory.newResource(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), id); parameters.stack.push(resource); return classDeclaration.accept(this, parameters); } } /** * Find a type that extends the provided abstract type and return it. * TODO: work out whether this has to be a leaf node or whether the closest type can be used * It depends really since the closest type will satisfy the model but whether it satisfies * any transaction code which attempts to use the generated resource is another matter. * @param {ClassDeclaration} declaration the class declaration. * @return {ClassDeclaration} the closest extending concrete class definition - null if none are found. * @throws {Error} if no concrete subclasses exist. */ findConcreteSubclass(declaration) { if (!declaration.isAbstract()) { return declaration; } const concreteSubclasses = declaration.getAssignableClassDeclarations() .filter(subclass =&gt; !subclass.isAbstract()); if (concreteSubclasses.length === 0) { const formatter = Globalize.messageFormatter('instancegenerator-newinstance-noconcreteclass'); throw new Error(formatter({ type: declaration.getFullyQualifiedName() })); } return concreteSubclasses[0]; } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { let classDeclaration = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); let identifierFieldName = classDeclaration.getIdentifierFieldName(); let factory = parameters.factory; if (relationshipDeclaration.isArray()) { let result = []; for (let i = 0; i &lt; 3; i++) { let idx = Math.round(Math.random() * 9999).toString(); idx = leftPad(idx, 4, '0'); let id = `${identifierFieldName}:${idx}`; let relationship = factory.newRelationship(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), id); result.push(relationship); } return result; } else { let idx = Math.round(Math.random() * 9999).toString(); idx = leftPad(idx, 4, '0'); let id = `${identifierFieldName}:${idx}`; let relationship = factory.newRelationship(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), id); return relationship; } } } module.exports = InstanceGenerator; × Search results Close "},"composer-common_lib_introspect_introspector.js.html":{"id":"composer-common_lib_introspect_introspector.js.html","title":"Source: composer-common/lib/introspect/introspector.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/introspector.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * &lt;p&gt; * Provides access to the structure of transactions, assets and participants. * &lt;/p&gt; * @class * @memberof module:composer-common */ class Introspector { /** * Create the Introspector. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - the ModelManager that backs this Introspector */ constructor(modelManager) { this.modelManager = modelManager; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns all the class declarations for the business network. * @return {ClassDeclaration[]} the array of class declarations */ getClassDeclarations() { let result = []; const modelFiles = this.modelManager.getModelFiles(); for(let n=0; n &lt; modelFiles.length; n++) { const modelFile = modelFiles[n]; result = result.concat(modelFile.getAllDeclarations()); } return result; } /** * Returns the class declaration with the given fully qualified name. * Throws an error if the class declaration does not exist. * @param {String} fullyQualifiedTypeName - the fully qualified name of the type * @return {ClassDeclaration} the class declaration * @throws {Error} if the class declaration does not exist */ getClassDeclaration(fullyQualifiedTypeName) { return this.modelManager.getType(fullyQualifiedTypeName); } /** * Returns the backing ModelManager * @return {ModelManager} the backing ModelManager * @private */ getModelManager() { return this.modelManager; } } module.exports = Introspector; × Search results Close "},"composer-common_lib_codegen_javascriptparser.js.html":{"id":"composer-common_lib_codegen_javascriptparser.js.html","title":"Source: composer-common/lib/codegen/javascriptparser.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/javascriptparser.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const doctrine = require('doctrine'); const esprima = require('esprima'); const acorn = require('acorn'); /** * Processes a single Javascript file (.js extension) * * @param {string} file - the file to process * @param {Object} fileProcessor - the processor instance to use to generate code * @private * @class * @memberof module:composer-common */ class JavaScriptParser { /** * Create a JavaScriptParser. * * @param {string} fileContents - the text of the JS file to parse * @param {boolean} [includePrivates] - if true methods tagged as private are also returned * @param {number} [ecmaVersion] - the ECMAScript version to use */ constructor(fileContents, includePrivates, ecmaVersion) { let comments = []; this.tokens = []; let options = { // collect ranges for each node ranges: true, // collect comments in Esprima's format onComment: comments, // collect token ranges onToken: this.tokens, // collect token locations locations: true }; if (ecmaVersion) { options.ecmaVersion = ecmaVersion; } let ast = acorn.parse(fileContents, options); this.includes = []; this.classes = []; this.functions = []; for (let n = 0; n &lt; ast.body.length; n++) { let statement = ast.body[n]; if (statement.type === 'VariableDeclaration') { let variableDeclarations = statement.declarations; for (let n = 0; n &lt; variableDeclarations.length; n++) { let variableDeclaration = variableDeclarations[n]; if (variableDeclaration.init &amp;&amp; variableDeclaration.init.type === 'CallExpression' &amp;&amp; variableDeclaration.init.callee.name === 'require') { let requireName = variableDeclaration.init.arguments[0].value; // we only care about the code we require with a relative path if (requireName.startsWith('.')) { this.includes.push(variableDeclaration.init.arguments[0].value); } } } } else if (statement.type === 'FunctionDeclaration') { //console.log(JSON.stringify(statement)); let closestComment = JavaScriptParser.findCommentBefore(statement.start, statement.end, comments); let returnType = ''; let visibility = '+'; let parameterTypes = []; let parameterNames = []; let decorators = []; let throws = ''; let example = ''; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; //console.log('Found comment: ' + comment ); returnType = JavaScriptParser.getReturnType(comment); visibility = JavaScriptParser.getVisibility(comment); parameterTypes = JavaScriptParser.getMethodArguments(comment); throws = JavaScriptParser.getThrows(comment); decorators = JavaScriptParser.getDecorators(comment); example = JavaScriptParser.getExample(comment); } if(visibility === '+' || includePrivates) { for(let n=0; n &lt; statement.params.length; n++) { parameterNames.push(statement.params[n].name); } const func = { visibility: visibility, returnType: returnType, name: statement.id.name, parameterTypes: parameterTypes, parameterNames: parameterNames, throws: throws, decorators: decorators, functionText : JavaScriptParser.getText(statement.start, statement.end, fileContents), example: example }; //console.log('Function: ' + JSON.stringify(func)); this.functions.push(func); } } else if (statement.type === 'ClassDeclaration') { let closestComment = JavaScriptParser.findCommentBefore(statement.start, statement.end, comments); let privateClass = false; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; privateClass = JavaScriptParser.getVisibility(comment) === '-'; } if(privateClass === false || includePrivates) { const clazz = { name: statement.id.name}; clazz.methods = []; for(let n=0; n &lt; statement.body.body.length; n++) { let thing = statement.body.body[n]; if (thing.type === 'MethodDefinition') { let closestComment = JavaScriptParser.findCommentBefore(thing.key.start, thing.key.end, comments); let returnType = ''; let visibility = '+'; let methodArgs = []; let throws = ''; let decorators = []; let example = ''; if(closestComment &gt;= 0) { let comment = comments[closestComment].value; returnType = JavaScriptParser.getReturnType(comment); visibility = JavaScriptParser.getVisibility(comment); methodArgs = JavaScriptParser.getMethodArguments(comment); decorators = JavaScriptParser.getDecorators(comment); throws = JavaScriptParser.getThrows(comment); example = JavaScriptParser.getExample(comment); } if(visibility === '+' || includePrivates) { const method = { visibility: visibility, returnType: returnType, name: thing.key.name, methodArgs: methodArgs, decorators: decorators, throws: throws, example: example }; clazz.methods.push(method); } } } if (statement.superClass) { clazz.superClass = statement.superClass.name; } this.classes.push(clazz); } } } } /** * Return the includes that were extracted from the JS file. * * @return {Object[]} information about each include */ getIncludes() { return this.includes; } /** * Return the classes that were extracted from the JS file. * * @return {Object[]} information about each class */ getClasses() { return this.classes; } /** * Return the methods that were extracted from the JS file. * * @return {Object[]} information about each method */ getFunctions() { return this.functions; } /** * Return the tokens that were extracted from the JS file. * * @return {Object[]} information about each tokens */ getTokens() { return this.tokens; } /** * Grab the text between a range * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {string} source - the source text * @return {string} the text between start and end * @private */ static getText(rangeStart, rangeEnd, source) { return source.substring(rangeStart, rangeEnd); } /** * Find the comments that are above and closest to the start of the range. * * @param {integer} rangeStart - the start of the range * @param {integer} rangeEnd - the end of the range * @param {string[]} comments - the end of the range * @return {integer} the comment index or -1 if there are no comments * @private */ static findCommentBefore(rangeStart, rangeEnd, comments) { let foundIndex = -1; let distance = -1; for(let n=0; n &lt; comments.length; n++) { let comment = comments[n]; let endComment = comment.end; if(rangeStart &gt; endComment ) { if(distance === -1 || rangeStart - endComment &lt; distance) { distance = rangeStart - endComment; foundIndex = n; } } } return foundIndex; } /** * Grabs all the @ prefixed decorators from a comment block. * @param {string} comment - the comment block * @return {string[]} the @ prefixed decorators within the comment block * @private */ static getDecorators(comment) { const re = /(?:^|\\W)@(\\w+)/g; let match; const matches = []; match = re.exec(comment); while (match) { matches.push(match[1]); match = re.exec(comment); } return matches; } /** * Extracts the visibilty from a comment block * @param {string} comment - the comment block * @return {string} the return visibility (either + for public, or - for private) * @private */ static getVisibility(comment) { const PRIVATE = 'private'; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [PRIVATE]}); const tags = parsedComment.tags; if (tags.length &gt; 0) { return '-'; } return '+'; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment * @private */ static getReturnType(comment) { const RETURN = 'return'; const RETURNS = 'returns'; let result = 'void'; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [RETURN, RETURNS]}); const tags = parsedComment.tags; if (tags.length &gt; 1) { throw new Error('Malformed JSDoc comment. More than one returns: ' + comment ); } tags.forEach((tag) =&gt; { if (tag.type) { if (!tag.type.name &amp;&amp; !tag.type) { throw new Error('Malformed JSDoc comment. ' + comment ); } if (tag.type.name) { result = tag.type.name; } else if (tag.type.applications){ result = tag.type.applications[0].name + '[]'; } else if (tag.type.expression) { result = tag.type.expression.name; } } else { throw new Error('Malformed JSDoc comment. ' + comment ); } }); return result; } /** * Extracts the return type from a comment block. * @param {string} comment - the comment block * @return {string} the return type of the comment * @private */ static getThrows(comment) { const THROWS = 'throws'; const EXCEPTION = 'exception'; let result = ''; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [THROWS, EXCEPTION]}); const tags = parsedComment.tags; if (tags.length &gt; 1) { throw new Error('Malformed JSDoc comment. More than one throws/exception: ' + comment ); } tags.forEach((tag) =&gt; { if (tag.type) { if (!tag.type.type || !tag.type.name) { throw new Error('Malformed JSDoc comment. ' + comment ); } result = tag.type.name; } else { throw new Error('Malformed JSDoc comment. ' + comment); } }); return result; } /** * Extracts the method arguments from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types * @private */ static getMethodArguments(comment) { const TAG = 'param'; let paramTypes = []; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [TAG]}); const tags = parsedComment.tags; // param is mentined but not picked up by parser if (comment.indexOf('@'+TAG) !== -1 &amp;&amp; tags.length === 0) { throw new Error('Malformed JSDoc comment: ' + comment ); } tags.forEach((tag) =&gt; { if (tag.description) { //If description starts with } if (tag.description.trim().indexOf('}') === 0 || !tag.type || !tag.name ) { throw new Error('Malformed JSDoc comment: ' + comment ); } } if(tag.type.name) { if (tag.type.name.indexOf(' ') !== -1) { throw new Error('Malformed JSDoc comment: ' + comment ); } } if (tag.type.name) { paramTypes.push(tag.type.name); } else if (tag.type.applications){ paramTypes.push(tag.type.applications[0].name + '[]'); } else if (tag.type.expression) { paramTypes.push(tag.type.expression.name); } }); return paramTypes; } /** * Extracts the example tag from a comment block. * @param {string} comment - the comment block * @return {string} the the argument types * @private */ static getExample(comment) { const EXAMPLE = 'example'; let result = ''; let parsedComment = doctrine.parse(comment, {unwrap: true, sloppy: true, tags: [EXAMPLE]}); const tags = parsedComment.tags; if (tags.length &gt; 0) { result = tags[0].description; } try { // Pass as a function so that return statements are valid let program = 'function testSyntax() {' + result + '}'; esprima.parse(program); } catch (e) { throw Error('Malformed JSDoc Comment. Invalid @example tag: ' + comment); } return result; } } module.exports = JavaScriptParser; × Search results Close "},"composer-common_lib_serializer_jsongenerator.js.html":{"id":"composer-common_lib_serializer_jsongenerator.js.html","title":"Source: composer-common/lib/serializer/jsongenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/jsongenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Resource = require('../model/resource'); const Typed = require('../model/typed'); const Concept = require('../model/concept'); const ModelUtil = require('../modelutil'); const Util = require('../util'); /** * Converts the contents of a Resource to JSON. The parameters * object should contain the keys * 'writer' - the JSONWriter instance to use to accumulate the JSON text. * 'stack' - the TypedStack of objects being processed. It should * start with a Resource. * 'modelManager' - the ModelManager to use. * @private * @class * @memberof module:composer-common */ class JSONGenerator { /** * Constructor. * @param {boolean} [convertResourcesToRelationships] Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} [permitResourcesForRelationships] Permit resources in the * place of relationships (serializing them as resources), false by default. */ constructor(convertResourcesToRelationships, permitResourcesForRelationships) { this.convertResourcesToRelationships = convertResourcesToRelationships; this.permitResourcesForRelationships = permitResourcesForRelationships; } /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { parameters.writer.openObject(); parameters.writer.writeKeyStringValue('$class', classDeclaration.getFullyQualifiedName()); const obj = parameters.stack.pop(); if(!((obj instanceof Resource) || (obj instanceof Concept))) { throw new Error('Expected a Resource or a Concept, but found ' + obj ); } const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if(!Util.isNull(value)) { parameters.stack.push(value); property.accept(this,parameters); } } parameters.writer.closeObject(); return null; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(field.getName()); if(field.isArray()) { parameters.writer.openArray(); for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; if(!field.isPrimitive() &amp;&amp; !ModelUtil.isEnum(field)) { parameters.writer.writeComma(); parameters.stack.push(item, Typed); const classDecl = parameters.modelManager.getType(item.getFullyQualifiedType()); classDecl.accept(this, parameters); } else { parameters.writer.writeArrayValue(this.convertToJSON(field,item)); } } parameters.writer.closeArray(); } else if(field.isPrimitive() || ModelUtil.isEnum(field)) { parameters.writer.writeValue(this.convertToJSON(field,obj)); } else { parameters.stack.push(obj); const classDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); classDeclaration.accept(this, parameters); } return null; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} obj - the object to convert to text * @return {string} the text representation */ convertToJSON(field, obj) { switch(field.getType()) { case 'DateTime': { return `&quot;${obj.toISOString()}&quot;`; } case 'Integer': case 'Long': case 'Double': case 'Boolean':{ return `${obj.toString()}`; } default: { return JSON.stringify(obj.toString()); } } } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const obj = parameters.stack.pop(); parameters.writer.writeKey(relationshipDeclaration.getName()); if(relationshipDeclaration.isArray()) { parameters.writer.openArray(); for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; if (this.permitResourcesForRelationships &amp;&amp; item instanceof Resource) { let fqi = item.getFullyQualifiedIdentifier(); if (parameters.seenResources.has(fqi)) { let relationshipText = this.getRelationshipText(relationshipDeclaration, item ); parameters.writer.writeStringValue(relationshipText); } else { parameters.seenResources.add(fqi); parameters.writer.writeComma(); parameters.stack.push(item, Resource); const classDecl = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); classDecl.accept(this, parameters); parameters.seenResources.delete(fqi); } } else { let relationshipText = this.getRelationshipText(relationshipDeclaration, item ); parameters.writer.writeArrayStringValue(relationshipText); } } parameters.writer.closeArray(); } else if (this.permitResourcesForRelationships &amp;&amp; obj instanceof Resource) { let fqi = obj.getFullyQualifiedIdentifier(); if (parameters.seenResources.has(fqi)) { let relationshipText = this.getRelationshipText(relationshipDeclaration, obj ); parameters.writer.writeStringValue(relationshipText); } else { parameters.seenResources.add(fqi); parameters.stack.push(obj, Resource); const classDecl = parameters.modelManager.getType(relationshipDeclaration.getFullyQualifiedTypeName()); classDecl.accept(this, parameters); parameters.seenResources.delete(fqi); } } else { let relationshipText = this.getRelationshipText(relationshipDeclaration, obj ); parameters.writer.writeStringValue(relationshipText); } return null; } /** * Returns the persistent format for a relationship. * @param {RelationshipDeclaration} relationshipDeclaration - the relationship being persisted * @param {Identifiable} relationshipOrResource - the relationship or the resource * @returns {string} the text to use to persist the relationship */ getRelationshipText(relationshipDeclaration, relationshipOrResource) { if(relationshipOrResource instanceof Resource) { const allowRelationships = this.convertResourcesToRelationships || this.permitResourcesForRelationships; if(!allowRelationships) { throw new Error('Did not find a relationship for ' + relationshipDeclaration.getFullyQualifiedTypeName() + ' found ' + relationshipOrResource ); } } return relationshipOrResource.toURI(); } } module.exports = JSONGenerator; × Search results Close "},"composer-common_lib_serializer_jsonpopulator.js.html":{"id":"composer-common_lib_serializer_jsonpopulator.js.html","title":"Source: composer-common/lib/serializer/jsonpopulator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/jsonpopulator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const Relationship = require('../model/relationship'); const Util = require('../util'); const ModelUtil = require('../modelutil'); /** * Populates a Resource with data from a JSON object graph. The JSON objects * should be the result of calling Serializer.toJSON and then JSON.parse. * The parameters object should contain the keys * 'stack' - the TypedStack of objects being processed. It should * start with the root object from JSON.parse. * 'factory' - the Factory instance to use for creating objects. * 'modelManager' - the ModelManager instance to use to resolve classes * @private * @class * @memberof module:composer-common */ class JSONPopulator { /** * Constructor. * @param {boolean} [acceptResourcesForRelationships] Permit resources in the * place of relationships, false by default. */ constructor(acceptResourcesForRelationships) { this.acceptResourcesForRelationships = acceptResourcesForRelationships; } /** * Visitor design pattern * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } else { throw new Error('Unrecognised ' + JSON.stringify(thing) ); } } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); const resourceObj = parameters.resourceStack.pop(); const properties = classDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = jsonObj[property.getName()]; if(!Util.isNull(value)) { parameters.jsonStack.push(value); resourceObj[property.getName()] = property.accept(this,parameters); } } return resourceObj; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; if(field.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { const jsonItem = jsonObj[n]; result.push(this.convertItem(field,jsonItem, parameters)); } } else { result = this.convertItem(field,jsonObj, parameters); } return result; } /** * * @param {Field} field - the field of the item being converted * @param {Object} jsonItem - the JSON object of the item being converted * @param {Object} parameters - the parameters * @return {Object} - the populated object. */ convertItem(field, jsonItem, parameters) { let result = null; if(!field.isPrimitive() &amp;&amp; !field.isTypeEnum()) { let typeName = jsonItem.$class; if(!typeName) { // If the type name is not specified in the data, then use the // type name from the model. This will only happen in the case of // a sub resource inside another resource. typeName = field.getFullyQualifiedTypeName(); } // This throws if the type does not exist. const classDeclaration = parameters.modelManager.getType(typeName); // create a new instance, using the identifier field name as the ID. let subResource = null; // if this is identifiable, then we create a resource if(!classDeclaration.isConcept()) { subResource = parameters.factory.newResource(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); } else { // otherwise we create a concept subResource = parameters.factory.newConcept(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName() ); } result = subResource; parameters.resourceStack.push(subResource); parameters.jsonStack.push(jsonItem); classDeclaration.accept(this, parameters); } else { result = this.convertToObject(field,jsonItem); } return result; } /** * Converts a primtive object to JSON text. * * @param {Field} field - the field declaration of the object * @param {Object} json - the JSON object to convert to a Composer Object * @return {string} the text representation */ convertToObject(field, json) { let result = null; switch(field.getType()) { case 'DateTime': result = new Date(json); break; case 'Integer': case 'Long': result = parseInt(json); break; case 'Double': result = parseFloat(json); break; case 'Boolean': result = (json === true || json === 'true'); break; case 'String': result = json.toString(); break; default: // everything else should be an enumerated value... result = json; } return result; } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const jsonObj = parameters.jsonStack.pop(); let result = null; let typeFQN = relationshipDeclaration.getFullyQualifiedTypeName(); let defaultNamespace = ModelUtil.getNamespace(typeFQN); if(!defaultNamespace) { defaultNamespace = relationshipDeclaration.getNamespace(); } let defaultType = ModelUtil.getShortName(typeFQN); if(relationshipDeclaration.isArray()) { result = []; for(let n=0; n &lt; jsonObj.length; n++) { let jsonItem = jsonObj[n]; if (typeof jsonItem === 'string') { result.push(Relationship.fromURI(parameters.modelManager, jsonItem, defaultNamespace, defaultType )); } else { if (!this.acceptResourcesForRelationships) { throw new Error('Invalid JSON data. Found a value that is not a string: ' + jsonObj + ' for relationship ' + relationshipDeclaration); } // this isn't a relationship, but it might be an object! if(!jsonItem.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonItem + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonItem.$class); // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newResource(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonItem[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonItem); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result.push(subResource); } } } else { if (typeof jsonObj === 'string') { result = Relationship.fromURI(parameters.modelManager, jsonObj, defaultNamespace, defaultType ); } else { if (!this.acceptResourcesForRelationships) { throw new Error('Invalid JSON data. Found a value that is not a string: ' + jsonObj + ' for relationship ' + relationshipDeclaration); } // this isn't a relationship, but it might be an object! if(!jsonObj.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier: ' + jsonObj + ' for relationship ' + relationshipDeclaration ); } const classDeclaration = parameters.modelManager.getType(jsonObj.$class); // create a new instance, using the identifier field name as the ID. let subResource = parameters.factory.newResource(classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObj[classDeclaration.getIdentifierFieldName()] ); parameters.jsonStack.push(jsonObj); parameters.resourceStack.push(subResource); classDeclaration.accept(this, parameters); result = subResource; } } return result; } } module.exports = JSONPopulator; × Search results Close "},"composer-common_lib_codegen_jsonwriter.js.html":{"id":"composer-common_lib_codegen_jsonwriter.js.html","title":"Source: composer-common/lib/codegen/jsonwriter.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/jsonwriter.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Writer = require('./writer'); /** * JSONWriter manages a text buffer for writing JSON data structures. * It tracks when a comma is needed to separate items. Commas are inserted * automatically based on context. * @private * @extends Writer * @see See [Writer]{@link module:composer-common.Writer} * @class * @memberof module:composer-common */ class JSONWriter extends Writer { /** * Create a JSONWriter. * */ constructor() { super(); this.indent = 0; this.firstItem = true; } /** * Opens an object declaration * @param {string} key - the key */ openObject() { this.write('{'); this.indent++; this.firstItem = true; this.log('{'); } /** * Close the current object declaration. */ closeObject() { this.write('}'); this.indent--; this.firstItem = false; this.log('}'); } /** * Writes a key, in the format * '&quot;key&quot; : ' * @param {string} key - the key */ writeKey(key) { this.writeComma(); this.write(JSON.stringify(key) + ':'); this.log('writeKey', key ); } /** * Writes a comma when this.firstItem === false */ writeComma() { if(this.firstItem === false) { this.write(','); this.log(','); } else { this.log(', (suppressed)'); } } /** * Writes a value, in the format: * '&quot;value&quot;' * @param {string} value - the value */ writeStringValue(value) { this.write(JSON.stringify(value)); this.firstItem = false; this.log('writeStringValue', value); } /** * Writes a value, in the format: * 'value' * @param {string} value - the value */ writeValue(value) { this.write(`${value}`); this.firstItem = false; this.log('writeValue', value); } /** * Writes a key/value, in the format: * '&quot;key&quot; : &quot;value&quot;' * @param {string} key - the key * @param {string} value - the value */ writeKeyStringValue(key,value) { this.writeComma(); this.writeKey(key); this.writeStringValue(value); this.firstItem = false; this.log('writeKeyStringValue', (key + ':' + value)); } /** * Writes a key/value, in the format: * '&quot;key&quot; : value' * @param {string} key - the key * @param {string} value - the value */ writeKeyValue(key,value) { this.writeComma(); this.writeKey(key); this.writeValue(value); this.firstItem = false; this.log('writeKeyValue', key + '=' + value); } /** * Writes an array value, in the format * '&quot;value&quot;' * @param {string} value - the value */ writeArrayStringValue(value) { this.writeComma(); this.writeStringValue(value); this.firstItem = false; this.log('writeArrayStringValue', value); } /** * Writes an array value, in the format * 'value' * @param {string} value - the value */ writeArrayValue(value) { this.writeComma(); this.write(`${value}`); this.firstItem = false; this.log('writeArrayValue', value); } /** * Opens a new array */ openArray() { this.write('['); this.indent++; this.firstItem = true; this.log('['); } /** * Closes the current array */ closeArray() { this.write(']'); this.indent--; this.firstItem = false; this.log(']'); } /** * @return {String} a string represention of this class */ toString() { return 'indent ' + this.indent + ' firstItem ' + this.firstItem; } /** * @param {String} callSite - the location * @param {String} message - the message to log. */ log(callSite, message) { const log = false; if(log) { let spaces = ''; for(let n=0; n &lt; this.indent; n++) { spaces += ' '; } if(!message) { message = ''; } console.log(spaces + ' ' + message + ' ' + callSite ); } } /** * Empties the underyling buffer and resets the line count. */ clearBuffer() { super.clearBuffer(); this.indent = 0; this.firstItem = true; } } module.exports = JSONWriter; × Search results Close "},"composer-common_lib_query_limit.js.html":{"id":"composer-common_lib_query_limit.js.html","title":"Source: composer-common/lib/query/limit.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/limit.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Limit defines the LIMIT portion of a SELECT statement * * @private * @class * @memberof module:composer-common */ class Limit { /** * Create a Limit from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this Limit * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new IllegalModelException('Invalid Select or AST'); } this.ast = ast; this.select = select; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this Limit. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this limit. * * @throws {IllegalModelException} * @private */ validate() { // TODO (DCS) walk the AST and check that the properties exist in the model! } /** * Return the AST for this limit statement. * @return {Object} The AST for this limit statement. */ getAST() { return this.ast; } } module.exports = Limit; × Search results Close "},"composer-common_lib_log_logger.js.html":{"id":"composer-common_lib_log_logger.js.html","title":"Source: composer-common/lib/log/logger.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/logger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const sprintf = require('sprintf-js').sprintf; const Tree = require('./tree.js'); // Root node of the selection tree let _tree = null; // Core logger that is in use (user configurable) let _logger = null; // Set of instances of this logger class that acts as a proxy to the core logger let _clInstances = {}; /** * @description Class that provides the API to enable parts of the *Composer* * library to diagnostic messages. * * The aim is to provide a system whereby * - The *Composer* library has a common API to call and formats the essential data * its way * - It's own control of what level of data points are currently being collected * and for what module/class level * - Provide a default console and/or file basic log if user's application doesn't have * any preference * - Provide hook in which application can provide an injected dependancy to route * tracing to its own Logger * * # Log Levels * Standard log levels are in use. In order these are * - silly, debug, verbose, info, warn, error * In addition, there are functions that record method entry and method exit. these * map down to the debug level. [Silly level isn't being used] * * Examples of using each function are included for each API below. * * At the top of the class (or file if not object style) issue. * * ``` * const log = require('./log/logger.js').getLog(&lt;CLASSNAME&gt;); * log.info(.....) * ``` * The classname is in a fully qualified format eg common/BusinessNetworkDefinition or * cli/archiveCreate. * * Comming Soon: Aliases * * @private * @class * @memberof module:composer-common */ class Logger { /** * Constructor *THIS SHOULD ONLY BE CALLED INTERNALLY* * @param {String} name Classname or other filename for this logger * @private * */ constructor(name) { this.className = name; } /** * * @description Do the formatting of the data that *Composer* wishes to have for all * logging systems. This method does basic formatting before passing to the * log method of the selected logger implementation. * * Internal method * * @private * @param {String} logLevel log loglevel * @param {String} method method name * @param {String} msg to log * @param {others} arguments parameters are treated as data points to be logged */ intlog(logLevel,method,msg){ // first we need to make sure that we have logger setup this._intLogFirst.apply(this,arguments); } /** * @description Main internal logging method * Required fn here is to form up the arguements into a suitable string, and * process any errors to capture the stack trace. The core logger is then CALLED * * The assumption is that this logger has a method called `log`. with this prototype * `log(String loglevel, String codeunit, String message, Array[optional] data)` * * @param {String} loglevel log loglevel * @param {String} method method name * @param {String} msg to log */ _intLogMain(loglevel,method,msg){ if (typeof arguments[3] ==='undefined'){ // this is the case where there are no additional arguements; data for example _logger.log(loglevel,sprintf('%-25s:%-25s', this.className,method+'()'),msg); } else { // loop over the aguements - if any are Errors make sure that the stack trace is captured let args = []; for(let i = 3; i &lt; arguments.length; i++) { if (arguments[i] instanceof Error){ args.push( {'stack' : sprintf('{%s}%s %s',arguments[i].name,arguments[i].message,arguments[i].stack,null,' ').match(/[^\\r\\n]+/g)}); }else { args.push(arguments[i]); } } _logger.log(loglevel,sprintf('%-25s:%-25s', this.className,method+'()'),msg, args); } } /** * @description initial internal log function that setups the logger to use. * Then it calls the normal internal log method (and modifies the original * function defn) * * @param {String} logLevel log loglevel * @param {String} method method name * @param {String} msg to log */ _intLogFirst(logLevel,method,msg){ // call the setup logger to make sure that things are setup // this is done now to be as late as possible Logger._setupLog(this); //reroute the ingLog method to the main implementation // and call this.intLog = this._intLogMain; // this._intLogMain.apply(this,arguments); this._intLogMain.apply(this,arguments); } /** * @description Log a message at the _debug_level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log * * @private */ debug(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('debug'); this.intlog.apply(this, args); } /** * @description Log a message at the _warn_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at warn level * * @private */ warn(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('warn'); this.intlog.apply(this, args); } /** * @description Log a message at the _info_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at an info level * * @private */ info(method, msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('info'); this.intlog.apply(this, args); } /** * @description Log a message at the _verbose_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at a verbose level * * @private */ verbose(method,msg, data) { const args = Array.prototype.slice.call(arguments); args.unshift('verbose'); this.intlog.apply(this, args); } /** * @description Log a message at the _error_ level * * @param {String} method calling method * @param {String} msg Text Message * @param {stuff} data Data to log at an error level * * @private */ error(method, msg,data) { const args = Array.prototype.slice.call(arguments); args.unshift('error'); this.intlog.apply(this, args); } /** * @description Logs the entry to a method at the _debug_ level * * @param {String} method Text Message. * @param {stuff} data Data to log at an info level * * @private */ entry(method, data) { const args = Array.prototype.slice.call(arguments); args.shift(); args.unshift('debug', method, '&gt;'); this.intlog.apply(this, args); } /** * @description Logs the entry to a method at the _debug_ level * @param {String} method Method name * @param {objects} data Data to log * * @private */ exit(method, data) { const args = Array.prototype.slice.call(arguments); args.shift(); args.unshift('debug', method, '&lt;'); this.intlog.apply(this, args); } /** * @description Method to call passing an instance of an object that has the * method definition * * log(level,msg,data...) * * @param {Object} newlogger sets a new log processor to the one of your choice * * @private */ static setFunctionalLogger(newlogger){ _logger = newlogger; } /** * @description what is the debug environment variable set to * Note that the _envDebug property of this object is for debugging the debugging log * and emergency use ONLY * * @return {String} String of the DEBUG env variable * */ static getDebugEnv(){ return process.env.DEBUG || this._envDebug || ''; } /** * @description Get the configuration for the logging. * This uses the config module to look for a configuration block under the * composer.debug property. * * The 'logger' property is required to specify the core logger to use. By * default this is the 'winstonInjector' that creates and returns a Winston backed * console and file logger. * * The 'config' property is required - but the contents of this property are passed * as is to the class defined in the logger property. * * @return {Object} with the config iformation * **/ static getLoggerConfig(){ try { // This weird code is needed to trick browserify. process.env.SUPPRESS_NO_CONFIG_WARNING = 'y'; const mod = 'config'; const req = require; const config = req(mod); if (config.has('composer.debug')){ return config.get('composer.debug'); } } catch (e) { // We don't care if we can't find the config module, it won't be // there when the code is running inside a browser/chaincode. } return { 'logger': './winstonInjector.js', 'config': { 'console': { 'enabledLevel': 'info', 'alwaysLevel': 'none' }, 'file': { 'filename': 'trace_PID.log', 'enabledLevel': 'silly', 'alwaysLevel': 'info' } }}; } /** * @description Get the logger instance to be used for this class or file. * * @param {String} classname The classname (or filename if not a class) to get the logger for * @return {ConcertoLog} instance of a concertoLog to use * * @private */ static getLog(classname) { if(typeof _clInstances[classname] === 'undefined') { _clInstances[classname] = new Logger(classname); _clInstances[classname].log = Logger._intLogFirst; } return _clInstances[classname]; } /** @description gets the configuration that has been passed in to this node.js runtime * to control the tracing. This will update the concertLogger instance that * is passed in to match the settings * * @param {Logger} concertoLogger the instance of the Logger class to update */ static _setupLog(concertoLogger){ let concertoConfigElements = []; if (_tree === null){ // need to do the filtering to see if this shold be enabled or not let string = this.getDebugEnv(); let details = string.split(/[\\s,]+/); // _root = new Node('root',false); _tree = new Tree(); const regex = /(-?)composer:(.*)?/; // now we have an array of the elements that we might need to be enabled // for (let i=0; i&lt; details.length;i++){ let e = details[i]; if (e === '*' || e ==='composer:*'){ _tree.setRootInclusion(); } // determine if the element is for concerto or not let machResult = e.match(regex); if (machResult!==null){ // got a result that we need to trace therefore setup the child node correctly _tree.addNode(machResult[2] ,(machResult[1]==='') ); // make a note of the debug settings that permit the config elements concertoConfigElements.push(machResult[2]); } } } // need to check the config to determine what exactly we need to be using here if(_logger === null) { let localConfig = this.getLoggerConfig(); // use the config package to get conifguration to see what we should be doing. // and pass the restul fo the data to the logger indicated along with the // array of the data that might have been passed on the DBEUG variable. let loggerToUse = localConfig.logger; let myLogger = require(loggerToUse); // primary used to determine what has been abled to allow the logger to // go into a default mode.. NOT MEANT TO BE USED FOR FILTERTING. _logger = myLogger.getLogger(localConfig.config,{ 'debug' : concertoConfigElements } ); } // now we need to check if the name that has come in and should be traced concertoLogger.include = _tree.getInclusion(concertoLogger.className); return ; } /** * @description clean up the logger; required if anything is dynamically changed */ static reset(){ _tree=null; _logger=null; _clInstances=[]; } } module.exports = Logger; × Search results Close "},"composer-common_lib_acl_modelbinding.js.html":{"id":"composer-common_lib_acl_modelbinding.js.html","title":"Source: composer-common/lib/acl/modelbinding.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/modelbinding.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ModelUtil = require('../modelutil'); /** * ModelBinding captures a binding to a model element. A ModelBinding can * be to a namespace, a class, or an instance of a class, and may optionally * be bound to a named variable. * * @private * @class * @memberof module:composer-common */ class ModelBinding { /** * Create an ModelBinding from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclRule} aclRule - the AclRule for this ModelBinding * @param {Object} ast - the AST created by the parser * @param {Object} variableAst - the variable binding AST created by the parser * @throws {IllegalModelException} */ constructor(aclRule, ast, variableAst) { if(!aclRule || !ast) { throw new IllegalModelException('Invalid AclRule or AST'); } this.ast = ast; this.aclRule = aclRule; if(variableAst) { this.variableAst = variableAst; } else { this.variableAst = null; } this.classDeclaration = null; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclRule that owns this ModelBinding. * * @return {AclRule} the owning AclRule */ getAclRule() { return this.aclRule; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.qualifiedName = this.ast.qualifiedName; this.instanceId = null; if(this.ast.instanceId) { this.instanceId = this.ast.instanceId; } this.variableName = null; if(this.variableAst) { this.variableName = this.variableAst.name; } } /** * Returns strind representation of this object * * @return {string} the string version of the object */ toString() { let result = 'ModelBinding ' + this.qualifiedName; if(this.instanceId) { result += '#' + this.instanceId; } if(this.variableName) { result += ':' + this.variableName; } return result; } /** * Returns the fully qualified name of the model element for this ModelBinding. * * @return {string} the fully qualified model name */ getFullyQualifiedName() { return this.qualifiedName; } /** * Returns the identifier of the instance of the model element for this ModelBinding. * * @return {string} the identifier of the instance, or null */ getInstanceIdentifier() { return this.instanceId; } /** * Returns the name of the variable of the model element for this ModelBinding. * * @return {string} the name of the variable, or null */ getVariableName() { return this.variableName; } /** * Semantic validation of the structure of this ModelBinding. * * @throws {IllegalModelException} * @private */ validate() { const mm = this.getAclRule().getAclFile().getModelManager(); const ns = ModelUtil.getNamespace(this.qualifiedName); if (ModelUtil.isRecursiveWildcardName(this.qualifiedName)) { const namespaces = mm.getNamespaces(); if (namespaces.findIndex(function (element, index, array) { return (ns === element || element.startsWith(ns + '.')); })=== -1) { throw new IllegalModelException('Failed to find namespace ' + this.qualifiedName); } } else if (ModelUtil.isWildcardName(this.qualifiedName)) { const modelFile = mm.getModelFile(ns); if(!modelFile) { throw new IllegalModelException('Failed to find namespace ' + this.qualifiedName); } } else { const modelFile = mm.getModelFile(ns); if(!modelFile) { throw new IllegalModelException('Failed to find namespace ' + ns); } const className = ModelUtil.getShortName(this.qualifiedName); const classDeclaration = modelFile.getLocalType(className); if(!classDeclaration) { throw new IllegalModelException('Failed to find class ' + this.qualifiedName); } this.classDeclaration = classDeclaration; } } /** * Get the class declaration for the class that this instance is bound to. * @return {ClassDeclaration} The class declaration for the class that * this instance is bound to, or null if this instance is bound to a namespace. */ getClassDeclaration() { return this.classDeclaration; } } module.exports = ModelBinding; × Search results Close "},"composer-common_lib_introspect_modelfile.js.html":{"id":"composer-common_lib_introspect_modelfile.js.html","title":"Source: composer-common/lib/introspect/modelfile.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/modelfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const AssetDeclaration = require('./assetdeclaration'); const EnumDeclaration = require('./enumdeclaration'); const ConceptDeclaration = require('./conceptdeclaration'); const ParticipantDeclaration = require('./participantdeclaration'); const TransactionDeclaration = require('./transactiondeclaration'); const EventDeclaration = require('./eventdeclaration'); const IllegalModelException = require('./illegalmodelexception'); const ParseException = require('./parseexception'); const ModelUtil = require('../modelutil'); const Globalize = require('../globalize'); /** * Class representing a Model File. A Model File contains a single namespace * and a set of model elements: assets, transactions etc. * @private * @class * @memberof module:composer-common */ class ModelFile { /** * Create a ModelFile. This should only be called by framework code. * Use the ModelManager to manage ModelFiles. * * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile * @param {string} definitions - The DSL model as a string. * @param {string} fileName - The optional filename for this modelfile * @throws {IllegalModelException} */ constructor(modelManager, definitions, fileName) { this.modelManager = modelManager; this.declarations = []; this.imports = []; this.fileName = 'UNKNOWN'; if(!definitions || typeof definitions !== 'string') { throw new Error('ModelFile expects a Composer model as a string as input.'); } this.definitions = definitions; if(fileName &amp;&amp; typeof fileName !== 'string') { throw new Error('ModelFile expects an (optional) filename as a string.'); } this.fileName = fileName; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException(err.message, err.location); } else { throw err; } } this.namespace = this.ast.namespace; if(this.ast.imports) { this.imports = this.ast.imports; } // if we are not in the system namespace we add imports to all the system types if(!this.isSystemModelFile()) { const systemTypes = this.modelManager.getSystemTypes(); for(let n=0; n &lt; systemTypes.length; n++) { this.imports.unshift(systemTypes[n].getFullyQualifiedName()); } } for(let n=0; n &lt; this.ast.body.length; n++ ) { let thing = this.ast.body[n]; if(thing.type === 'AssetDeclaration') { this.declarations.push( new AssetDeclaration(this, thing) ); } else if(thing.type === 'TransactionDeclaration') { this.declarations.push( new TransactionDeclaration(this, thing) ); } else if(thing.type === 'EventDeclaration') { this.declarations.push( new EventDeclaration(this, thing) ); } else if(thing.type === 'ParticipantDeclaration') { this.declarations.push( new ParticipantDeclaration(this, thing) ); } else if(thing.type === 'EnumDeclaration') { this.declarations.push( new EnumDeclaration(this, thing) ); } else if(thing.type === 'ConceptDeclaration') { this.declarations.push( new ConceptDeclaration(this, thing) ); } else { let formatter = Globalize('en').messageFormatter('modelfile-constructor-unrecmodelelem'); throw new IllegalModelException(formatter({ 'type': thing.type, }),this.modelFile); } } } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this ModelFile * * @return {ModelManager} The ModelManager for this ModelFile */ getModelManager() { return this.modelManager; } /** * Returns the types that have been imported into this ModelFile. * * @return {string[]} The array of imports for this ModelFile */ getImports() { return this.imports; } /** * Validates the ModelFile. * * @throws {IllegalModelException} if the model is invalid * @private */ validate() { // Validate all of the imports to check that they reference // namespaces or types that actually exist. this.imports.forEach((importName) =&gt; { const importNamespace = ModelUtil.getNamespace(importName); const modelFile = this.getModelManager().getModelFile(importNamespace); if (!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-gettype-noregisteredns'); throw new IllegalModelException(formatter({ type: importName }), this); } if (ModelUtil.isWildcardName(importName)) { // This is a wildcard import, org.acme.* // Doesn't matter if 0 or 100 types in the namespace. return; } const importShortName = ModelUtil.getShortName(importName); if (!modelFile.isLocalType(importShortName)) { let formatter = Globalize.messageFormatter('modelmanager-gettype-notypeinns'); throw new IllegalModelException(formatter({ type: importShortName, namespace: importNamespace }), this); } }); // Validate all of the types in this model file. for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; classDeclaration.validate(); } } /** * Check that the type is valid. * @param {string} context - error reporting context * @param {string} type - a short type name * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context,type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { let formatter = Globalize('en').messageFormatter('modelfile-resolvetype-undecltype'); throw new IllegalModelException(formatter({ 'type': type, 'context': context }),this.modelFile); } } else { // check whether type is defined in another file this.getModelManager().resolveType(context,this.resolveImport(type)); } } } /** * Returns true if the type is defined in this namespace. * @param {string} type - the short name of the type * @return {boolean} - true if the type is defined in this ModelFile * @private */ isLocalType(type) { let result = (type !== null &amp;&amp; this.getLocalType(type) !== null); //console.log('isLocalType ' + this.getNamespace() + ' ' + type + '=' + result ); return result; } /** * Returns true if the type is imported from another namespace * @param {string} type - the short name of the type * @return {boolean} - true if the type is imported from another namespace * @private */ isImportedType(type) { //console.log('isImportedType ' + this.getNamespace() + ' ' + type ); for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return true; } else if (ModelUtil.isWildcardName(importName)) { const wildcardNamespace = ModelUtil.getNamespace(importName); const modelFile = this.getModelManager().getModelFile(wildcardNamespace); if (modelFile) { return modelFile.isLocalType(type); } } } return false; } /** * Returns the FQN for a type that is imported from another namespace * @param {string} type - the short name of the type * @return {string} - the FQN of the resolved import * @throws {Error} - if the type is not imported * @private */ resolveImport(type) { for(let n=0; n &lt; this.imports.length; n++) { let importName = this.imports[n]; if( ModelUtil.getShortName(importName) === type ) { return importName; } else if (ModelUtil.isWildcardName(importName)) { const wildcardNamespace = ModelUtil.getNamespace(importName); const modelFile = this.getModelManager().getModelFile(wildcardNamespace); if (modelFile &amp;&amp; modelFile.isLocalType(type)) { return wildcardNamespace + '.' + type; } } } let formatter = Globalize('en').messageFormatter('modelfile-resolveimport-failfindimp'); throw new IllegalModelException(formatter({ 'type': type, 'imports': this.imports, 'namespace': this.getNamespace() }),this.modelFile); } /** * Returns true if the type is defined in the model file * @param {string} type the name of the type * @return {boolean} true if the type (asset or transaction) is defined */ isDefined(type) { return ModelUtil.isPrimitiveType(type) || this.getLocalType(type) !== null; } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the type name is returned. * @param {string} type - a FQN or short type name * @return {string | ClassDeclaration} the class declaration for the type or null. * @private */ getType(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); if (!modelFile) { return null; } else { return modelFile.getLocalType(fqn); } } } else { // for primitive types we just return the name return type; } } /** * Returns the FQN of the type or null if the type could not be resolved. * For primitive types the short type name is returned. * @param {string} type - a FQN or short type name * @return {string} the FQN type name or null * @private */ getFullyQualifiedTypeName(type) { // is the type a primitive? if(!ModelUtil.isPrimitiveType(type)) { // is it an imported type? if(!this.isImportedType(type)) { // is the type declared locally? if(!this.isLocalType(type)) { return null; } else { return this.getLocalType(type).getFullyQualifiedName(); } } else { // check whether type is defined in another file const fqn = this.resolveImport(type); const modelFile = this.getModelManager().getModelFile(ModelUtil.getNamespace(fqn)); return modelFile.getLocalType(fqn).getFullyQualifiedName(); } } else { // for primitive types we just return the name return type; } } /** * Returns the type with the specified name or null * @param {string} type the short OR FQN name of the type * @return {ClassDeclaration} the ClassDeclaration, or null if the type does not exist */ getLocalType(type) { if(!type.startsWith(this.getNamespace())) { type = this.getNamespace() + '.' + type; } for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(type === this.getNamespace() + '.' + classDeclaration.getName() ) { return classDeclaration; } } return null; } /** * Get the AssetDeclarations defined in this ModelFile or null * @param {string} name the name of the type * @return {AssetDeclaration} the AssetDeclaration with the given short name */ getAssetDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof AssetDeclaration) { return classDeclaration; } return null; } /** * Get the TransactionDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {TransactionDeclaration} the TransactionDeclaration with the given short name */ getTransactionDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof TransactionDeclaration) { return classDeclaration; } return null; } /** * Get the EventDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {EventDeclaration} the EventDeclaration with the given short name */ getEventDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof EventDeclaration) { return classDeclaration; } return null; } /** * Get the ParticipantDeclaration defined in this ModelFile or null * @param {string} name the name of the type * @return {ParticipantDeclaration} the ParticipantDeclaration with the given short name */ getParticipantDeclaration(name) { let classDeclaration = this.getLocalType(name); if(classDeclaration instanceof ParticipantDeclaration) { return classDeclaration; } return null; } /** * Get the Namespace for this model file. * @return {string} The Namespace for this model file */ getNamespace() { return this.namespace; } /** * Get the filename for this model file. Note that this may be null. * @return {string} The filename for this model file */ getName() { return this.fileName; } /** * Get the AssetDeclarations defined in this ModelFile * @return {AssetDeclaration[]} the AssetDeclarations defined in the model file */ getAssetDeclarations() { return this.getDeclarations(AssetDeclaration); } /** * Get the TransactionDeclarations defined in this ModelFile * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model file */ getTransactionDeclarations() { return this.getDeclarations(TransactionDeclaration); } /** * Get the EventDeclarations defined in this ModelFile * @return {EventDeclaration[]} the EventDeclarations defined in the model file */ getEventDeclarations() { return this.getDeclarations(EventDeclaration); } /** * Get the ParticipantDeclarations defined in this ModelFile * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model file */ getParticipantDeclarations() { return this.getDeclarations(ParticipantDeclaration); } /** * Get the ConceptDeclarations defined in this ModelFile * @return {ConceptDeclaration[]} the ParticipantDeclaration defined in the model file */ getConceptDeclarations() { return this.getDeclarations(ConceptDeclaration); } /** * Get the EnumDeclarations defined in this ModelFile * @return {EnumDeclaration[]} the EnumDeclaration defined in the model file */ getEnumDeclarations() { return this.getDeclarations(EnumDeclaration); } /** * Get the instances of a given type in this ModelFile * @param {Function} type - the type of the declaration * @return {ClassDeclaration[]} the ClassDeclaration defined in the model file */ getDeclarations(type) { let result = []; for(let n=0; n &lt; this.declarations.length; n++) { let classDeclaration = this.declarations[n]; if(classDeclaration instanceof type) { result.push(classDeclaration); } } return result; } /** * Get all declarations in this ModelFile * @return {ClassDeclaration[]} the ClassDeclarations defined in the model file */ getAllDeclarations() { return this.declarations; } /** * Get the definitions for this model. * @return {string} The definitions for this model. */ getDefinitions() { return this.definitions; } /** * Returns true if this ModelFile is a system model * @return {boolean} true of this ModelFile is a system model */ isSystemModelFile() { return ModelUtil.getSystemNamespace() === this.getNamespace(); } } module.exports = ModelFile; × Search results Close "},"composer-common_lib_modelmanager.js.html":{"id":"composer-common_lib_modelmanager.js.html","title":"Source: composer-common/lib/modelmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/modelmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const IllegalModelException = require('./introspect/illegalmodelexception'); const ModelUtil = require('./modelutil'); const ModelFile = require('./introspect/modelfile'); const TypeNotFoundException = require('./typenotfoundexception'); // const ENCODING = 'utf8'; const LOG = require('./log/logger').getLog('ModelManager'); const SYSTEM_MODEL_CONTENTS = ` namespace org.hyperledger.composer.system abstract asset Asset { } abstract participant Participant { } abstract transaction Transaction identified by transactionId{ o String transactionId o DateTime timestamp } abstract event Event identified by eventId{ o String eventId o DateTime timestamp } `; /** * &lt;p&gt; * The structure of {@link Resource}s (Assets, Transactions, Participants) is modelled * in a set of Composer files. The contents of these files are managed * by the {@link ModelManager}. Each Composer file has a single namespace and contains * a set of asset, transaction and participant type definitions. * &lt;/p&gt; * &lt;p&gt; * Composer applications load their Composer files and then call the {@link ModelManager#addModelFile addModelFile} * method to register the Composer file(s) with the ModelManager. The ModelManager * parses the text of the Composer file and will make all defined types available * to other Composer services, such as the {@link Serializer} (to convert instances to/from JSON) * and {@link Factory} (to create instances). * &lt;/p&gt; * &lt;p&gt;&lt;a href=&quot;./diagrams-private/modelmanager.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/modelmanager.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ModelManager { /** * Create the ModelManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Composer}&lt;/strong&gt; * &lt;/p&gt; */ constructor() { LOG.entry('constructor'); this.modelFiles = {}; this.addSystemModels(); LOG.exit('constructor'); } /** * Add the system models to the model manager * @private */ addSystemModels() { LOG.entry('addSystemModels'); // add the system model LOG.info('info', SYSTEM_MODEL_CONTENTS); let m = new ModelFile(this, SYSTEM_MODEL_CONTENTS); m.validate(); this.modelFiles[m.getNamespace()] = m; LOG.exit('addSystemModels'); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor, parameters) { return visitor.visit(this, parameters); } /** * Validates a Composer file (as a string) to the ModelManager. * Composer files have a single namespace. * * Note that if there are dependencies between multiple files the files * must be added in dependency order, or the addModelFiles method can be * used to add a set of files irrespective of dependencies. * @param {string} modelFile - The Composer file as a string * @param {string} fileName - an optional file name to associate with the model file * @throws {IllegalModelException} */ validateModelFile(modelFile, fileName) { if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile, fileName); m.validate(); } else { modelFile.validate(); } } /** * Adds a Composer file (as a string) to the ModelManager. * Composer files have a single namespace. If a Composer file with the * same namespace has already been added to the ModelManager then it * will be replaced. * Note that if there are dependencies between multiple files the files * must be added in dependency order, or the addModelFiles method can be * used to add a set of files irrespective of dependencies. * @param {string} modelFile - The Composer file as a string * @param {string} fileName - an optional file name to associate with the model file * @throws {IllegalModelException} * @return {Object} The newly added model file (internal). */ addModelFile(modelFile, fileName) { const NAME = 'addModelFile'; LOG.info(NAME,'addModelFile',modelFile,fileName); let m = null; if (typeof modelFile === 'string') { m = new ModelFile(this, modelFile, fileName); } else { m = modelFile; } if(m.isSystemModelFile()) { throw new Error('Cannot add a model file with the reserved system namspace: ' + m.getNamespace() ); } m.validate(); this.modelFiles[m.getNamespace()] = m; return m; } /** * Updates a Composer file (as a string) on the ModelManager. * Composer files have a single namespace. If a Composer file with the * same namespace has already been added to the ModelManager then it * will be replaced. * @param {string} modelFile - The Composer file as a string * @param {string} fileName - an optional file name to associate with the model file * @throws {IllegalModelException} * @returns {Object} The newly added model file (internal). */ updateModelFile(modelFile, fileName) { const NAME = 'updateModelFile'; LOG.info(NAME,'updateModelFile',modelFile,fileName); if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile, fileName); if (m.isSystemModelFile()){ throw new Error('System namespace can not be updated'); } if (!this.modelFiles[m.getNamespace()]) { throw new Error('model file does not exist'); } m.validate(); this.modelFiles[m.getNamespace()] = m; return m; } else { if (modelFile.isSystemModelFile()){ throw new Error('System namespace can not be updated'); } if (!this.modelFiles[modelFile.getNamespace()]) { throw new Error('model file does not exist'); } modelFile.validate(); this.modelFiles[modelFile.getNamespace()] = modelFile; return modelFile; } } /** * Remove the Composer file for a given namespace * @param {string} namespace - The namespace of the model file to * delete. */ deleteModelFile(namespace) { if (!this.modelFiles[namespace]) { throw new Error('model file does not exist'); } else if (namespace === ModelUtil.getSystemNamespace()) { throw new Error('Cannot delete system namespace'); } delete this.modelFiles[namespace]; } /** * Add a set of Composer files to the model manager. * @param {string[]} modelFiles - An array of Composer files as * strings. * @param {string[]} fileNames - An optional array of file names to * associate with the model files * @returns {Object[]} The newly added model files (internal). */ addModelFiles(modelFiles, fileNames) { const NAME = 'addModelFiles'; LOG.entry(NAME,'addModelFiles',modelFiles,fileNames); const originalModelFiles = {}; Object.assign(originalModelFiles, this.modelFiles); let newModelFiles = []; try { // create the model files for (let n = 0; n &lt; modelFiles.length; n++) { const modelFile = modelFiles[n]; let fileName = null; if (fileNames) { fileName = fileNames[n]; } if (typeof modelFile === 'string') { let m = new ModelFile(this, modelFile, fileName); if (m.isSystemModelFile()){ throw new Error('System namespace can not be updated'); } this.modelFiles[m.getNamespace()] = m; newModelFiles.push(m); } else { if (modelFile.isSystemModelFile()){ throw new Error('System namespace can not be updated'); } this.modelFiles[modelFile.getNamespace()] = modelFile; newModelFiles.push(modelFile); } } // re-validate all the model files for (let ns in this.modelFiles) { this.modelFiles[ns].validate(); } // return the model files. return newModelFiles; } catch (err) { this.modelFiles = {}; Object.assign(this.modelFiles, originalModelFiles); throw err; } finally{ LOG.exit(NAME,newModelFiles); } } /** * Get the array of model file instances * Note - this is an internal method and therefore will return the system model * as well as any network defined models. * * It is the callers responsibility to remove this before the data leaves an external API * * @return {ModelFile[]} The ModelFiles registered * @private */ getModelFiles() { let keys = Object.keys(this.modelFiles); let result = []; for (let n = 0; n &lt; keys.length; n++) { result.push(this.modelFiles[keys[n]]); } return result; } /** * Check that the type is valid and returns the FQN of the type. * @param {string} context - error reporting context * @param {string} type - fully qualified type name * @return {string} - the resolved type name (fully qualified) * @throws {IllegalModelException} - if the type is not defined * @private */ resolveType(context, type) { // is the type a primitive? if (ModelUtil.isPrimitiveType(type)) { return type; } let ns = ModelUtil.getNamespace(type); let modelFile = this.getModelFile(ns); if (!modelFile) { let formatter = Globalize.messageFormatter('modelmanager-resolvetype-nonsfortype'); throw new IllegalModelException(formatter({ type: type, context: context })); } if (modelFile.isLocalType(type)) { return type; } let formatter = Globalize.messageFormatter('modelmanager-resolvetype-notypeinnsforcontext'); throw new IllegalModelException(formatter({ context: context, type: type, namespace: modelFile.getNamespace() })); } /** * Remove all registered Composer files */ clearModelFiles() { this.modelFiles = {}; this.addSystemModels(); } /** * Get the ModelFile associated with a namespace * Note - this is an internal method and therefore will return the system model * as well as any network defined models. * * It is the callers responsibility to remove this before the data leaves an external API * @param {string} namespace - the namespace containing the ModelFile * @return {ModelFile} registered ModelFile for the namespace or null * @private */ getModelFile(namespace) { return this.modelFiles[namespace]; } /** * Get the namespaces registered with the ModelManager. * @return {string[]} namespaces - the namespaces that have been registered. */ getNamespaces() { return Object.keys(this.modelFiles); } /** * Look up a type in all registered namespaces. * * @param {string} qualifiedName - fully qualified type name. * @return {ClassDeclaration} - the class declaration for the specified type. * @throws {TypeNotFoundException} - if the type cannot be found or is a primitive type. * @private */ getType(qualifiedName) { const namespace = ModelUtil.getNamespace(qualifiedName); const modelFile = this.getModelFile(namespace); if (!modelFile) { const formatter = Globalize.messageFormatter('modelmanager-gettype-noregisteredns'); throw new TypeNotFoundException(qualifiedName, formatter({ type: qualifiedName })); } const classDecl = modelFile.getType(qualifiedName); if (!classDecl) { const formatter = Globalize.messageFormatter('modelmanager-gettype-notypeinns'); throw new TypeNotFoundException(qualifiedName, formatter({ type: ModelUtil.getShortName(qualifiedName), namespace: namespace })); } return classDecl; } /** * Get all class declarations from system namespaces * @return {ClassDeclaration[]} the ClassDeclarations from system namespaces */ getSystemTypes() { return this.getModelFile(ModelUtil.getSystemNamespace()).getAllDeclarations(); } /** * Get the AssetDeclarations defined in this model manager * @return {AssetDeclaration[]} the AssetDeclarations defined in the model manager */ getAssetDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getAssetDeclarations()); }, []); } /** * Get the TransactionDeclarations defined in this model manager * @return {TransactionDeclaration[]} the TransactionDeclarations defined in the model manager */ getTransactionDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getTransactionDeclarations()); }, []); } /** * Get the EventDeclarations defined in this model manager * @return {EventDeclaration[]} the EventDeclaration defined in the model manager */ getEventDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getEventDeclarations()); }, []); } /** * Get the ParticipantDeclarations defined in this model manager * @return {ParticipantDeclaration[]} the ParticipantDeclaration defined in the model manager */ getParticipantDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getParticipantDeclarations()); }, []); } /** * Get the EnumDeclarations defined in this model manager * @return {EnumDeclaration[]} the EnumDeclaration defined in the model manager */ getEnumDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getEnumDeclarations()); }, []); } /** * Get the Concepts defined in this model manager * @return {ConceptDeclaration[]} the ConceptDeclaration defined in the model manager */ getConceptDeclarations() { return this.getModelFiles().reduce((prev, cur) =&gt; { return prev.concat(cur.getConceptDeclarations()); }, []); } } module.exports = ModelManager; × Search results Close "},"composer-common_lib_modelutil.js.html":{"id":"composer-common_lib_modelutil.js.html","title":"Source: composer-common/lib/modelutil.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/modelutil.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const COMPOSER_SYSTEM_NAMESPACE = 'org.hyperledger.composer.system'; /** * Internal Model Utility Class * &lt;p&gt;&lt;a href=&quot;./diagrams-private/modelutil.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/modelutil.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ModelUtil { /** * Returns everything after the last dot, if present, of the source string * @param {string} fqn - the source string * @return {string} - the string after the last dot * @private */ static getShortName(fqn) { //console.log('toShortName ' + name ); let result = fqn; let dotIndex = fqn.lastIndexOf('.'); if (dotIndex &gt; -1) { result = fqn.substr(dotIndex + 1); } //console.log('result ' + result ); return result; } /** * Returns true if the specified name is a wildcard * @param {string} fqn - the source string * @return {boolean} true if the specified name is a wildcard * @private */ static isWildcardName(fqn) { return ModelUtil.getShortName(fqn) === '*'; } /** * Returns true if the specified name is a recusive wildcard * @param {string} fqn - the source string * @return {boolean} true if the specified name is a recusive wildcard * @private */ static isRecursiveWildcardName(fqn) { return ModelUtil.getShortName(fqn) === '**'; } /** * Returns true if a type matches the required fully qualified name. The required * name may be a wildcard or recursive wildcard * @param {Typed} type - the type to test * @param {string} fqn - required fully qualified name * @return {boolean} true if the specified type and namespace match * @private */ static isMatchingType(type, fqn) { let ns = ModelUtil.getNamespace(fqn); let typeNS = type.getNamespace(); if (type.instanceOf(fqn)) { // matching type or subtype } else if (ModelUtil.isWildcardName(fqn) &amp;&amp; typeNS === ns) { // matching namespace } else if (ModelUtil.isRecursiveWildcardName(fqn) &amp;&amp; (typeNS + '.').startsWith(ns + '.')) { // matching recursive namespace } else { // does not match return false; } return true; } /** * Returns the namespace for a the fully qualified name of a type * @param {string} fqn - the fully qualified identifier of a type * @return {string} - namespace of the type (everything before the last dot) * or the empty string if there is no dot * @private */ static getNamespace(fqn) { if (!fqn) { throw new Error(Globalize.formatMessage('modelutil-getnamespace-nofnq')); } let result = ''; let dotIndex = fqn.lastIndexOf('.'); if (dotIndex &gt; -1) { result = fqn.substr(0, dotIndex); } return result; } /** * Returns the system namespace * @return {string} - namespace of system types * @private */ static getSystemNamespace() { return COMPOSER_SYSTEM_NAMESPACE; } /** * Returns true if the type is a primitive type * @param {string} typeName - the name of the type * @return {boolean} - true if the type is a primitive * @private */ static isPrimitiveType(typeName) { const primitiveTypes = ['Boolean', 'String', 'DateTime', 'Double', 'Integer', 'Long']; return (primitiveTypes.indexOf(typeName) &gt;= 0); } /** * Returns true if the type is assignable to the propertyType. * * @param {ModelFile} modelFile - the ModelFile that owns the Property * @param {string} typeName - the FQN of the type we are trying to assign * @param {Property} property - the property that we'd like to store the * type in. * @return {boolean} - true if the type can be assigned to the property * @private */ static isAssignableTo(modelFile, typeName, property) { const propertyTypeName = property.getFullyQualifiedTypeName(); const isDirectMatch = (typeName === propertyTypeName); if (isDirectMatch || ModelUtil.isPrimitiveType(typeName) || ModelUtil.isPrimitiveType(propertyTypeName)) { return isDirectMatch; } const typeDeclaration = modelFile.getType(typeName); if (!typeDeclaration) { throw new Error('Cannot find type ' + typeName); } return typeDeclaration.getAllSuperTypeDeclarations(). some(type =&gt; type.getFullyQualifiedName() === propertyTypeName); } /** * Returns the passed string with the first character capitalized * @param {string} string - the string * @return {string} the string with the first letter capitalized * @private */ static capitalizeFirstLetter(string) { return string.charAt(0).toUpperCase() + string.slice(1); } /** * Returns the true if the given field is an enumerated type * @param {Field} field - the string * @return {boolean} true if the field is declared as an enumeration * @private */ static isEnum(field) { const modelFile = field.getParent().getModelFile(); const typeDeclaration = modelFile.getType(field.getType()); return (typeDeclaration !== null &amp;&amp; typeDeclaration.isEnum()); } /** * Get the fully qualified name of a type. * @param {string} namespace - namespace of the type. * @param {string} type - short name of the type. * @returns {string} the fully qualified type name. */ static getFullyQualifiedName(namespace, type) { if (namespace) { return namespace + '.' + type; } else { return type; } } } module.exports = ModelUtil; × Search results Close "},"composer-common_lib_log_node.js.html":{"id":"composer-common_lib_log_node.js.html","title":"Source: composer-common/lib/log/node.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/node.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** @description Internal class for handling a simple directed tree to support filtering * @private * @class * @memberof module:composer-common */ class Node { /** @description creates a new node * @TODO replace the include with a filter level * * @param {String} name name of the node i.e. package &amp; class * @param {boolean} include should this included in the trace * * @private */ constructor(name,include){ this.name=name; this.include =include; this.children=[]; } /** * @description adds a new node as a child of this at the start of the listTitles * @param {Node} node Child node to add * * @private */ addChildNodeAtStart(node){ this.children.push(node); } /** * @description what is the name of this node? * @return {String} name as set on constructor * * @private */ getName(){ return this.name; } /** * @description is this node included in the set trace settings * @return {boolean} included true or false * * @private */ isIncluded(){ return this.include; } /** * @description Set the node to be an inclusion */ setIncluded(){ this.include = true; } /** Find the node in the children that matches the array * * @param {String} nameToFind which node to try and locate in the children * @return {node} Node that matches - * * @private */ findChild(nameToFind){ // do an array search of the children and match the nameToFind return this.children.find(function(element){ return element.getName()===this; },nameToFind); } } module.exports = Node; × Search results Close "},"composer-common_lib_query_orderby.js.html":{"id":"composer-common_lib_query_orderby.js.html","title":"Source: composer-common/lib/query/orderby.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/orderby.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const Sort = require('./sort'); /** * Defines the ORDER BY specification for a SELECT statement * * @private * @class * @memberof module:composer-common */ class OrderBy { /** * Create an OrderBy from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this order by * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new IllegalModelException('Invalid Select or AST'); } this.ast = ast; this.select = select; this.sortCriteria = []; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this OrderBy. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { if(this.ast.sort) { for(let n=0; n &lt; this.ast.sort.length; n++) { this.sortCriteria.push( new Sort(this, this.ast.sort[n])); } } } /** * Semantic validation of the structure of this select. * * @throws {IllegalModelException} * @private */ validate() { // TODO (DCS) check that the fields we are sorting by exist! } /** * Return the sort criteria of this order by. * @return {Sort[]} The sort criteria of this order by. */ getSortCriteria() { return this.sortCriteria; } } module.exports = OrderBy; × Search results Close "},"composer-common_lib_introspect_parseexception.js.html":{"id":"composer-common_lib_introspect_parseexception.js.html","title":"Source: composer-common/lib/introspect/parseexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/parseexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseModelException = require('./basemodelexception'); /** * Exception throws when a Composer file is syntactically invalid * @extends BaseModelException * @see See [BaseModelException]{@link module:composer-common.BaseModelException} * @class * @memberof module:composer-common */ class ParseException extends BaseModelException { /** * Create an ParseException * @param {string} message - the message for the exception * @param {string} fileLocation - the optional file location associated with the exception */ constructor(message, fileLocation) { let fullMessage = message + ' Line ' + fileLocation.start.line + ' column ' + fileLocation.start.column; // The parser does not give us back the end location of an invalid token. // Making the end column equal to the end column makes use of // vscodes default behaviour of selecting an entire word if (fileLocation) { if (fileLocation.end &amp;&amp; fileLocation.start) { if (fileLocation.end.offset &amp;&amp; fileLocation.start.offset) { if (fileLocation.end.offset - fileLocation.start.offset === 1) { fileLocation.end.column = fileLocation.start.column; fileLocation.end.offset = fileLocation.start.offset; } } } } super(message, fileLocation, fullMessage); } } module.exports = ParseException; × Search results Close "},"composer-common_lib_introspect_participantdeclaration.js.html":{"id":"composer-common_lib_introspect_participantdeclaration.js.html","title":"Source: composer-common/lib/introspect/participantdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/participantdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); /** Class representing the definition of a Participant. * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @private * @class * @memberof module:composer-common */ class ParticipantDeclaration extends ClassDeclaration { /** * Create an ParticipantDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns true if this class can be pointed to by a relationship * * @return {boolean} true if the class may be pointed to by a relationship */ isRelationshipTarget() { return true; } /** * Returns the base system type for Participants from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Participant'; } /** * Semantic validation of the structure of this participant. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Participant') { throw new IllegalModelException('Participant is a reserved type name.', this.modelFile, this.ast.location); } } } module.exports = ParticipantDeclaration; × Search results Close "},"composer-common_lib_codegen_fromjs_plantumlgenerator.js.html":{"id":"composer-common_lib_codegen_fromjs_plantumlgenerator.js.html","title":"Source: composer-common/lib/codegen/fromjs/plantumlgenerator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/fromjs/plantumlgenerator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const fs = require('fs'); const path = require('path'); const FileWriter = require('../filewriter'); /** * Converts the includes, classes and methods in a Javascript * file into a PlantUML format file. * @private * @class * @memberof module:composer-common */ class PlantUMLGenerator { /** * @param {Object} program - the program arguments * @param {Object} file - the file instance being processed * @param {Object[]} includes - the includes (require statements) within the file * @param {Object[]} classes - the classes within the file * @param {Object[]} functions - the functions within the file */ generate(program, file, includes, classes, functions) { // generate the output if(classes.length &gt; 0 || functions.length &gt; 0) { let fileWriter = new FileWriter(program.outputDir); const umlFilename = toUMLFilename(program.inputDir, program.outputDir, file); console.log('open file: ' + umlFilename); fileWriter.openFile(umlFilename); fileWriter.writeLine(0, '@startuml'); console.log('+'); fileWriter.writeLine(0, '!include '+ program.outputDir + '/../../jsdoc-template/umlstyle.uml'); for(let n=0; n &lt; includes.length; n++) { // only include files that exist // the file may not exist if it was empty const includeFile = program.outputDir + '/' + includes[n] + '.uml'; if (fs.existsSync(includeFile)) { fileWriter.writeLine(0, '!include ' + includeFile); } } for(let n=0; n &lt; classes.length; n++) { const clazz = classes[n]; fileWriter.writeLine(0, 'class ' + clazz.name + '{'); for(let i=0; i &lt; clazz.methods.length; i++) { const method = clazz.methods[i]; fileWriter.writeLine(1, method.visibility + ' ' + method.returnType + ' ' + method.name + paramsToString(method.methodArgs) ); } fileWriter.writeLine(0, '}'); if(clazz.superClass) { const filePath = path.parse(file); fileWriter.writeBeforeLine(0, '!include ' + filePath.dir + '/' + clazz.superClass.toLowerCase() + '.uml'); fileWriter.writeLine(0, clazz.name + ' --|&gt; ' + clazz.superClass); } } fileWriter.writeLine(0, '@enduml'); fileWriter.closeFile(); } } } /** * Converts an array of parameter types to a string * @param {string[]} paramTypes array of parameter type names * @return {string} - string representation * @private */ function paramsToString(paramTypes) { let result = '('; for(let n=0; n &lt; paramTypes.length; n++) { result += paramTypes[n]; if(n &lt; paramTypes.length-1) { result += ','; } } result += ')'; return result; } /** * @param {string} inputDir - the fully qualified input directory * @param {string} outputDir - the fully qualified output directory * @param {string} filename - the fully qualified input file name (.js) * @return {string} the UML file name to use * @private */ function toUMLFilename(inputDir, outputDir, filename) { console.log('inputDir' + inputDir); console.log('outputDir' + outputDir); console.log('filename' + filename); let index = filename.indexOf(inputDir); console.log('index ' + index); let rest = filename.substr(index + 1 + inputDir.length); // let out = outputDir + '/' + rest; let i = rest.lastIndexOf('.'); // console.log('result' + out.substr(0, i) + '.uml' ); return (i &lt; 0) ? '' : rest.substr(0, i) + '.uml'; } module.exports = PlantUMLGenerator; × Search results Close "},"composer-common_lib_acl_predicate.js.html":{"id":"composer-common_lib_acl_predicate.js.html","title":"Source: composer-common/lib/acl/predicate.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/acl/predicate.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Predicate captures a conditional Javascript expression: * anything that can legally appear within a if statement. * * @private * @class * @memberof module:composer-common */ class Predicate { /** * Create an Predicate from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {AclRule} aclRule - the AclRule for this Predicate * @param {Object} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(aclRule, ast) { if(!aclRule || !ast) { throw new IllegalModelException('Invalid AclRule or AST'); } this.expression = ast; this.aclRule = aclRule; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the AclRule that owns this ModelBinding. * * @return {AclRule} the owning AclRule */ getAclRule() { return this.aclRule; } /** * Returns the expression as a text string. * * @return {string} the operator for the predicate */ getExpression() { return this.expression; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this ModelBinding. * * @throws {IllegalModelException} * @private */ validate() { } } module.exports = Predicate; × Search results Close "},"composer-common_lib_introspect_property.js.html":{"id":"composer-common_lib_introspect_property.js.html","title":"Source: composer-common/lib/introspect/property.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/property.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ModelUtil = require('../modelutil'); /** * Property representing an attribute of a class declaration, * either a Field or a Relationship. * @private * @class * @memberof module:composer-common */ class Property { /** * Create a Property. * @param {ClassDeclaration} parent - the owner of this property * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(parent, ast) { this.ast = ast; this.parent = parent; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the owner of this property * @return {ClassDeclaration} the parent class declaration */ getParent() { return this.parent; } /** * Process the AST and build the model * @throws {IllegalModelException} * @private */ process() { this.name = this.ast.id.name; if(!this.name) { throw new Error('No name for type ' + this.ast ); } if(this.ast.propertyType) { this.type = this.ast.propertyType.name; } else { this.type = null; } this.array = false; if(this.ast.array) { this.array = true; } if(this.ast.optional) { this.optional = true; } else { this.optional = false; } } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {IllegalModelException} * @private */ validate(classDecl) { if(this.type) { classDecl.getModelFile().resolveType( 'property ' + this.getFullyQualifiedName(), this.type); } } /** * Returns the name of a property * @return {string} the name of this field */ getName() { return this.name; } /** * Returns the type of a property * @return {string} the type of this field */ getType() { return this.type; } /** * Returns true if the field is optional * @return {boolean} true if the field is optional */ isOptional() { return this.optional; } /** * Returns the fully qualified type name of a property * @return {string} the fully qualified type of this property */ getFullyQualifiedTypeName() { if(this.isPrimitive()) { return this.type; } const parent = this.getParent(); if(!parent) { throw new Error('Property ' + this.name + ' does not have a parent.'); } const modelFile = parent.getModelFile(); if(!modelFile) { throw new Error('Parent of property ' + this.name + ' does not have a ModelFile!'); } const result = modelFile.getFullyQualifiedTypeName(this.type); if(!result) { throw new Error('Failed to find fully qualified type name for property ' + this.name + ' with type ' + this.type ); } return result; } /** * Returns the fully name of a property (ns + class name + property name) * @return {string} the fully qualified name of this property */ getFullyQualifiedName() { return this.getNamespace() + '.' + this.getParent().getName() + '.' + this.getName(); } /** * Returns the namespace of the parent of this property * @return {string} the namespace of the parent of this property */ getNamespace() { return this.getParent().getModelFile().getNamespace(); } /** * Returns true if the field is declared as an array type * @return {boolean} true if the property is an array type */ isArray() { return this.array; } /** * Returns true if the field is declared as an enumerated value * @return {boolean} true if the property is an enumerated value */ isTypeEnum() { if(this.isPrimitive()) { return false; } else { const type = this.getParent().getModelFile().getType(this.getType()); return type.isEnum(); } } /** * Returns true if this property is a primitive type. *@return {boolean} true if the property is a primitive type. */ isPrimitive() { return ModelUtil.isPrimitiveType(this.getType()); } } module.exports = Property; × Search results Close "},"composer-common_lib_query_query.js.html":{"id":"composer-common_lib_query_query.js.html","title":"Source: composer-common/lib/query/query.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/query.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const ParseException = require('../introspect/parseexception'); const parser = require('./parser'); const Select = require('./select'); /** * Query defines a SELECT query over a resource (asset, transaction or participant) * * @private * @class * @memberof module:composer-common */ class Query { /** * Create a query programmatically without supplying an AST. * @param {QueryFile} queryFile The owning query file. * @param {string} name The name of the query. * @param {string} description A description of the query. * @param {string} select The select statement. * @return {Query} The created query. */ static buildQuery(queryFile, name, description, select) { let selectAst; try { // We must tell the PEG.js parser to use an alternate start rule, // so that we can parse just the statement rather than the full query. selectAst = parser.parse(select, { startRule: 'SelectStatement' }); } catch (err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException( err.message + ' Line ' + err.location.start.line + ' column ' + err.location.start.column, err.location ); } else { throw err; } } const ast = { identifier: { name: name }, description: description, select: selectAst }; return new Query(queryFile, ast); } /** * Create an Query from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {QueryFile} queryFile - the QueryFile for this query * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(queryFile, ast) { if(!queryFile || !ast) { throw new IllegalModelException('Invalid QueryFile or AST'); } this.ast = ast; this.queryFile = queryFile; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the QueryFile that owns this Query. * * @return {AclFile} the owning QueryFile */ getQueryFile() { return this.queryFile; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.name = this.ast.identifier.name; this.description = this.ast.description; this.select = new Select(this, this.ast.select); } /** * Semantic validation of the structure of this Query. * * @throws {IllegalModelException} * @private */ validate() { this.select.validate(); } /** * Returns the name of this Query. * * @return {string} the name of the Query */ getName() { return this.name; } /** * Returns the description associated with this Query. * * @return {string} the description */ getDescription() { return this.description; } /** * Returns the select statement associated with this Query. * @return {Select} The select statement. */ getSelect() { return this.select; } } module.exports = Query; × Search results Close "},"composer-common_lib_query_queryfile.js.html":{"id":"composer-common_lib_query_queryfile.js.html","title":"Source: composer-common/lib/query/queryfile.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/queryfile.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const parser = require('./parser'); const Query = require('./query'); const ParseException = require('../introspect/parseexception'); /** * Class representing a Query File * @private * @class * @memberof module:composer-common */ class QueryFile { /** * Create an QueryFile. This should only be called by framework code. * @param {string} id - The identifier of this Query File (may be a filename for example) * @param {ModelManager} modelManager - the ModelManager that manages this * ModelFile and that will be used to validate the queries in the QueryFile * @param {string} definitions - The queries as a string. * @throws {IllegalModelException} */ constructor(id, modelManager, definitions) { this.modelManager = modelManager; this.queries = []; this.identifier = id; if(typeof definitions !== 'string') { throw new Error('QueryFile expects an QueryFile as a string as input.'); } this.definitions = definitions; try { this.ast = parser.parse(definitions); } catch(err) { if(err.location &amp;&amp; err.location.start) { throw new ParseException( err.message + ' Line ' + err.location.start.line + ' column ' + err.location.start.column, err.location ); } else { throw err; } } for(let n=0; n &lt; this.ast.queries.length; n++ ) { let thing = this.ast.queries[n]; this.queries.push(new Query(this, thing)); } } /** * Returns the identifier of this Query File. * @return {string} the identifier of this Query File */ getIdentifier() { return this.identifier; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the ModelManager associated with this QueryFile * * @return {ModelManager} The ModelManager for this QueryFile */ getModelManager() { return this.modelManager; } /** * Validates the QueryFile. * * @throws {IllegalModelException} if the query file is invalid * @private */ validate() { const queries = {}; this.queries.forEach((query) =&gt; { query.validate(); let name = query.getName(); if (queries[name]){ throw new Error(`Found two or more queries with the name '${name}'`); } queries[name] = query; }); } /** * Get all declarations in this Query file * @return {Query[]} the Queries defined in the Query file */ getQueries() { return this.queries; } /** * Get the definitions for this Query file. * @return {string} The definitions for this Query file. */ getDefinitions() { return this.definitions; } /** * Create a query programmatically without supplying an AST, * and add it into this query file. * @param {string} name The name of the query. * @param {string} description A description of the query. * @param {string} select The select statement. * @return {Query} The created query. */ buildQuery(name, description, select) { const query = Query.buildQuery(this, name, description, select); this.queries.push(query); return query; } } module.exports = QueryFile; × Search results Close "},"composer-common_lib_querymanager.js.html":{"id":"composer-common_lib_querymanager.js.html","title":"Source: composer-common/lib/querymanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/querymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const QueryFile = require('./query/queryfile'); /** * &lt;p&gt; * Manages a set of queries. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class QueryManager { /** * Create the QueryManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this QueryManager * @param {QueryFile} queryFile - The QueryFile that stores the queries */ constructor(modelManager) { this.modelManager = modelManager; this.queryFile = null; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Create an Query file using the specified ID and contents. * @param {string} identifier The identifier of the query file. * @param {string} contents The contents of the query file. * @return {QueryFile} The new Query file. */ createQueryFile(identifier, contents) { return new QueryFile(identifier, this.modelManager, contents); } /** * Set the QueryFile for this QueryManager * @param {QueryFile} queryFile - the QueryFile to associate with this QueryManager * @private */ setQueryFile(queryFile) { queryFile.validate(); this.queryFile = queryFile; } /** * Get the QueryFile associated with this QueryManager * @return {QueryFile} The QueryFile for this QueryManager or null if it has not been set */ getQueryFile() { return this.queryFile; } /** * Get the Queries associated with this QueryManager * @return {Query[]} The Quries for the QueryManager or an empty array if not set */ getQueries() { if(this.queryFile) { return this.queryFile.getQueries(); } return []; } } module.exports = QueryManager; × Search results Close "},"composer-common_lib_model_relationship.js.html":{"id":"composer-common_lib_model_relationship.js.html","title":"Source: composer-common/lib/model/relationship.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/relationship.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Identifiable = require('./identifiable'); const ModelUtils = require('../modelutil'); const Globalize = require('../globalize'); /** * A Relationship is a typed pointer to an instance. I.e the relationship * with namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates * a pointer that points at an instance of org.acme.Vehicle with the id * ABC. * @extends Identifiable * @see See [Identifiable]{@link module:composer-common.Identifiable} * @class * @memberof module:composer-common */ class Relationship extends Identifiable { /** * Create an asset. Use the Factory to create instances. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); // we use this metatag to identify the instance as a relationship this.$class = 'Relationship'; } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Relationship {id=' + this.getFullyQualifiedIdentifier() + '}'; } /** * Determine if this identifiable is a relationship. * @return {boolean} True if this identifiable is a relationship, * false if not. */ isRelationship() { return true; } /** * Contructs a Relationship instance from a URI representation (created using toURI). * @param {ModelManager} modelManager - the model manager to bind the relationship to * @param {String} uriAsString - the URI as a string, generated using Identifiable.toURI() * @param {String} defaultNamespace - default namespace to use for backwards compatability (optional) * @param {String} defaultType - default type to use for backwards compatability (optional) * @return {Relationship} the relationship */ static fromURI(modelManager, uriAsString, defaultNamespace, defaultType) { // parse the URI, we do it by hand because we know the format const indexOfColon = uriAsString.indexOf(':'); let protocol = null; let id = uriAsString; let type = null; let ns = null; let resource = null; // protocol if(indexOfColon &gt; 0) { protocol = uriAsString.substring(0, indexOfColon); uriAsString = uriAsString.substr(indexOfColon+1); } // id and resource const indexOfHash = uriAsString.indexOf('#'); if(indexOfHash &gt; 0) { id = uriAsString.substr(indexOfHash+1); resource = uriAsString.substring(0,indexOfHash); } // old style relationships do not have a schema if (protocol !== 'resource') { ns = defaultNamespace; type = defaultType; id = uriAsString; } else { ns = ModelUtils.getNamespace(resource); type = ModelUtils.getShortName(resource); } id = decodeURI(id); let modelFile = modelManager.getModelFile(ns); if(!modelFile) { let formatter = Globalize.messageFormatter('factory-newrelationship-notregisteredwithmm'); throw new Error(formatter({ namespace: ns })); } if(!modelFile.isDefined(type)) { let formatter = Globalize.messageFormatter('factory-newinstance-typenotdeclaredinns'); throw new Error(formatter({ namespace: ns, type: type })); } let relationship = new Relationship(modelManager,ns,type,id); return relationship; } } module.exports = Relationship; × Search results Close "},"composer-common_lib_introspect_relationshipdeclaration.js.html":{"id":"composer-common_lib_introspect_relationshipdeclaration.js.html","title":"Source: composer-common/lib/introspect/relationshipdeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/relationshipdeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Property = require('./property'); const IllegalModelException = require('./illegalmodelexception'); const ModelUtil = require('../modelutil'); /** * Class representing a relationship between model elements * @extends Property * @see See [Property]{@link module:composer-common.Property} * @private * @class * @memberof module:composer-common */ class RelationshipDeclaration extends Property { /** * Create a Relationship. * @param {ClassDeclaration} parent - The owner of this property * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(parent, ast) { super(parent, ast); } /** * Validate the property * @param {ClassDeclaration} classDecl the class declaration of the property * @throws {IllegalModelException} * @private */ validate(classDecl) { super.validate(classDecl); // relationship cannot point to primitive types if(!this.getType()) { throw new IllegalModelException('Relationship must have a type', classDecl.getModelFile(), this.ast.location); } let classDeclaration = null; // you can't have a relationship with a primitive... if(ModelUtil.isPrimitiveType(this.getType())) { throw new IllegalModelException('Relationship ' + this.getName() + ' cannot be to the primitive type ' + this.getType(), classDecl.getModelFile(), this.ast.location ); } else { let namespace = this.getParent().getModelFile().getNamespace(); // we first try to get the type from our own model file // because during validate we have not yet been added to the model manager if(namespace === ModelUtil.getNamespace(this.getFullyQualifiedTypeName())) { classDeclaration = this.getParent().getModelFile().getType(this.getType()); } else { // otherwise we have to use the modelmanager to try to load try { classDeclaration = this.getParent().getModelFile().getModelManager().getType(this.getFullyQualifiedTypeName()); } catch (err) { // Let classDeclaration remain null and get handled below } } if(classDeclaration === null) { throw new IllegalModelException('Relationship ' + this.getName() + ' points to a missing type ' + this.getFullyQualifiedTypeName(), classDecl.getModelFile(), this.ast.location); } if ((namespace === ModelUtil.getSystemNamespace()) &amp;&amp; classDecl.isEvent()) { // Transaction relationship in event, continue } else if((namespace === ModelUtil.getSystemNamespace()) &amp;&amp; classDeclaration.isSystemRelationshipTarget() === false) { throw new IllegalModelException('Relationship ' + this.getName() + ' must be to an asset, participant or transaction, but is to ' + this.getFullyQualifiedTypeName(), classDecl.getModelFile(), this.ast.location); } else if(classDeclaration.isRelationshipTarget() === false) { throw new IllegalModelException('Relationship ' + this.getName() + ' must be to an asset or participant, but is to ' + this.getFullyQualifiedTypeName(), classDecl.getModelFile(), this.ast.location); } } } /** * Returns a string representation of this property * @return {String} the string version of the property. */ toString() { return 'RelationshipDeclaration {name=' + this.name + ', type=' + this.getFullyQualifiedTypeName() + ', array=' + this.array + ', optional=' + this.optional +'}'; }} module.exports = RelationshipDeclaration; × Search results Close "},"composer-common_lib_model_resource.js.html":{"id":"composer-common_lib_model_resource.js.html","title":"Source: composer-common/lib/model/resource.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/resource.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Identifiable = require('./identifiable'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class Resource extends Identifiable { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @private */ constructor(modelManager, ns, type, id) { super(modelManager, ns, type, id); } /** * Returns the string representation of this class * @return {String} the string representation of the class */ toString() { return 'Resource {id=' + this.getFullyQualifiedIdentifier() +'}'; } /** * Determine if this identifiable is a resource. * @return {boolean} True if this identifiable is a resource, * false if not. */ isResource() { return true; } } module.exports = Resource; × Search results Close "},"composer-common_lib_serializer_resourcevalidator.js.html":{"id":"composer-common_lib_serializer_resourcevalidator.js.html","title":"Source: composer-common/lib/serializer/resourcevalidator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/resourcevalidator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('../introspect/classdeclaration'); const Field = require('../introspect/field'); const RelationshipDeclaration = require('../introspect/relationshipdeclaration'); const EnumDeclaration = require('../introspect/enumdeclaration'); const Relationship = require('../model/relationship'); const Resource = require('../model/resource'); const Concept = require('../model/concept'); const Identifiable = require('../model/identifiable'); const Util = require('../util'); const ModelUtil = require('../modelutil'); const ValidationException = require('./validationexception'); const Globalize = require('../globalize'); /** * &lt;p&gt; * Validates a Resource or Field against the models defined in the ModelManager. * This class is used with the Visitor pattern and visits the class declarations * (etc) for the model, checking that the data in a Resource / Field is consistent * with the model. * &lt;/p&gt; * The parameters for the visit method must contain the following properties: * &lt;ul&gt; * &lt;li&gt; 'stack' - the TypedStack of objects being processed. It should * start as [Resource] or [Field]&lt;/li&gt; * &lt;li&gt; 'rootResourceIdentifier' - the identifier of the resource being validated &lt;/li&gt; * &lt;li&gt; 'modelManager' - the ModelManager instance to use for type checking&lt;/li&gt; * &lt;/ul&gt; * @private * @class * @memberof module:composer-common */ class ResourceValidator { /** * Visitor design pattern. * * @param {Object} thing - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visit(thing, parameters) { const obj = parameters.stack.peek(); this.log('visit', thing.toString() + ' with value (' + obj + ')'); if (thing instanceof EnumDeclaration) { return this.visitEnumDeclaration(thing, parameters); } else if (thing instanceof ClassDeclaration) { return this.visitClassDeclaration(thing, parameters); } else if (thing instanceof RelationshipDeclaration) { return this.visitRelationshipDeclaration(thing, parameters); } else if (thing instanceof Field) { return this.visitField(thing, parameters); } } /** * Visitor design pattern * * @param {EnumDeclaration} enumDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitEnumDeclaration(enumDeclaration, parameters) { const obj = parameters.stack.pop(); // now check that obj is one of the enum values const properties = enumDeclaration.getProperties(); let found = false; for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; if(property.getName() === obj) { found = true; } } if(!found) { ResourceValidator.reportInvalidEnumValue( parameters.rootResourceIdentifier, enumDeclaration, obj ); } return null; } /** * Visitor design pattern * @param {ClassDeclaration} classDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitClassDeclaration(classDeclaration, parameters) { const obj = parameters.stack.pop(); // are we dealing with a Resouce? if(!((obj instanceof Resource) || (obj instanceof Concept))) { ResourceValidator.reportNotResouceViolation(parameters.rootResourceIdentifier, classDeclaration, obj ); } if(obj instanceof Identifiable) { parameters.rootResourceIdentifier = obj.getFullyQualifiedIdentifier(); } const toBeAssignedClassDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); // is the type we are assigning to abstract? // the only way this can happen is if the type is non-abstract // and then gets redeclared as abstract if(toBeAssignedClassDeclaration.isAbstract()) { ResourceValidator.reportAbstractClass(toBeAssignedClassDeclaration); } // are there extra fields in the object? let props = Object.getOwnPropertyNames(obj); for (let n = 0; n &lt; props.length; n++) { let propName = props[n]; if(!this.isSystemProperty(propName)) { const field = toBeAssignedClassDeclaration.getProperty(propName); if (!field) { if(obj instanceof Identifiable) { ResourceValidator.reportUndeclaredField(obj.getIdentifier(), propName, toBeAssignedClassDeclaration.getFullyQualifiedName()); } else { ResourceValidator.reportUndeclaredField(this.currentIdentifier, propName, toBeAssignedClassDeclaration.getFullyQualifiedName()); } } } } if(obj instanceof Identifiable) { const id = obj.getIdentifier(); // prevent empty identifiers if(!id || id.trim().length === 0) { ResourceValidator.reportEmptyIdentifier(parameters.rootResourceIdentifier); } this.currentIdentifier = obj.getFullyQualifiedIdentifier(); } // now validate each property const properties = toBeAssignedClassDeclaration.getProperties(); for(let n=0; n &lt; properties.length; n++) { const property = properties[n]; const value = obj[property.getName()]; if(!Util.isNull(value)) { parameters.stack.push(value); property.accept(this,parameters); } else { if(!property.isOptional()) { ResourceValidator.reportMissingRequiredProperty( parameters.rootResourceIdentifier, property); } } } return null; } /** * Returns true if the property is a system property. * System properties are not declared in the model. * @param {String} propertyName - the name of the property * @return {Boolean} true if the property is a system property * @private */ isSystemProperty(propertyName) { return propertyName.charAt(0) === '$'; } /** * Visitor design pattern * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitField(field, parameters) { const obj = parameters.stack.pop(); let dataType = typeof(obj); let propName = field.getName(); if (dataType === 'undefined' || dataType === 'symbol') { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } if(field.isTypeEnum()) { this.checkEnum(obj, field,parameters); } else { if(field.isArray()) { this.checkArray(obj, field,parameters); } else { this.checkItem(obj, field,parameters); } } return null; } /** * Check a Field that is declared as an Array. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkEnum(obj,field,parameters) { if(field.isArray() &amp;&amp; !(obj instanceof Array)) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, field.getName(), obj, field); } const enumDeclaration = field.getParent().getModelFile().getType(field.getType()); if(field.isArray()) { for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; parameters.stack.push(item); enumDeclaration.accept(this, parameters); } } else { const item = obj; parameters.stack.push(item); enumDeclaration.accept(this, parameters); } } /** * Check a Field that is declared as an Array. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkArray(obj,field,parameters) { if(!(obj instanceof Array)) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, field.getName(), obj, field); } for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; this.checkItem(item, field, parameters); } } /** * Check a single (non-array) field. * @param {Object} obj - the object being validated * @param {Field} field - the object being visited * @param {Object} parameters - the parameter * @private */ checkItem(obj,field, parameters) { let dataType = typeof obj; let propName = field.getName(); if (dataType === 'undefined' || dataType === 'symbol') { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } if(field.isPrimitive()) { let invalid = false; switch(field.getType()) { case 'String': if(dataType !== 'string') { invalid = true; } break; case 'Double': case 'Long': case 'Integer': if(dataType !== 'number') { invalid = true; } break; case 'Boolean': if(dataType !== 'boolean') { invalid = true; } break; case 'DateTime': if(!(obj instanceof Date)) { invalid = true; } break; } if (invalid) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } else { if(field.getValidator() !== null) { field.getValidator().validate(this.currentIdentifier, obj); } } } else { // a field that points to a transaction, asset, participant... let classDeclaration = parameters.modelManager.getType(field.getFullyQualifiedTypeName()); if(obj instanceof Identifiable) { try { classDeclaration = parameters.modelManager.getType(obj.getFullyQualifiedType()); } catch (err) { ResourceValidator.reportFieldTypeViolation(parameters.rootResourceIdentifier, propName, obj, field); } // is it compatible? if(!ModelUtil.isAssignableTo(classDeclaration.getModelFile(), classDeclaration.getFullyQualifiedName(), field)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, propName, obj, field); } } // recurse parameters.stack.push(obj); classDeclaration.accept(this, parameters); } } /** * Visitor design pattern * @param {RelationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ visitRelationshipDeclaration(relationshipDeclaration, parameters) { const obj = parameters.stack.pop(); if(relationshipDeclaration.isArray()) { if(!(obj instanceof Array)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, relationshipDeclaration.getName(), obj, relationshipDeclaration); } for(let n=0; n &lt; obj.length; n++) { const item = obj[n]; this.checkRelationship(parameters, relationshipDeclaration, item); } } else { this.checkRelationship(parameters, relationshipDeclaration, obj); } return null; } /** * Check a single relationship * @param {Object} parameters - the parameter * @param {relationshipDeclaration} relationshipDeclaration - the object being visited * @param {Object} obj - the object being validated * @private */ checkRelationship(parameters, relationshipDeclaration, obj) { if(!(obj instanceof Relationship)) { ResourceValidator.reportNotRelationshipViolation(parameters.rootResourceIdentifier, relationshipDeclaration, obj); } const relationshipType = parameters.modelManager.getType(obj.getFullyQualifiedType()); if(relationshipType.isConcept()) { throw new Error('Cannot have a relationship to a concept. Relationships must be to resources.'); } if(!ModelUtil.isAssignableTo(relationshipType.getModelFile(), obj.getFullyQualifiedType(), relationshipDeclaration)) { ResourceValidator.reportInvalidFieldAssignment(parameters.rootResourceIdentifier, relationshipDeclaration.getName(), obj, relationshipDeclaration); } } /** * @param {String} callSite - the location * @param {String} message - the message to log. */ log(callSite, message) { const log = false; if(log) { if(!message) { message = ''; } } } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {string} propName - the name of the field. * @param {*} value - the value of the field. * @param {Field} field - the field * @throws {ValidationException} the exception * @private */ static reportFieldTypeViolation(id, propName, value, field) { let isArray = field.isArray() ? '[]' : ''; let typeOfValue = typeof value; if(value instanceof Identifiable) { typeOfValue = value.getFullyQualifiedType(); value = value.getFullyQualifiedIdentifier(); } else { if(value) { try { value = JSON.stringify(value); } catch(err) { value = value.toString(); } } } let formatter = Globalize.messageFormatter('resourcevalidator-fieldtypeviolation'); throw new ValidationException(formatter({ resourceId: id, propertyName: propName, fieldType: field.getType() + isArray, value: value, typeOfValue: typeOfValue })); } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {classDeclaration} classDeclaration - the declaration of the classs * @param {Object} value - the value of the field. * @private */ static reportNotResouceViolation(id, classDeclaration, value) { let formatter = Globalize.messageFormatter('resourcevalidator-notresourceorconcept'); throw new ValidationException(formatter({ resourceId: id, classFQN: classDeclaration.getFullyQualifiedName(), invalidValue: value.toString() })); } /** * Throw a new error for a model violation. * @param {string} id - the identifier of this instance. * @param {RelationshipDeclaration} relationshipDeclaration - the declaration of the classs * @param {Object} value - the value of the field. * @private */ static reportNotRelationshipViolation(id, relationshipDeclaration, value) { let formatter = Globalize.messageFormatter('resourcevalidator-notrelationship'); throw new ValidationException(formatter({ resourceId: id, classFQN: relationshipDeclaration.getFullyQualifiedTypeName(), invalidValue: value.toString() })); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field/ * @private */ static reportMissingRequiredProperty(id, field) { let formatter = Globalize.messageFormatter('resourcevalidator-missingrequiredproperty'); throw new ValidationException(formatter({ resourceId: id, fieldName: field.getName() })); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field/ * @private */ static reportEmptyIdentifier(id) { let formatter = Globalize.messageFormatter('resourcevalidator-emptyidentifier'); throw new ValidationException(formatter({ resourceId: id })); } /** * Throw a new error for a missing, but required field. * @param {string} id - the identifier of this instance. * @param {Field} field - the field * @param {string} obj - the object value * @private */ static reportInvalidEnumValue(id, field, obj) { let formatter = Globalize.messageFormatter('resourcevalidator-invalidenumvalue'); throw new ValidationException(formatter({ resourceId: id, value: obj, fieldName: field.getName() })); } /** * Throw a validation exception for an abstract class * @param {ClassDeclaration} classDeclaration - the class declaration * @throws {ValidationException} the validation exception * @private */ static reportAbstractClass(classDeclaration) { let formatter = Globalize.messageFormatter('resourcevalidator-abstractclass'); throw new ValidationException(formatter({ className: classDeclaration.getFullyQualifiedName(), })); } /** * Throw a validation exception for an abstract class * @param {string} resourceId - the id of the resouce being validated * @param {string} propertyName - the name of the property that is not declared * @param {string} fullyQualifiedTypeName - the fully qualified type being validated * @throws {ValidationException} the validation exception * @private */ static reportUndeclaredField(resourceId, propertyName, fullyQualifiedTypeName ) { let formatter = Globalize.messageFormatter('resourcevalidator-undeclaredfield'); throw new ValidationException(formatter({ resourceId: resourceId, propertyName: propertyName, fullyQualifiedTypeName: fullyQualifiedTypeName })); } /** * Throw a validation exception for an invalid field assignment * @param {string} resourceId - the id of the resouce being validated * @param {string} propName - the name of the property that is being assigned * @param {*} obj - the Field * @param {Field} field - the Field * @throws {ValidationException} the validation exception * @private */ static reportInvalidFieldAssignment(resourceId, propName, obj, field) { let formatter = Globalize.messageFormatter('resourcevalidator-invalidfieldassignment'); let typeName = field.getFullyQualifiedTypeName(); if(field.isArray()) { typeName += '[]'; } throw new ValidationException(formatter({ resourceId: resourceId, propertyName: propName, objectType: obj.getFullyQualifiedType(), fieldType: typeName })); } } module.exports = ResourceValidator; × Search results Close "},"composer-common_lib_introspect_script.js.html":{"id":"composer-common_lib_introspect_script.js.html","title":"Source: composer-common/lib/introspect/script.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/script.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const JavaScriptParser = require('../codegen/javascriptparser'); const FunctionDeclaration = require('../introspect/functiondeclaration'); /** * &lt;p&gt; * An executable script. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class Script { /** * Create the Script. * &lt;p&gt; * @param {ModelManager} modelManager - The ModelManager associated with this Script * @param {string} identifier - The identifier of the script * @param {string} language - The language type of the script * @param {string} contents - The contents of the script */ constructor(modelManager, identifier, language, contents) { this.modelManager = modelManager; this.identifier = identifier; this.language = language; this.contents = contents; this.functions = []; if(!contents) { throw new Error('Empty script contents'); } const parser = new JavaScriptParser(this.contents, false, 5); const functions = parser.getFunctions(); for(let n=0; n &lt; functions.length; n++) { const func = functions[n]; const functionDeclaration = new FunctionDeclaration(this.modelManager, this.language, func.name, func.visibility, func.returnType, func.throws, func.parameterNames, func.parameterTypes, func.decorators, func.functionText ); functionDeclaration.validate(); this.functions.push( functionDeclaration ); } this.tokens = parser.getTokens(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the identifier of the script * @return {string} the identifier of the script */ getIdentifier() { return this.identifier; } /** * Returns the identifier of the script * @return {string} the identifier of the script */ getName() { return this.identifier; } /** * Returns the language of the script * @return {string} the identifier of the script */ getLanguage() { return this.language; } /** * Returns the contents of the script * @return {string} the identifier of the script */ getContents() { return this.contents; } /** * Returns the FunctionDeclaration for all functions that have been defined in this * Script. * * @return {FunctionDeclaration[]} The array of FunctionDeclarations */ getFunctionDeclarations() { return this.functions; } /** * Returns the tokens of the script * @return {Object[]} the tokens of the script */ getTokens() { return this.tokens; } } module.exports = Script; × Search results Close "},"composer-common_lib_scriptmanager.js.html":{"id":"composer-common_lib_scriptmanager.js.html","title":"Source: composer-common/lib/scriptmanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/scriptmanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Script = require('./introspect/script'); /** * &lt;p&gt; * Manages a set of scripts. * &lt;/p&gt; * @private * @class * @memberof module:composer-common */ class ScriptManager { /** * Create the ScriptManager. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link BusinessNetworkDefinition}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager to use for this ScriptManager */ constructor(modelManager) { this.modelManager = modelManager; this.scripts = {}; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Creates a new Script from a string. * * @param {string} identifier - the identifier of the script * @param {string} language - the language identifier of the script * @param {string} contents - the contents of the script * @returns {Script} - the instantiated script */ createScript(identifier, language, contents) { return new Script(this.modelManager, identifier, language, contents ); } /** * Adds a Script to the ScriptManager * @param {Script} script - The script to add to the ScriptManager */ addScript(script) { this.scripts[script.getIdentifier()] = script; } /** * Update an existing Script in the ScriptManager * @param {Script} script - The script to add to the ScriptManager */ updateScript(script) { if (!this.scripts[script.getIdentifier()]) { throw new Error('Script file does not exist'); } this.addScript(script); } /** * Remove the Script * @param {string} identifier - The identifier of the script to remove * delete. */ deleteScript(identifier) { if (!this.scripts[identifier]) { throw new Error('Script file does not exist'); } delete this.scripts[identifier]; } /** * Get the array of Script instances * @return {Script[]} The Scripts registered * @private */ getScripts() { let keys = Object.keys(this.scripts); let result = []; for(let n=0; n &lt; keys.length;n++) { result.push(this.scripts[keys[n]]); } return result; } /** * Remove all registered Composer files */ clearScripts() { this.scripts = {}; } /** * Get the Script associated with an identifier * @param {string} identifier - the identifier of the Script * @return {Script} the Script * @private */ getScript(identifier) { return this.scripts[identifier]; } /** * Get the identifiers of all registered scripts * @return {string[]} The identifiers of all registered scripts */ getScriptIdentifiers() { return Object.keys(this.scripts); } } module.exports = ScriptManager; × Search results Close "},"composer-common_lib_securitycontext.js.html":{"id":"composer-common_lib_securitycontext.js.html","title":"Source: composer-common/lib/securitycontext.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/securitycontext.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * SecurityContext is used to authenticate and manage * user credentials to the underlying blockchain fabric. * &lt;p&gt;&lt;a href=&quot;./diagrams/securitycontext.svg&quot;&gt;&lt;img src=&quot;./diagrams/securitycontext.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @abstract * @class * @memberof module:composer-common */ class SecurityContext { /** * Create the SecurityContext. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances by calling {@link Composer#login login}&lt;/strong&gt; * &lt;/p&gt; * @param {Connection} connection The owning connection. * @param {string} user The user identifier. */ constructor(connection) { this.connection = connection; } /** * Get the owning connection. * @return {Connection} The owning connection. */ getConnection() { return this.connection; } /** * Get the current username. * @abstract * @return {string} The username */ getUser() { throw new Error('abstract function called'); } } module.exports = SecurityContext; × Search results Close "},"composer-common_lib_securityexception.js.html":{"id":"composer-common_lib_securityexception.js.html","title":"Source: composer-common/lib/securityexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/securityexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('./baseexception'); /** * Class representing a security exception * &lt;p&gt;&lt;a href=&quot;./diagrams/securityexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/securityexception.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class SecurityException extends BaseException { /** * Create the SecurityException. * @param {string} message - The exception message. */ constructor(message) { super(message); } } module.exports = SecurityException; × Search results Close "},"composer-common_lib_query_select.js.html":{"id":"composer-common_lib_query_select.js.html","title":"Source: composer-common/lib/query/select.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/select.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); const Limit = require('./limit'); const OrderBy = require('./orderby'); const Skip = require('./skip'); const Where = require('./where'); /** * Select defines a SELECT query over a resource (asset, transaction or participant) * * @private * @class * @memberof module:composer-common */ class Select { /** * Create an Select from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Query} query - the Query for this select * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(query, ast) { if(!query || !ast) { throw new IllegalModelException('Invalid Query or AST'); } this.ast = ast; this.query = query; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the QueryFile that owns this Query. * * @return {Query} the owning QueryFile */ getQuery() { return this.query; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { // The grammar ensures that the resource property is set. this.resource = this.ast.resource; this.registry = null; if(this.ast.registry) { this.registry = this.ast.registry; } this.where = null; if(this.ast.where) { this.where = new Where(this, this.ast.where); } this.limit = null; if(this.ast.limit) { this.limit = new Limit(this, this.ast.limit); } this.skip = null; if(this.ast.skip) { this.skip = new Skip(this, this.ast.skip); } this.orderBy = null; if(this.ast.orderBy) { this.orderBy = new OrderBy(this, this.ast.orderBy); } this.text = null; if(this.ast.text) { this.text = this.ast.text; } } /** * Semantic validation of the structure of this select. * * @throws {IllegalModelException} * @private */ validate() { // The grammar ensures that the resource property is set. const mm = this.getQuery().getQueryFile().getModelManager(); // checks the resource type exists const resourceClassDeclaration = mm.getType(this.resource); // check that it is not an enum or concept if(resourceClassDeclaration.isConcept() || resourceClassDeclaration.isEnum()) { throw new Error('Can only select assets, participants and transactions.'); } if(this.where) { this.where.validate(); } if(this.limit) { this.limit.validate(); } if(this.skip) { this.skip.validate(); } if(this.orderBy) { this.orderBy.validate(); } } /** * Returns the FQN of the resource of this select or null if it does not have a resource. * * @return {string} the fully qualified name of the select */ getResource() { return this.resource; } /** * Returns the name of the registry of this select or null if it does not have a registry. * * @return {string} the name of the registry of the select */ getRegistry() { return this.registry; } /** * Returns the Where clause for this query or null if it does not have a WHERE clause. * * @return {Where} the Where or null */ getWhere() { return this.where; } /** * Returns the OrderBy clause for this query or null if it does not have an ORDER BY clause. * * @return {OrderBy} the OrderBy or null */ getOrderBy() { return this.orderBy; } /** * Returns the LIMIT count for this query or null if it does not have a LIMIT * * @return {Limit} the LIMIT or null */ getLimit() { return this.limit; } /** * Returns the SKIP count for this query or null if it does not have a SKIP * * @return {Skip} the SKIP or null */ getSkip() { return this.skip; } /** * Returns the text of this select statement. * @return {string} the text of this select statement. */ getText() { return this.text; } } module.exports = Select; × Search results Close "},"composer-common_lib_serializer.js.html":{"id":"composer-common_lib_serializer.js.html","title":"Source: composer-common/lib/serializer.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const EventDeclaration = require('./introspect/eventdeclaration'); const Globalize = require('./globalize'); const JSONGenerator = require('./serializer/jsongenerator'); const JSONPopulator = require('./serializer/jsonpopulator'); const Resource = require('./model/resource'); const ResourceValidator = require('./serializer/resourcevalidator'); const TransactionDeclaration = require('./introspect/transactiondeclaration'); const TypedStack = require('./serializer/typedstack'); const JSONWriter = require('./codegen/jsonwriter'); /** * Serialize Resources instances to/from various formats for long-term storage * (e.g. on the blockchain). * &lt;p&gt;&lt;a href=&quot;./diagrams/serializer.svg&quot;&gt;&lt;img src=&quot;./diagrams/serializer.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @class * @memberof module:composer-common */ class Serializer { /** * Create a Serializer. * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Composer}&lt;/strong&gt; * &lt;/p&gt; * @param {Factory} factory - The Factory to use to create instances * @param {ModelManager} modelManager - The ModelManager to use for validation etc. */ constructor(factory,modelManager) { if(!factory) { throw new Error(Globalize.formatMessage('serializer-constructor-factorynull')); } else if(!modelManager) { throw new Error(Globalize.formatMessage('serializer-constructor-modelmanagernull')); } this.factory = factory; this.modelManager = modelManager; } /** * &lt;p&gt; * Convert a {@link Resource} to a JavaScript object suitable for long-term * peristent storage. * &lt;/p&gt; * @param {Resource} resource - The instance to convert to JSON * @param {Object} options - the optional serialization options. * @param {boolean} options.validate - validate the structure of the Resource * with its model prior to serialization (default to true) * @param {boolean} options.convertResourcesToRelationships - Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} options.permitResourcesForRelationships - Permit resources in the * place of relationships (serializing them as resources), false by default. * @return {Object} - The Javascript Object that represents the resource * @throws {Error} - throws an exception if resource is not an instance of * Resource or fails validation. */ toJSON(resource, options) { // correct instance type if(!(resource instanceof Resource)) { throw new Error(Globalize.formatMessage('serializer-tojson-notcobject')); } const parameters = {}; parameters.stack = new TypedStack(resource); parameters.modelManager = this.modelManager; parameters.seenResources = new Set(); const classDeclaration = this.modelManager.getType( resource.getFullyQualifiedType() ); // validate the resource against the model options = options || { validate: true }; if(options.validate === true) { const validator = new ResourceValidator(); classDeclaration.accept(validator, parameters); } const generator = new JSONGenerator( options.convertResourcesToRelationships === true, options.permitResourcesForRelationships === true ); const writer = new JSONWriter(); parameters.writer = writer; parameters.stack.clear(); parameters.stack.push(resource); // this writes the JSON into the parameters.writer classDeclaration.accept(generator, parameters); const jsonText = parameters.writer.getBuffer(); try { return JSON.parse(jsonText); } catch(err) { throw new Error( 'Generated invalid JSON: ' + jsonText ); } } /** * Create a {@link Resource} from a JavaScript Object representation. * The JavaScript Object should have been created by calling the * {@link Serializer#toJSON toJSON} API. * * The Resource is populated based on the JavaScript object. * * @param {Object} jsonObject The JavaScript Object for a Resource * @param {Object} options - the optional serialization options * @param {boolean} options.acceptResourcesForRelationships - handle JSON objects * in the place of strings for relationships, defaults to false. * @return {Resource} The new populated resource */ fromJSON(jsonObject, options) { if(!jsonObject.$class) { throw new Error('Invalid JSON data. Does not contain a $class type identifier.'); } const classDeclaration = this.modelManager.getType(jsonObject.$class); // default the options. options = options || {}; // create a new instance, using the identifier field name as the ID. let resource; if (classDeclaration instanceof TransactionDeclaration) { resource = this.factory.newTransaction( classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); } else if (classDeclaration instanceof EventDeclaration) { resource = this.factory.newEvent( classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); } else { resource = this.factory.newResource( classDeclaration.getModelFile().getNamespace(), classDeclaration.getName(), jsonObject[classDeclaration.getIdentifierFieldName()] ); } // populate the resource based on the jsonObject // by walking the classDeclaration const parameters = {}; parameters.jsonStack = new TypedStack(jsonObject); parameters.resourceStack = new TypedStack(resource); parameters.modelManager = this.modelManager; parameters.factory = this.factory; const populator = new JSONPopulator(options.acceptResourcesForRelationships === true); classDeclaration.accept(populator, parameters); return resource; } } module.exports = Serializer; × Search results Close "},"composer-common_lib_query_skip.js.html":{"id":"composer-common_lib_query_skip.js.html","title":"Source: composer-common/lib/query/skip.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/skip.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Skip defines the SKIP portion of a SELECT statement * * @private * @class * @memberof module:composer-common */ class Skip { /** * Create a Skip from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this Skip * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new IllegalModelException('Invalid Select or AST'); } this.ast = ast; this.select = select; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this Skip. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this skip. * * @throws {IllegalModelException} * @private */ validate() { // TODO (DCS) walk the AST and check that the properties exist in the model! } /** * Return the AST for this skip statement. * @return {Object} The AST for this skip statement. */ getAST() { return this.ast; } } module.exports = Skip; × Search results Close "},"composer-common_lib_query_sort.js.html":{"id":"composer-common_lib_query_sort.js.html","title":"Source: composer-common/lib/query/sort.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/sort.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Defines a sort on a field for an ORDER BY clause * * @private * @class * @memberof module:composer-common */ class Sort { /** * Create a Sort from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {OrderBy} orderBy - the OrderBy for this sort by * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(orderBy, ast) { if(!orderBy || !ast) { throw new IllegalModelException('Invalid OrderBy or AST'); } this.ast = ast; this.orderBy = orderBy; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the OrderBy that owns this Sort. * * @return {OrderBy} the owning OrderBy */ getOrderBy() { return this.orderBy; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { this.propertyPath = this.ast.fieldName.name; this.direction = 'ASC'; if(this.ast.direction) { this.direction = this.ast.direction; } this.direction = this.ast.direction; } /** * Semantic validation of the structure of this select. * * @throws {IllegalModelException} * @private */ validate() { } /** * Returns the name of the property of the owning resource. This may be an dotted expression * to navigate to sub-properties of the owning resource. E.g. x.y.z. * * @return {string} the navigation property */ getPropertyPath() { return this.propertyPath; } /** * Returns the name of the property of the owning resource. This may be an dotted expression * to navigate to sub-properties of the owning resource. E.g. x.y.z. * * @return {string} the navigation property */ getDirection() { return this.direction; } } module.exports = Sort; × Search results Close "},"composer-common_lib_introspect_transactiondeclaration.js.html":{"id":"composer-common_lib_introspect_transactiondeclaration.js.html","title":"Source: composer-common/lib/introspect/transactiondeclaration.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/transactiondeclaration.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const ClassDeclaration = require('./classdeclaration'); const IllegalModelException = require('./illegalmodelexception'); /** Class representing the definition of an Transaction. * @extends ClassDeclaration * @see See [ClassDeclaration]{@link module:composer-common.ClassDeclaration} * @private * @class * @memberof module:composer-common */ class TransactionDeclaration extends ClassDeclaration { /** * Create an TransactionDeclaration. * @param {ModelFile} modelFile the ModelFile for this class * @param {Object} ast - The AST created by the parser * @throws {IllegalModelException} */ constructor(modelFile, ast) { super(modelFile, ast); } /** * Returns the base system type for Transactions from the system namespace * * @return {string} the short name of the base system type */ getSystemType() { return 'Transaction'; } /** * Semantic validation of the structure of this asset. Subclasses should * override this method to impose additional semantic constraints on the * contents/relations of fields. * * @throws {IllegalModelException} * @private */ validate() { super.validate(); if(!this.isSystemType() &amp;&amp; this.getName() === 'Transaction') { throw new IllegalModelException('Transaction is a reserved type name.', this.modelFile, this.ast.location); } } } module.exports = TransactionDeclaration; × Search results Close "},"composer-common_lib_model_typed.js.html":{"id":"composer-common_lib_model_typed.js.html","title":"Source: composer-common/lib/model/typed.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/typed.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Field = require('../introspect/field'); /** * Object is an instance with a namespace and a type. * * This class is abstract. * @abstract * @class * @memberof module:composer-common */ class Typed { /** * Create an instance. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @private */ constructor(modelManager, ns, type) { this.$modelManager = modelManager; this.$namespace = ns; this.$type = type; } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Get the ModelManager for this instance * @return {ModelManager} The ModelManager for this object * @private */ getModelManager() { return this.$modelManager; } /** * Get the type of the instance (a short name, not including namespace). * @return {string} The type of this object */ getType() { return this.$type; } /** * Get the fully-qualified type name of the instance (including namespace). * @return {string} The fully-qualified type name of this object */ getFullyQualifiedType() { return this.$namespace + '.' + this.$type; } /** * Get the namespace of the instance. * @return {string} The namespace of this object */ getNamespace() { return this.$namespace; } /** * Returns the class declaration for this instance object. * * @return {ClassDeclaration} - the class declaration for this instance * @throws {Error} - if the class or namespace for the instance is not declared * @private */ getClassDeclaration() { // do we have a model file? let modelFile = this.getModelManager().getModelFile(this.getNamespace()); if (!modelFile) { throw new Error('No model for namespace ' + this.getNamespace() + ' is registered with the ModelManager'); } // do we have a class? let classDeclaration = modelFile.getType(this.getType()); if (!classDeclaration) { throw new Error('The namespace ' + this.getNamespace() + ' does not contain the type ' + this.getType()); } return classDeclaration; } /** * Sets a property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ setPropertyValue(propName, value) { this[propName] = value; } /** * Adds a value to an array property on this Resource * @param {string} propName - the name of the field * @param {string} value - the value of the property */ addArrayValue(propName, value) { if(this[propName]) { this[propName].push(value); } else { this[propName] = [value]; } } /** * Sets the fields to their default values, based on the model * @private */ assignFieldDefaults() { let classDeclaration = this.getClassDeclaration(); let fields = classDeclaration.getProperties(); for (let n = 0; n &lt; fields.length; n++) { let field = fields[n]; if (field instanceof Field) { let defaultValue = field.getDefaultValue(); if (defaultValue) { if (field.getType() === 'String') { this.setPropertyValue(field.getName(), defaultValue); } else if (field.getType() === 'Integer') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Long') { this.setPropertyValue(field.getName(), parseInt(defaultValue)); } else if (field.getType() === 'Double') { this.setPropertyValue(field.getName(), parseFloat(defaultValue)); } else if (field.getType() === 'Boolean') { this.setPropertyValue(field.getName(), (defaultValue === 'true')); } else if (field.getType() === 'DateTime') { const dateTime = new Date(); dateTime.setTime(Date.parse(defaultValue)); this.setPropertyValue(field.getName(), dateTime); } } } } } /** * Check to see if this instance is an instance of the specified fully qualified * type name. * @param {String} fqt The fully qualified type name. * @returns {boolean} True if this instance is an instance of the specified fully * qualified type name, false otherwise. */ instanceOf(fqt) { const classDeclaration = this.getClassDeclaration(); return classDeclaration.getFullyQualifiedName() === fqt || classDeclaration.getAllSuperTypeDeclarations().some(declaration =&gt; declaration.getFullyQualifiedName() === fqt); } /** * Overriden to prevent people accidentally converting a resource to JSON * without using the Serializer. * @private */ toJSON() { throw new Error('Use Serializer.toJSON to convert resource instances to JSON objects.'); } } module.exports = Typed; × Search results Close "},"composer-common_lib_serializer_typedstack.js.html":{"id":"composer-common_lib_serializer_typedstack.js.html","title":"Source: composer-common/lib/serializer/typedstack.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/typedstack.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Util = require('../util'); /** * Tracks a stack of typed instances. The type information is used to detect * overflow / underflow bugs by the caller. It also performs basic sanity * checking on push/pop to make detecting bugs easier. * @private * @class * @memberof module:composer-common */ class TypedStack { /** * Create the Stack with the resource at the head. * @param {Object} resource - the resource to be put at the head of the stack */ constructor(resource) { this.stack = []; this.push(resource); } /** * Push a new object. * @param {Object} obj - the object being visited * @param {Object} expectedType - the expected type of the object being pushed */ push(obj, expectedType) { if(expectedType &amp;&amp; !(obj instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType.constructor.name + ' as argument to push. Found: ' + obj.toString()); } if(Util.isNull(obj)) { throw new Error('Pushing null data!'); } this.stack.push(obj); //console.log('Push depth is: ' + this.stack.length + ', contents: ' + this.stack.toString() ); } /** * Push a new object. * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of pop */ pop(expectedType) { this.peek(expectedType); return this.stack.pop(); } /** * Peek the top of the stack * @param {Object} expectedType - the type that should be the result of pop * @return {Object} the result of peek */ peek(expectedType) { //console.log( 'pop ' ); if(this.stack.length &lt; 1) { throw new Error('Stack is empty!'); } const result = this.stack[this.stack.length-1]; if(expectedType &amp;&amp; !(result instanceof expectedType)) { throw new Error('Did not find expected type ' + expectedType + ' on head of stack. Found: ' + result); } if(Util.isNull(result)) { throw new Error('Pop returned invalid data'); } return result; } /** * Clears the stack */ clear() { this.stack = []; } } module.exports = TypedStack; × Search results Close "},"composer-common_lib_typenotfoundexception.js.html":{"id":"composer-common_lib_typenotfoundexception.js.html","title":"Source: composer-common/lib/typenotfoundexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/typenotfoundexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('./baseexception'); const Globalize = require('./globalize'); /** * Error thrown when a Composer type does not exist. * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class TypeNotFoundException extends BaseException { /** * Constructor. If the optional 'message' argument is not supplied, it will be set to a default value that * includes the type name. * @param {String} typeName - fully qualified type name. * @param {String} [message] - error message. */ constructor(typeName, message) { if (!message) { const formatter = Globalize.messageFormatter('typenotfounderror-defaultmessage'); message = formatter({ typeName: typeName }); } super(message); this.typeName = typeName; } /** * Get the name of the type that was not found. * @returns {string} fully qualified type name. */ getTypeName() { return this.typeName; } } module.exports = TypeNotFoundException; × Search results Close "},"composer-common_lib_util.js.html":{"id":"composer-common_lib_util.js.html","title":"Source: composer-common/lib/util.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/util.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Globalize = require('./globalize'); const SecurityContext = require('./securitycontext'); const SecurityException = require('./securityexception'); /** * Internal Utility Class * &lt;p&gt;&lt;a href=&quot;./diagrams-private/util.svg&quot;&gt;&lt;img src=&quot;./diagrams-private/util.svg&quot; style=&quot;height:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @private * @class * @memberof module:composer-common */ class Util { /** * Internal method to check the security context * @param {SecurityContext} securityContext - The user's security context * @throws {SecurityException} if the user context is invalid */ static securityCheck(securityContext) { if (Util.isNull(securityContext)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } else if (!(securityContext instanceof SecurityContext)) { throw new SecurityException(Globalize.formatMessage('util-securitycheck-novalidcontext')); } } /** * Submit a query request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static queryChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); return securityContext.getConnection().queryChainCode(securityContext, functionName, args); } /** * Submit an invoke request to the chain-code * @param {SecurityContext} securityContext - The user's security context * @param {string} functionName - The name of the function to call. * @param {string[]} args - The arguments to pass to the function being called. * @return {Promise} - A promise that will be resolved with the value returned * by the chain-code function. */ static invokeChainCode(securityContext, functionName, args) { Util.securityCheck(securityContext); if (!functionName) { throw new Error('functionName not specified'); } else if (!args) { throw new Error('args not specified'); } args.forEach((arg) =&gt; { if (typeof arg !== 'string') { throw new Error('invalid arg specified: ' + arg); } }); return securityContext.getConnection().invokeChainCode(securityContext, functionName, args); } /** * Returns true if the typeof the object === 'undefined' or * the object === null. * @param {Object} obj - the object to be tested * @returns {boolean} true if the object is null or undefined */ static isNull(obj) { return(typeof(obj) === 'undefined' || obj === null); } } module.exports = Util; × Search results Close "},"composer-common_lib_model_validatedconcept.js.html":{"id":"composer-common_lib_model_validatedconcept.js.html","title":"Source: composer-common/lib/model/validatedconcept.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/validatedconcept.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Concept = require('./concept'); const TypedStack = require('../serializer/typedstack'); /** * &lt;p&gt; * Resource is an instance that has a type. The type of the resource * specifies a set of properites (which themselves have types). * &lt;/p&gt; * &lt;p&gt; * Type information in Composer is used to validate the structure of * Resource instances and for serialization. * &lt;/p&gt; * &lt;p&gt; * Resources are used in Composer to represent Assets, Participants, Transactions and * other domain classes that can be serialized for long-term persistent storage. * &lt;/p&gt; * @extends Identifiable * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class ValidatedConcept extends Concept { /** * This constructor should not be called directly. * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {ResourceValidator} resourceValidator - The validator to use for this instance * @private */ constructor(modelManager, ns, type, resourceValidator) { super(modelManager, ns, type); this.$validator = resourceValidator; } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setPropertyValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('Trying to set field ' + propName + ' which is not declared in the model.'); } // else { // this.log( 'Validating field ' + field + ' with data ' + value ); // } const parameters = {}; parameters.stack = new TypedStack(value); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; field.accept(this.$validator, parameters); super.setPropertyValue(propName,value); } /** * Adds an array property value, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ addArrayValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('Trying to set field ' + propName + ' which is not declared in the model.'); } if (!field.isArray()) { throw new Error('Trying to add array item ' + propName + ' which is not declared as an array in the model.'); } const parameters = {}; let newArray = []; if(this[propName]) { newArray = this[propName].slice(0); } newArray.push(value); parameters.stack = new TypedStack(newArray); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; field.accept(this.$validator, parameters); super.addArrayValue(propName, value); } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model */ validate() { const classDeclaration = this.getClassDeclaration(); const parameters = {}; parameters.stack = new TypedStack(this); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = 'undefined'; classDeclaration.accept(this.$validator, parameters); } } module.exports = ValidatedConcept; × Search results Close "},"composer-common_lib_model_validatedresource.js.html":{"id":"composer-common_lib_model_validatedresource.js.html","title":"Source: composer-common/lib/model/validatedresource.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/model/validatedresource.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const TypedStack = require('../serializer/typedstack'); const Resource = require('./resource'); /** * ValidatedResource is a Resource that can validate that property * changes (or the whole instance) do not violate the structure of * the type information associated with the instance. * @extends Resource * @see See [Resource]{@link module:composer-common.Resource} * @class * @memberof module:composer-common */ class ValidatedResource extends Resource { /** * This constructor should not be called directly. * Use the Factory class to create instances. * * &lt;p&gt; * &lt;strong&gt;Note: Only to be called by framework code. Applications should * retrieve instances from {@link Factory}&lt;/strong&gt; * &lt;/p&gt; * @param {ModelManager} modelManager - The ModelManager for this instance * @param {string} ns - The namespace this instance. * @param {string} type - The type this instance. * @param {string} id - The identifier of this instance. * @param {ResourceValidator} resourceValidator - The validator to use for this instance * @private */ constructor(modelManager, ns, type, id,resourceValidator) { super(modelManager, ns, type, id); this.$validator = resourceValidator; } /** * Sets a property, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ setPropertyValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } // else { // this.log( 'Validating field ' + field + ' with data ' + value ); // } const parameters = {}; parameters.stack = new TypedStack(value); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.setPropertyValue(propName,value); } /** * Adds an array property value, validating that it does not violate the model * @param {string} propName - the name of the field * @param {string} value - the value of the property * @throws {Error} if the value is not compatible with the model definition for the field */ addArrayValue(propName, value) { let classDeclaration = this.getClassDeclaration(); let field = classDeclaration.getProperty(propName); if (!field) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to set field ' + propName + ' which is not declared in the model.'); } if (!field.isArray()) { throw new Error('The instance with id ' + this.getIdentifier() + ' trying to add array item ' + propName + ' which is not declared as an array in the model.'); } const parameters = {}; let newArray = []; if(this[propName]) { newArray = this[propName].slice(0); } newArray.push(value); parameters.stack = new TypedStack(newArray); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); field.accept(this.$validator, parameters); super.addArrayValue(propName, value); } /** * Validates the instance against its model. * * @throws {Error} - if the instance if invalid with respect to the model */ validate() { const classDeclaration = this.getClassDeclaration(); const parameters = {}; parameters.stack = new TypedStack(this); parameters.modelManager = this.getModelManager(); parameters.rootResourceIdentifier = this.getFullyQualifiedIdentifier(); classDeclaration.accept(this.$validator, parameters); } } module.exports = ValidatedResource; × Search results Close "},"composer-common_lib_serializer_validationexception.js.html":{"id":"composer-common_lib_serializer_validationexception.js.html","title":"Source: composer-common/lib/serializer/validationexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/serializer/validationexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('../baseexception'); /** * Exception thrown when a resource fails to model against the model * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-common */ class ValidationException extends BaseException { /** * Create an ParseException * @param {string} message - the message for the exception */ constructor(message) { super(message); } } module.exports = ValidationException; × Search results Close "},"composer-common_lib_introspect_validator.js.html":{"id":"composer-common_lib_introspect_validator.js.html","title":"Source: composer-common/lib/introspect/validator.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/introspect/validator.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * An Abstract field validator. Extend this class and override the * validate method. * @private * @class * @abstract * @memberof module:composer-common */ class Validator { /** * Create a Property. * @param {Field} field - the field this validator is attached to * @param {Object} validator - The validation string * @throws {IllegalModelException} */ constructor(field, validator) { this.validator = validator; this.field = field; } /** * @param {string} id the identifier of the instance * @param {string} msg the exception message * @throws {Error} throws an error to report the message */ reportError(id, msg) { throw new Error( 'Invalid validator for field ' + id + ' ' + this.getField().getFullyQualifiedName() + ': ' + msg ); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the field that this validator applies to * @return {Field} the field */ getField() { return this.field; } /** * Validate the property against a value * @param {string} identifier the identifier of the instance being validated * @param {Object} value the value to validate * @throws {IllegalModelException} * @private */ validate(identifier, value) { } } module.exports = Validator; × Search results Close "},"composer-common_lib_tools_versionchecker.js.html":{"id":"composer-common_lib_tools_versionchecker.js.html","title":"Source: composer-common/lib/tools/versionchecker.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/tools/versionchecker.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const crypto = require('crypto'); const semver = require('semver'); /** * Checks that a change log file takes into account * the signature of a public API (tracks API breakage) * and that the version number in package.json is in sync * with the contents of the changelog. * @private * @class * @memberof module:composer-common */ class VersionChecker { /** * @param {string} changelog - the text of a changelog file * @param {string} publicApi - the text of a public API description * @param {string} packageJson - the text of a package.json file * @returns {boolean} true if the version check passes * @throws {Error} if there is an issue with the version check */ static check(changelog, publicApi, packageJson) { const changelogLines = changelog.split('\\n'); const digest = VersionChecker.getDigest(publicApi); let result = false; for (let n = 0; n &lt; changelogLines.length; n++) { const line = changelogLines[n]; if (!line.startsWith('#')) { // find the first instance of 'Version' const versionIndex = line.indexOf('Version'); if (versionIndex &gt;= 0) { // find the version number const openBraceIndex = line.indexOf('{', versionIndex); if (openBraceIndex &lt; 0) { throw new Error('Invalid changelog, failed to find { in line ' + line); } const version = line.substring(versionIndex + 'Version'.length, openBraceIndex).trim(); // check the version in package.json is up to date const packageObj = JSON.parse(packageJson); if (!semver.lte(version, packageObj.version)) { throw new Error(`The version in the changelog file &quot;${version}&quot; is not less than or equal to the version in package.json &quot;${packageObj.version}&quot;.`); } // get MD5 const closeBraceIndex = line.indexOf('}', openBraceIndex); if (closeBraceIndex &lt; 0) { throw new Error('Invalid changelog, failed to find } in line ' + line); } const md5 = line.substring(openBraceIndex + 1, closeBraceIndex).trim(); if (digest !== md5) { throw new Error('Computed public API digest did not match the digest in the changelog for the most recent version. ' + 'Increment the version number and add a new entry to the changelog (explaining your public API change) using the digest ' + digest + '. Run \\'git diff api.txt\\' to understand the pubic API changes.'); } // we're done here... result = true; break; } } } if (!result) { throw new Error('Did not find any version in changelog'); } else { console.log('SUCCESS: validated public API against package.json and changelog.txt.'); } return true; } /** * Gets the digest (hash) for an input string * @param {string} data - the data to hash * @returns {string} the hash in hex format */ static getDigest(data) { return crypto.createHash('md5').update(data).digest('hex'); } } module.exports = VersionChecker; × Search results Close "},"composer-common_lib_query_where.js.html":{"id":"composer-common_lib_query_where.js.html","title":"Source: composer-common/lib/query/where.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/query/where.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const IllegalModelException = require('../introspect/illegalmodelexception'); /** * Where defines the WHERE portion of a SELECT statement * * @private * @class * @memberof module:composer-common */ class Where { /** * Create a Where from an Abstract Syntax Tree. The AST is the * result of parsing. * * @param {Select} select - the Select for this Where * @param {string} ast - the AST created by the parser * @throws {IllegalModelException} */ constructor(select, ast) { if(!select || !ast) { throw new IllegalModelException('Invalid Select or AST'); } this.ast = ast; this.select = select; this.process(); } /** * Visitor design pattern * @param {Object} visitor - the visitor * @param {Object} parameters - the parameter * @return {Object} the result of visiting or null * @private */ accept(visitor,parameters) { return visitor.visit(this, parameters); } /** * Returns the Select that owns this Where. * * @return {Select} the owning Select */ getSelect() { return this.select; } /** * Process the AST and build the model * * @throws {IllegalModelException} * @private */ process() { } /** * Semantic validation of the structure of this where. * * @throws {IllegalModelException} * @private */ validate() { // TODO (DCS) walk the AST and check that the properties exist in the model! } /** * Return the AST for this where statement. * @return {Object} The AST for this where statement. */ getAST() { return this.ast; } } module.exports = Where; × Search results Close "},"composer-common_lib_codegen_writer.js.html":{"id":"composer-common_lib_codegen_writer.js.html","title":"Source: composer-common/lib/codegen/writer.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/codegen/writer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Writer buffers text to be written in memory. It handles simple * indentation and tracks the number of lines written. * @private * @class * @memberof module:composer-common */ class Writer { /** * Create a Writer. * */ constructor() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } /** * Writes text to the start of the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeBeforeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.beforeBuffer += ' '; } this.beforeBuffer += text; this.beforeBuffer += '\\n'; this.linesWritten++; } /** * Append text to the buffer * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeLine(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); this.write('\\n'); this.linesWritten++; } /** * Returns the number of lines that have been written to the buffer. * @return {int} the number of lines written to the buffer. */ getLineCount() { return this.linesWritten; } /** * Append text to the buffer, prepending tabs * @param {int} tabs - the number of tabs to use * @param {string} text - the text to write */ writeIndented(tabs,text) { for(let n=0; n &lt; tabs; n++) { this.write(' '); } this.write(text); } /** * Append text to the buffer (no automatic newline). The * text may contain newline, and these will increment the linesWritten * counter. * @param {string} msg - the text to write */ write(msg) { if(typeof msg !== 'string' ) { throw new Error('Can only append strings. Argument ' + msg + ' has type ' + typeof msg); } this.buffer += msg; this.linesWritten += msg.split(/\\r\\n|\\r|\\n/).length; } /** * Returns the text that has been buffered in this Writer. * @return {string} the buffered text. */ getBuffer() { return this.beforeBuffer + this.buffer; } /** * Empties the underyling buffer and resets the line count. */ clearBuffer() { this.beforeBuffer = ''; this.buffer = ''; this.linesWritten = 0; } } module.exports = Writer; × Search results Close "},"composer-runtime_index.js.html":{"id":"composer-runtime_index.js.html","title":"Source: composer-runtime/index.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/index.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * The runtime module provides the API that is made available to transaction * processing functions. * @module composer-runtime */ module.exports.Container = require('./lib/container'); module.exports.Context = require('./lib/context'); module.exports.DataCollection = require('./lib/datacollection'); module.exports.DataService = require('./lib/dataservice'); module.exports.Engine = require('./lib/engine'); module.exports.HTTPService = require('./lib/httpservice'); module.exports.EventService = require('./lib/eventservice'); module.exports.IdentityService = require('./lib/identityservice'); module.exports.LoggingService = require('./lib/loggingservice'); module.exports.ScriptCompiler = require('./lib/scriptcompiler'); × Search results Close "},"composer-runtime_lib_accesscontroller.js.html":{"id":"composer-runtime_lib_accesscontroller.js.html","title":"Source: composer-runtime/lib/accesscontroller.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/accesscontroller.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AccessException = require('./accessexception'); const Logger = require('composer-common').Logger; const ModelUtil = require('composer-common').ModelUtil; const LOG = Logger.getLog('AccessController'); /** * A class that manages access to registries and resources by processing * the access control list(s) in a business network definition. * @private * @class * @memberof module:composer-runtime */ class AccessController { /** * Constructor. * @param {AclManager} aclManager The ACL manager to use. */ constructor(aclManager) { const method = 'constructor'; LOG.entry(method, aclManager); this.aclManager = aclManager; this.participant = null; this.transaction = null; LOG.exit(method); } /** * Get the current participant. * @return {Resource} The current participant. */ getParticipant() { return this.participant; } /** * Set the current participant. * @param {Resource} participant The current participant. */ setParticipant(participant) { this.participant = participant; } /** * Get the current transaction. * @return {Resource} The current transaction. */ getTransaction() { return this.transaction; } /** * Set the current transaction. * @param {Resource} transaction The current transaction. */ setTransaction(transaction) { this.transaction = transaction; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @throws {AccessException} If the specified participant * does not have the specified level of access to the specified * resource. */ check(resource, access) { const method = 'check'; LOG.entry(method, resource.getFullyQualifiedIdentifier(), access); try { // Check to see if a participant has been set. If not, then ACL // enforcement is not enabled. let participant = this.participant; if (!participant) { LOG.debug(method, 'No participant'); LOG.exit(method); return; } // Grab the transaction. Does not matter if this is null. let transaction = this.transaction; // Check to see if an ACL file was supplied. If not, then ACL // enforcement is not enabled. if (!this.aclManager.getAclFile()) { LOG.debug(method, 'No ACL file'); LOG.exit(method); return; } // Iterate over the ACL rules in order, but stop at the first rule // that permits the action. let aclRules = this.aclManager.getAclRules(); let result = aclRules.some((aclRule) =&gt; { LOG.debug(method, 'Processing rule', aclRule); let value = this.checkRule(resource, access, participant, transaction, aclRule); LOG.debug(method, 'Processed rule', value); return value; }); // If a ACL rule permitted the action, return. if (result) { LOG.exit(method); return; } // Otherwise no ACL rule permitted the action. throw new AccessException(resource, access, participant, transaction); } catch (e) { LOG.error(method, e); throw e; } } /** * Check the specified ACL rule permits the specified level * of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ checkRule(resource, access, participant, transaction, aclRule) { const method = 'checkRule'; LOG.entry(method, resource, access, participant, transaction, aclRule); // Is the ACL rule relevant to the specified noun? if (!this.matchNoun(resource, aclRule)) { LOG.debug(method, 'Noun does not match'); LOG.exit(method, false); return false; } // Is the ACL rule relevant to the specified verb? if (!this.matchVerb(access, aclRule)) { LOG.debug(method, 'Verb does not match'); LOG.exit(method, false); return false; } // Is the ACL rule relevant to the specified participant? if (!this.matchParticipant(participant, aclRule)) { LOG.debug(method, 'Participant does not match'); LOG.exit(method, false); return false; } // Is the ACL rule relevant to the specified transaction? if (!this.matchTransaction(transaction, aclRule)) { LOG.debug(method, 'Transaction does not match'); LOG.exit(method, false); return false; } // Is the predicate met? if (!this.matchPredicate(resource, access, participant, transaction, aclRule)) { LOG.debug(method, 'Predicate does not match'); LOG.exit(method, false); return false; } // Yes, is this an allow or deny rule? if (aclRule.getAction() === 'ALLOW') { LOG.exit(method, true); return true; } // This must be an explicit deny rule, so throw. let e = new AccessException(resource, access, participant, transaction); LOG.error(method, e); throw e; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchNoun(resource, aclRule) { const method = 'matchNoun'; LOG.entry(method, resource.getFullyQualifiedIdentifier(), aclRule); // Determine the input ID. let id = resource.getIdentifier(); // Check to see if the resource is an instance of the // required resource type, or is in the required // namespace. let noun = aclRule.getNoun(); let reqFQN = noun.getFullyQualifiedName(); if (!ModelUtil.isMatchingType(resource, reqFQN)) { LOG.exit(method, false); return false; } // Check to see if the identifier matches (if specified). let reqID = noun.getInstanceIdentifier(); if (reqID) { if (id === reqID) { // Noun is matching identifier. } else { // Noun does not match. LOG.exit(method, false); return false; } } else { // Noun does not specify identifier. } LOG.exit(method, true); return true; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {string} access The level of access. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchVerb(access, aclRule) { const method = 'matchVerb'; LOG.entry(method, access, aclRule); // Check to see if the access matches the verb of the ACL rule. // Verb can be one of: // 'CREATE' / 'READ' / 'UPDATE' / 'ALL' / 'DELETE' let verbs = aclRule.getVerbs(); let result = verbs.some((verb) =&gt; { return verb === 'ALL' || access === verb; }); LOG.exit(method, result); return result; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} participant The participant. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchParticipant(participant, aclRule) { const method = 'matchParticipant'; LOG.entry(method, participant.getFullyQualifiedIdentifier(), aclRule); // Is a participant specified in the ACL rule? let reqParticipant = aclRule.getParticipant(); if (!reqParticipant) { LOG.exit(method, true); return true; } // Check to see if the participant is an instance of the // required participant type, or is in the required // namespace. let reqFQN = reqParticipant.getFullyQualifiedName(); if (!ModelUtil.isMatchingType(participant, reqFQN)) { LOG.exit(method, false); return false; } // Check to see if the identifier matches (if specified). let id = participant.getIdentifier(); let reqID = reqParticipant.getInstanceIdentifier(); if (reqID) { if (id === reqID) { // Participant is matching identifier. } else { // Participant does not match. LOG.exit(method, false); return false; } } else { // Participant does not specify identifier. } LOG.exit(method, true); return true; } /** * Check that the specified transaction has the specified * level of access to the specified resource. * @param {Resource} transaction The transaction. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchTransaction(transaction, aclRule) { const method = 'matchTransaction'; LOG.entry(method, transaction ? transaction.getFullyQualifiedIdentifier() : transaction, aclRule); // Is a transaction specified in the ACL rule? let reqTransaction = aclRule.getTransaction(); if (!reqTransaction) { LOG.exit(method, true); return true; } // OK, a transaction is specified in the ACL rule, but // are we executing in the scope of a transaction? if (!transaction) { LOG.exit(method, false); return false; } // Check to see if the participant is an instance of the // required participant type, or is in the required // namespace. let reqFQN = reqTransaction.getFullyQualifiedName(); if (!ModelUtil.isMatchingType(transaction, reqFQN)) { LOG.exit(method, false); return false; } LOG.exit(method, true); return true; } /** * Check that the specified participant has the specified * level of access to the specified resource. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. * @param {AclRule} aclRule The ACL rule. * @returns {boolean} True if the specified ACL rule permits * the specified level of access to the specified resource. */ matchPredicate(resource, access, participant, transaction, aclRule) { const method = 'matchPredicate'; LOG.entry(method, resource, access, participant, transaction, aclRule); // Get the predicate from the rule. let predicate = aclRule.getPredicate().getExpression(); // We can fast track the simple boolean predicates. if (predicate === 'true') { LOG.exit(method, true); return true; } else if (predicate === 'false') { LOG.exit(method, false); return false; } // Otherwise we need to build a function. let source = `return (${predicate});`; let argNames = []; let argValues = []; // Check to see if the resource needs to be bound. let resourceVar = aclRule.getNoun().getVariableName(); if (resourceVar) { argNames.push(resourceVar); argValues.push(resource); } // Check to see if the participant needs to be bound. let reqParticipant = aclRule.getParticipant(); if (reqParticipant) { let participantVar = aclRule.getParticipant().getVariableName(); if (participantVar) { argNames.push(participantVar); argValues.push(participant); } } // Check to see if the transaction needs to be bound. let reqTransaction = aclRule.getTransaction(); if (reqTransaction) { let transactionVar = aclRule.getTransaction().getVariableName(); if (transactionVar) { argNames.push(transactionVar); argValues.push(transaction); } } // Compile and execute the function. let result; try { LOG.debug(method, 'Compiling and executing function', source, argNames, argValues); let func = new Function(argNames.join(','), source); result = func.apply(null, argValues); } catch (e) { LOG.error(method, e); throw new AccessException(resource, access, participant, transaction); } // Convert the result into a boolean before returning it. result = !!result; LOG.exit(method, result); return result; } } module.exports = AccessController; × Search results Close "},"composer-runtime_lib_accessexception.js.html":{"id":"composer-runtime_lib_accessexception.js.html","title":"Source: composer-runtime/lib/accessexception.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/accessexception.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BaseException = require('composer-common').BaseException; /** * Class representing an access exception * &lt;p&gt;&lt;a href=&quot;./diagrams/accessexception.svg&quot;&gt;&lt;img src=&quot;./diagrams/accessexception.svg&quot; style=&quot;width:100%;&quot;/&gt;&lt;/a&gt;&lt;/p&gt; * @protected * @extends BaseException * @see See [BaseException]{@link module:composer-common.BaseException} * @class * @memberof module:composer-runtime */ class AccessException extends BaseException { /** * Generate the exception message. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. * @return {string} The exception message. */ static generateMessage(resource, access, participant, transaction) { let resourceId = resource.getFullyQualifiedIdentifier(); let participantId = participant.getFullyQualifiedIdentifier(); return `Participant '${participantId}' does not have '${access}' access to resource '${resourceId}'`; } /** * Constructor. * @param {Resource} resource The resource. * @param {string} access The level of access. * @param {Resource} participant The participant. * @param {Resource} transaction The transaction. */ constructor(resource, access, participant, transaction) { super(AccessException.generateMessage(resource, access, participant, transaction)); } } module.exports = AccessException; × Search results Close "},"composer-runtime_lib_api_assetregistry.js.html":{"id":"composer-runtime_lib_api_assetregistry.js.html","title":"Source: composer-runtime/lib/api/assetregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/assetregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('AssetRegistry'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getAssetRegistry getAssetRegistry} * method instead. * * @class AssetRegistry * @classdesc An asset registry manages a set of assets. * @memberof module:composer-runtime * @public */ /** * A class that represents an asset registry in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class AssetRegistry { /** * Constructor. * @param {Registry} registry The registry to use. * @private */ constructor(registry) { const method = 'constructor'; LOG.entry(method, registry); /** * Get a list of all of the existing assets in this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get all of the vehicles in the vehicle asset registry. * return assetRegistry.getAll(); * }) * .then(function (vehicles) { * // Process the array of vehicle objects. * vehicles.forEach(function (vehicle) { * console.log(vehicle.vehicleId); * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#getAll * @return {Promise} A promise. The promise is resolved with an array of * {@link Resource} instances representing all of the assets stored in this * asset registry. If the asset registry does not exist, or the current * user does not have access to the asset registry, then the promise will * be rejected with an error that describes the problem. */ this.getAll = function getAll() { return registry.getAll(); }; /** * Get the specified asset in this asset registry using the unique identifier * of the asset. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the specific vehicle from the vehicle asset registry. * return assetRegistry.get('VEHICLE_1'); * }) * .then(function (vehicle) { * // Process the the vehicle object. * console.log(vehicle.vehicleId); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#get * @param {string} id The ID of the asset. * @return {Promise} A promise. The promise is resolved with a {@link Resource} * instance representing the specified asset in this asset registry. If the * specified asset does not exist, or the current user does not have access * to the specified asset, then the promise will be rejected with an error * that describes the problem. */ this.get = function get(id) { return registry.get(id); }; /** * Determines whether a specific asset exists in this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Determine if the specific vehicle exists in the vehicle asset registry. * return assetRegistry.exists('VEHICLE_1'); * }) * .then(function (exists) { * // Process the the boolean result. * console.log('Vehicle exists', exists); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#exists * @param {string} id The ID of the asset. * @return {Promise} A promise. The promise is resolved with a boolean which * is true if the specified asset exists in this asset registry, and false * if the specified participant does not exist. */ this.exists = function exists(id) { return registry.exists(id); }; /** * Add all of the specified assets to this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Create the first vehicle. * var vehicle1 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); * vehicle1.colour = 'BLUE'; * // Create the second vehicle. * var vehicle2 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_2'); * vehicle2.colour = 'GREEN'; * // Add the vehicles to the vehicle asset registry. * return vehicleAssetRegistry.addAll([vehicle1, vehicle2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#addAll * @param {Resource[]} assets The assets to add to this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been added to this asset registry. If the assets cannot be * added to this asset registry, or if the assets already exist in the * asset registry, then the promise will be rejected with an error * that describes the problem. */ this.addAll = function addAll(assets) { return registry.addAll(assets, { convertResourcesToRelationships: true }); }; /** * Add the specified asset to this asset registry. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Create the vehicle. * var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); * vehicle.colour = 'BLUE'; * // Add the vehicle to the vehicle asset registry. * return vehicleAssetRegistry.add(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#add * @param {Resource} asset The assets to add to this asset registry. * @return {Promise} A promise. The promise is resolved when the asset has * been added to this asset registry. If the asset cannot be added to this * asset registry, or if the asset already exists in the asset registry, * then the promise will be rejected with an error that describes the problem. */ this.add = function add(asset) { return registry.add(asset, { convertResourcesToRelationships: true }); }; /** * Update all of the specified assets in this asset registry. * @example * // The existing vehicles that have come from elsewhere. * var vehicle1; * var vehicle2; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Modify the properties of the first vehicle. * vehicle1.colour = 'PURPLE'; * // Modify the properties of the second vehicle. * vehicle2.colour = 'ORANGE'; * // Update the vehicles in the vehicle asset registry. * return vehicleAssetRegistry.updateAll([vehicle1, vehicle2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#updateAll * @param {Resource[]} assets The assets to update in this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been updated in this asset registry. If the assets cannot be * updated in this asset registry, or if the assets do not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.updateAll = function updateAll(assets) { return registry.updateAll(assets, { convertResourcesToRelationships: true }); }; /** * Update the specified asset in this asset registry. * @example * // The existing vehicle that has come from elsewhere. * var vehicle; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Modify the properties of the vehicle. * vehicle.colour = 'PURPLE'; * // Update the vehicle in the vehicle asset registry. * return vehicleAssetRegistry.update(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#update * @param {Resource} asset The asset to update in this asset registry. * @return {Promise} A promise. The promise is resolved when the asset * have been updated in this asset registry. If the asset cannot be * updated in this asset registry, or if the asset does not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.update = function update(asset) { return registry.update(asset, { convertResourcesToRelationships: true }); }; /** * Remove all of the specified assets from this asset registry. * @example * // The existing vehicles that have come from elsewhere. * var vehicle1; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Remove the vehicles from the vehicle asset registry. Note that * // one vehicle is specified as a vehicle instance, and the other * // vehicle is specified by the ID of the vehicle. * return vehicleAssetRegistry.removeAll([vehicle1, 'VEHICLE_2']); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#removeAll * @param {string[]|Resource[]} assets The assets, or the IDs of the assets, * to remove from this asset registry. * @return {Promise} A promise. The promise is resolved when all of the * assets have been removed from this asset registry. If the assets cannot be * removed from this asset registry, or if the assets do not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.removeAll = function removeAll(assets) { return registry.removeAll(assets); }; /** * Remove the specified asset from this asset registry. * @example * // The existing vehicle that has come from elsewhere. * var vehicle; * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Get the factory for creating new asset instances. * var factory = getFactory(); * // Remove the vehicle from the vehicle asset registry. * return vehicleAssetRegistry.remove(vehicle); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.AssetRegistry#remove * @param {string|Resource} asset The asset, or ID of the asset, to remove * from this asset registry. * @return {Promise} A promise. The promise is resolved when the asset * has been removed from this asset registry. If the asset cannot be * removed from this asset registry, or if the asset does not exist in the * asset registry, then the promise will be rejected with an error that * describes the problem. */ this.remove = function remove(asset) { return registry.remove(asset); }; Object.freeze(this); LOG.exit(method); } } module.exports = AssetRegistry; × Search results Close "},"composer-runtime_lib_container.js.html":{"id":"composer-runtime_lib_container.js.html","title":"Source: composer-runtime/lib/container.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/container.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * A class representing the chaincode container hosting the JavaScript engine. * @protected * @abstract * @memberof module:composer-runtime */ class Container { /** * Get the version of the chaincode container. * @abstract * @return {string} The version of the chaincode container. */ getVersion() { throw new Error('abstract function called'); } /** * Get the logging service provided by the chaincode container. * @abstract * @return {LoggingService} The logging service provided by the chaincode container. */ getLoggingService() { throw new Error('abstract function called'); } } module.exports = Container; × Search results Close "},"composer-runtime_lib_context.js.html":{"id":"composer-runtime_lib_context.js.html","title":"Source: composer-runtime/lib/context.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/context.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AccessController = require('./accesscontroller'); const Api = require('./api'); const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const IdentityManager = require('./identitymanager'); const Logger = require('composer-common').Logger; const LRU = require('lru-cache'); const QueryCompiler = require('./querycompiler'); const QueryExecutor = require('./queryexecutor'); const RegistryManager = require('./registrymanager'); const Resolver = require('./resolver'); const ScriptCompiler = require('./scriptcompiler'); const TransactionLogger = require('./transactionlogger'); const LOG = Logger.getLog('Context'); const businessNetworkCache = LRU(8); const compiledScriptBundleCache = LRU(8); const compiledQueryBundleCache = LRU(8); /** * A class representing the current request being handled by the JavaScript engine. * @protected * @abstract * @memberof module:composer-runtime */ class Context { /** * Store a business network in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. */ static cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition) { const method = 'cacheBusinessNetwork'; LOG.entry(method, businessNetworkHash, businessNetworkDefinition); businessNetworkCache.set(businessNetworkHash, businessNetworkDefinition); LOG.exit(method); } /** * Store a compiled script bundle in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {CompiledScriptBundle} compiledScriptBundle The compiled script bundle. */ static cacheCompiledScriptBundle(businessNetworkHash, compiledScriptBundle) { const method = 'cacheCompiledScriptBundle'; LOG.entry(method, businessNetworkHash, compiledScriptBundle); compiledScriptBundleCache.set(businessNetworkHash, compiledScriptBundle); LOG.exit(method); } /** * Store a compiled query bundle in the cache. * @param {string} businessNetworkHash The hash of the business network definition. * @param {CompiledQueryBundle} compiledQueryBundle The compiled query bundle. */ static cacheCompiledQueryBundle(businessNetworkHash, compiledQueryBundle) { const method = 'cacheCompiledQueryBundle'; LOG.entry(method, businessNetworkHash, compiledQueryBundle); compiledQueryBundleCache.set(businessNetworkHash, compiledQueryBundle); LOG.exit(method); } /** * Constructor. * @param {Engine} engine The chaincode engine that owns this context. */ constructor(engine) { this.engine = engine; this.businessNetworkDefinition = null; this.registryManager = null; this.resolver = null; this.api = null; this.queryExecutor = null; this.identityManager = null; this.participant = null; this.transaction = null; this.accessController = null; this.sysregistries = null; this.sysidentities = null; this.eventNumber = 0; this.scriptCompiler = null; this.compiledScriptBundle = null; this.queryCompiler = null; this.compiledQueryBundle = null; } /** * Load the business network record from the world state. * @return {Promise} A promise that will be resolved with the business network record * when complete, or rejected with an error. */ loadBusinessNetworkRecord() { const method = 'loadBusinessNetworkRecord'; LOG.entry(method); return this.getDataService().getCollection('$sysdata') .then((collection) =&gt; { LOG.debug(method, 'Getting business network archive from the $sysdata collection'); return collection.get('businessnetwork'); }) .then((object) =&gt; { // check if the network has been undeployed first. if is has throw exception. if (object.undeployed){ throw new Error('The business network has been undeployed'); } LOG.exit(object); return object; }); } /** * Load the business network definition. * @param {Object} businessNetworkRecord The business network record. * @return {Promise} A promise that will be resolved with a {@link BusinessNetworkDefinition} * when complete, or rejected with an error. */ loadBusinessNetworkDefinition(businessNetworkRecord) { const method = 'loadBusinessNetworkDefinition'; LOG.entry(method); LOG.debug(method, 'Looking in cache for business network', businessNetworkRecord.hash); let businessNetworkDefinition = businessNetworkCache.get(businessNetworkRecord.hash); if (businessNetworkDefinition) { LOG.debug(method, 'Business network is in cache'); return Promise.resolve(businessNetworkDefinition); } LOG.debug(method, 'Business network is not in cache, loading'); let businessNetworkArchive = Buffer.from(businessNetworkRecord.data, 'base64'); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive) .then((businessNetworkDefinition) =&gt; { Context.cacheBusinessNetwork(businessNetworkRecord.hash, businessNetworkDefinition); LOG.exit(method, businessNetworkDefinition); return businessNetworkDefinition; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Load or compile the compiled script bundle. * @param {Object} businessNetworkRecord The business network record. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. * @return {Promise} A promise that will be resolved with a {@link BusinessNetworkDefinition} * when complete, or rejected with an error. */ loadCompiledScriptBundle(businessNetworkRecord, businessNetworkDefinition) { const method = 'loadCompiledScriptBundle'; LOG.entry(method); LOG.debug(method, 'Looking in cache for compiled script bundle', businessNetworkRecord.hash); let compiledScriptBundle = compiledScriptBundleCache.get(businessNetworkRecord.hash); if (compiledScriptBundle) { LOG.debug(method, 'Compiled script bundle is in cache'); return Promise.resolve(compiledScriptBundle); } LOG.debug(method, 'Compiled script bundle is not in cache, loading'); return Promise.resolve() .then(() =&gt; { let compiledScriptBundle = this.getScriptCompiler().compile(businessNetworkDefinition.getScriptManager()); Context.cacheCompiledScriptBundle(businessNetworkRecord.hash, compiledScriptBundle); LOG.exit(method, compiledScriptBundle); return compiledScriptBundle; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Load or compile the compiled query bundle. * @param {Object} businessNetworkRecord The business network record. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition. * @return {Promise} A promise that will be resolved with a {@link BusinessNetworkDefinition} * when complete, or rejected with an error. */ loadCompiledQueryBundle(businessNetworkRecord, businessNetworkDefinition) { const method = 'loadCompiledQueryBundle'; LOG.entry(method); LOG.debug(method, 'Looking in cache for compiled query bundle', businessNetworkRecord.hash); let compiledQueryBundle = compiledQueryBundleCache.get(businessNetworkRecord.hash); if (compiledQueryBundle) { LOG.debug(method, 'Compiled query bundle is in cache'); return Promise.resolve(compiledQueryBundle); } LOG.debug(method, 'Compiled query bundle is not in cache, loading'); return Promise.resolve() .then(() =&gt; { let compiledQueryBundle = this.getQueryCompiler().compile(businessNetworkDefinition.getQueryManager()); Context.cacheCompiledQueryBundle(businessNetworkRecord.hash, compiledQueryBundle); LOG.exit(method, compiledQueryBundle); return compiledQueryBundle; }) .catch((error) =&gt; { LOG.error(method, error); throw error; }); } /** * Load the current participant. * @return {Promise} A promise that will be resolved with a {@link Resource} * when complete, or rejected with an error. */ loadCurrentParticipant() { const method = 'loadCurrentParticipant'; LOG.entry(method); let currentUserID = this.getIdentityService().getCurrentUserID(); LOG.debug(method, 'Got current user ID', currentUserID); if (currentUserID) { return this.getIdentityManager().getParticipant(currentUserID) .then((participant) =&gt; { LOG.debug(method, 'Found current participant', participant.getFullyQualifiedIdentifier()); LOG.exit(method, participant); return participant; }) .catch((error) =&gt; { LOG.error(method, 'Could not find current participant', error); throw new Error(`Could not determine the participant for identity '${currentUserID}'. The identity may be invalid or may have been revoked.`); }); } else { // TODO: this is temporary whilst we migrate to requiring all // users to have identities that are mapped to participants. LOG.debug(method, 'Could not determine current user ID'); LOG.exit(method, null); return Promise.resolve(null); } } /** * Get the business network definition to use. * @param {Object} [options] The options to use. * @param {BusinessNetworkDefinition} [options.businessNetworkDefinition] The business network definition to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findBusinessNetworkDefinition(options) { const method = 'findBusinessNetworkDefinition'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { if (options.businessNetworkDefinition) { LOG.debug(method, 'Business network definition already specified'); return options.businessNetworkDefinition; } else { LOG.debug(method, 'Business network definition not specified, loading from world state'); return this.loadBusinessNetworkRecord() .then((businessNetworkRecord) =&gt; { return this.loadBusinessNetworkDefinition(businessNetworkRecord); }); } }) .then((businessNetworkDefinition) =&gt; { LOG.exit(method, businessNetworkDefinition); return businessNetworkDefinition; }); } /** * Get the compiled script bundle to use. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition to use. * @param {Object} [options] The options to use. * @param {CompiledScriptBundle} [options.compiledScriptBundle] The business network definition to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findCompiledScriptBundle(businessNetworkDefinition, options) { const method = 'findCompiledScriptBundle'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { if (options.compiledScriptBundle) { LOG.debug(method, 'Compiled script bundle already specified'); return options.compiledScriptBundle; } else { LOG.debug(method, 'Compiled script bundle not specified, loading from world state'); return this.loadBusinessNetworkRecord() .then((businessNetworkRecord) =&gt; { return this.loadCompiledScriptBundle(businessNetworkRecord, businessNetworkDefinition); }); } }) .then((compiledScriptBundle) =&gt; { LOG.exit(method, compiledScriptBundle); return compiledScriptBundle; }); } /** * Get the compiled query bundle to use. * @param {BusinessNetworkDefinition} businessNetworkDefinition The business network definition to use. * @param {Object} [options] The options to use. * @param {CompiledQueryBundle} [options.compiledQueryBundle] The business network definition to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findCompiledQueryBundle(businessNetworkDefinition, options) { const method = 'findCompiledQueryBundle'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { if (options.compiledQueryBundle) { LOG.debug(method, 'Compiled query bundle already specified'); return options.compiledQueryBundle; } else { LOG.debug(method, 'Compiled query bundle not specified, loading from world state'); return this.loadBusinessNetworkRecord() .then((businessNetworkRecord) =&gt; { return this.loadCompiledQueryBundle(businessNetworkRecord, businessNetworkDefinition); }); } }) .then((compiledQueryBundle) =&gt; { LOG.exit(method, compiledQueryBundle); return compiledQueryBundle; }); } /** * Initialize the context for use. * @param {Object} [options] The options to use. * @param {BusinessNetworkDefinition} [options.businessNetworkDefinition] The business network definition to use. * @param {CompiledScriptBundle} [options.compiledScriptBundle] The compiled script bundle to use. * @param {boolean} [options.reinitialize] Set to true if being reinitialized as a result of an upgrade to the * business network, falsey value if not. * @param {DataCollection} [options.sysregistries] The system registries collection to use. * @param {DataCollection} [options.sysidentities] The system identities collection to use. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ initialize(options) { const method = 'initialize'; LOG.entry(method, options); options = options || {}; return Promise.resolve() .then(() =&gt; { return this.findBusinessNetworkDefinition(options); }) .then((businessNetworkDefinition) =&gt; { LOG.debug(method, 'Got business network archive'); this.businessNetworkDefinition = businessNetworkDefinition; return this.findCompiledScriptBundle(this.businessNetworkDefinition, options); }) .then((compiledScriptBundle) =&gt; { LOG.debug(method, 'Got compiled script bundle'); this.compiledScriptBundle = compiledScriptBundle; return this.findCompiledQueryBundle(this.businessNetworkDefinition, options); }) .then((compiledQueryBundle) =&gt; { LOG.debug(method, 'Got compiled query bundle'); this.compiledQueryBundle = compiledQueryBundle; LOG.debug(method, 'Loading sysregistries collection', options.sysregistries); if (options.sysregistries) { this.sysregistries = options.sysregistries; } else { return this.getDataService().getCollection('$sysregistries') .then((sysregistries) =&gt; { this.sysregistries = sysregistries; }); } }) .then(() =&gt; { LOG.debug(method, 'Loading sysidentities collection', options.sysidentities); if (options.sysidentities) { this.sysidentities = options.sysidentities; } else { return this.getDataService().getCollection('$sysidentities') .then((sysidentities) =&gt; { this.sysidentities = sysidentities; }); } }) .then(() =&gt; { LOG.debug(method, 'Loading current participant'); return this.loadCurrentParticipant(); }) .then((participant) =&gt; { if (!options.reinitialize) { LOG.debug(method, 'Setting current participant', participant); this.setParticipant(participant); } else { // We don't want to change the participant in the middle of a update. LOG.debug(method, 'Reinitializing, not setting current participant', participant); } }) .then(() =&gt; { LOG.exit(method); }); } /** * Get all of the services provided by the chaincode container. * @return {Service[]} All of the services provided by the chaincode container. */ getServices() { return [ this.getDataService(), this.getEventService(), this.getIdentityService(), this.getHTTPService() ]; } /** * Get the data service provided by the chaincode container. * @abstract * @return {DataService} The data service provided by the chaincode container. */ getDataService() { throw new Error('abstract function called'); } /** * Get the identity service provided by the chaincode container. * @abstract * @return {IdentityService} The identity service provided by the chaincode container. */ getIdentityService() { throw new Error('abstract function called'); } /** * Get the http service provided by the chaincode container. * @abstract * @return {HTTPService} The http service provided by the chaincode container. */ getHTTPService() { throw new Error('abstract function called'); } /** * Get the event service provided by the chaincode container. * @abstract * @return {EventService} The event service provided by the chaincode container. */ getEventService() { throw new Error('abstract function called'); } /** * Get the model manager. * @return {ModelManager} The model manager. */ getModelManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getModelManager(); } /** * Get the script manager. * @return {ScriptManager} The script manager. */ getScriptManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getScriptManager(); } /** * Get the ACL manager. * @return {AclManager} The ACL manager. */ getAclManager() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getAclManager(); } /** * Get the factory. * @return {Factory} The factory. */ getFactory() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getFactory(); } /** * Get the serializer. * @return {Serializer} The serializer. */ getSerializer() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getSerializer(); } /** * Get the introspector. * @return {Introspector} The serializer. */ getIntrospector() { if (!this.businessNetworkDefinition) { throw new Error('must call initialize before calling this function'); } return this.businessNetworkDefinition.getIntrospector(); } /** * Get the registry manager. * @return {RegistryManager} The registry manager. */ getRegistryManager() { if (!this.registryManager) { this.registryManager = new RegistryManager(this.getDataService(), this.getIntrospector(), this.getSerializer(), this.getAccessController(), this.getSystemRegistries()); } return this.registryManager; } /** * Get the resolver. * @return {Resolver} The resolver. */ getResolver() { if (!this.resolver) { this.resolver = new Resolver(this.getIntrospector(), this.getRegistryManager()); } return this.resolver; } /** * Get the API. * @return {Api} The API. */ getApi() { if (!this.api) { this.api = new Api(this); } return this.api; } /** * Get the query executor. * @return {QueryExecutor} The query executor. */ getQueryExecutor() { if (!this.queryExecutor) { this.queryExecutor = new QueryExecutor(this.getResolver()); } return this.queryExecutor; } /** * Get the identity manager. * @return {IdentityManager} The identity manager. */ getIdentityManager() { if (!this.identityManager) { this.identityManager = new IdentityManager(this.getDataService(), this.getRegistryManager(), this.getSystemIdentities()); } return this.identityManager; } /** * Get the current participant. * @return {Resource} the current participant. */ getParticipant() { return this.participant; } /** * Set the current participant. * @param {Resource} participant the current participant. */ setParticipant(participant) { if (this.participant) { throw new Error('A current participant has already been specified'); } this.participant = participant; this.getAccessController().setParticipant(participant); } /** * Get the current transaction. * @return {Resource} the current transaction. */ getTransaction() { return this.transaction; } /** * Set the current transaction. * @param {Resource} transaction the current transaction. */ setTransaction(transaction) { if (this.transaction) { throw new Error('A current transaction has already been specified'); } this.transaction = transaction; this.transactionLogger = new TransactionLogger(this.transaction, this.getRegistryManager(), this.getSerializer()); this.getAccessController().setTransaction(transaction); } /** * Get the access controller. * @return {AccessController} The access controller. */ getAccessController() { if (!this.accessController) { this.accessController = new AccessController(this.getAclManager()); } return this.accessController; } /** * Get the system registries collection. * @return {DataCollection} The system registries collection. */ getSystemRegistries() { if (!this.sysregistries) { throw new Error('must call initialize before calling this function'); } return this.sysregistries; } /** * Get the system identities collection. * @return {DataCollection} The system registries collection. */ getSystemIdentities() { if (!this.sysidentities) { throw new Error('must call initialize before calling this function'); } return this.sysidentities; } /** * Get the next event number * @return {integer} the event number. */ getEventNumber() { return this.eventNumber; } /** * Incrememnt the event number by 1 * @return {integer} the event number. */ incrementEventNumber() { return this.eventNumber++; } /** * Get the script compiler. * @return {ScriptCompiler} scriptCompiler The script compiler. */ getScriptCompiler() { if (!this.scriptCompiler) { this.scriptCompiler = new ScriptCompiler(); } return this.scriptCompiler; } /** * Get the compiled script bundle. * @return {CompiledScriptBundle} compiledScriptBundle The compiled script bundle. */ getCompiledScriptBundle() { return this.compiledScriptBundle; } /** * Get the query compiler. * @return {QueryCompiler} queryCompiler The query compiler. */ getQueryCompiler() { if (!this.queryCompiler) { this.queryCompiler = new QueryCompiler(); } return this.queryCompiler; } /** * Get the compiled query bundle. * @return {CompiledScriptBundle} compiledQueryBundle The compiled query bundle. */ getCompiledQueryBundle() { return this.compiledQueryBundle; } /** * Called at the start of a transaction. * @param {boolean} readOnly Is the transaction read-only? * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionStart(readOnly) { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionStart(readOnly); }); }, Promise.resolve()); } /** * Called when a transaction is preparing to commit. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionPrepare() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionPrepare(); }); }, Promise.resolve()); } /** * Called when a transaction is rolling back. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionRollback() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionRollback(); }); }, Promise.resolve()); } /** * Called when a transaction is committing. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionCommit() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionCommit(); }); }, Promise.resolve()); } /** * Called at the end of a transaction. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionEnd() { const services = this.getServices(); return services.reduce((promise, service) =&gt; { return promise.then(() =&gt; { return service.transactionEnd(); }); }, Promise.resolve()); } } module.exports = Context; × Search results Close "},"composer-runtime_lib_datacollection.js.html":{"id":"composer-runtime_lib_datacollection.js.html","title":"Source: composer-runtime/lib/datacollection.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/datacollection.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class representing a data collection provided by a {@link DataService}. * @protected * @abstract * @memberof module:composer-runtime */ class DataCollection { /** * Constructor. * @param {DataService} dataService The owning data service. */ constructor(dataService) { this.dataService = dataService; } /** * Get all of the objects in this collection. * @abstract * @return {Promise} A promise that will be resolved with an array of objects, * or rejected with an error. */ getAll() { return new Promise((resolve, reject) =&gt; { this._getAll((error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback getAllCallback * @protected * @param {Error} error The error if any. * @param {Object[]} objects The objects in the collection. */ /** * Get all of the objects in this collection. * @abstract * @private * @param {getAllCallback} callback The callback function to call when complete. */ _getAll(callback) { throw new Error('abstract function called'); } /** * Get the specified object in this collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved with an object, or rejected * with an error. */ get(id) { return new Promise((resolve, reject) =&gt; { this._get(id, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback getCallback * @protected * @param {Error} error The error if any. * @param {Object} object The object in the collection. */ /** * Get the specified object in this collection. * @abstract * @private * @param {string} id The ID of the object. * @param {getCallback} callback The callback function to call when complete. */ _get(id, callback) { throw new Error('abstract function called'); } /** * Check to see if the specified object exists in this collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved with an boolean which will * be true if the specified object exists in this collection, or rejected with * an error. */ exists(id) { return new Promise((resolve, reject) =&gt; { this._exists(id, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback existsCallback * @protected * @param {Error} error The error if any. * @param {boolean} exists Whether or not the object exists in the collection. */ /** * Check to see if the specified object exists in this collection. * @abstract * @private * @param {string} id The ID of the object. * @param {existsCallback} callback The callback function to call when complete. */ _exists(id, callback) { throw new Error('abstract function called'); } /** * Add an object to the collection. * @abstract * @param {string} id The ID of the object. * @param {Object} object The object. * @param {boolean} force Whether to force creation without checking it already exists. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ add(id, object, force) { force = !!force; return new Promise((resolve, reject) =&gt; { this._add(id, object, force, (error, result) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback addCallback * @protected * @param {Error} error The error if any. */ /** * Add an object to the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {Object} object The object. * @param {boolean} force don't check for existence, force it * @param {addCallback} callback The callback function to call when complete. */ _add(id, object, force, callback) { throw new Error('abstract function called'); } /** * Add an object to the collection. * @abstract * @param {string} id The ID of the object. * @param {Object} object The object. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ update(id, object) { return new Promise((resolve, reject) =&gt; { this._update(id, object, (error, result) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback updateCallback * @protected * @param {Error} error The error if any. */ /** * Update an object in the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {Object} object The object. * @param {updateCallback} callback The callback function to call when complete. */ _update(id, object, callback) { throw new Error('abstract function called'); } /** * Remove an object from the collection. * @abstract * @param {string} id The ID of the object. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ remove(id) { return new Promise((resolve, reject) =&gt; { this._remove(id, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback removeCallback * @protected * @param {Error} error The error if any. */ /** * Remove an object from the collection. * @abstract * @private * @param {string} id The ID of the object. * @param {removeCallback} callback The callback function to call when complete. */ _remove(id, callback) { throw new Error('abstract function called'); } } module.exports = DataCollection; × Search results Close "},"composer-runtime_lib_dataservice.js.html":{"id":"composer-runtime_lib_dataservice.js.html","title":"Source: composer-runtime/lib/dataservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/dataservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Service = require('./service'); const LOG = Logger.getLog('DataService'); /** * Base class representing the data service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class DataService extends Service { /** * Create a collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @param {boolean} force Whether to force creation without checking it already exists. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ createCollection(id, force) { force = !!force; return new Promise((resolve, reject) =&gt; { this._createCollection(id, force, (error, dataCollection) =&gt; { if (error) { return reject(error); } return resolve(dataCollection); }); }); } /** * @callback createCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Create a collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {force} force force creation, don't check for existence 1st * @param {createCollectionCallback} callback The callback function to call when complete. */ _createCollection(id, force, callback) { throw new Error('abstract function called'); } /** * Delete a collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ deleteCollection(id) { return new Promise((resolve, reject) =&gt; { this._deleteCollection(id, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback deleteCollectionCallback * @protected * @param {Error} error The error if any. */ /** * Delete a collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {deleteCollectionCallback} callback The callback function to call when complete. */ _deleteCollection(id, callback) { throw new Error('abstract function called'); } /** * Get the collection with the specified ID. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ getCollection(id) { return new Promise((resolve, reject) =&gt; { this._getCollection(id, (error, dataCollection) =&gt; { if (error) { return reject(error); } return resolve(dataCollection); }); }); } /** * @callback getCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Get the collection with the specified ID. * @abstract * @private * @param {string} id The ID of the collection. * @param {getCollectionCallback} callback The callback function to call when complete. */ _getCollection(id, callback) { throw new Error('abstract function called'); } /** * Determine whether the collection with the specified ID exists. * @abstract * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a boolean * indicating whether the collection exists. */ existsCollection(id) { return new Promise((resolve, reject) =&gt; { this._existsCollection(id, (error, exists) =&gt; { if (error) { return reject(error); } return resolve(exists); }); }); } /** * @callback existsCollectionCallback * @protected * @param {Error} error The error if any. * @param {DataCollection} dataCollection The data collection. */ /** * Determine whether the collection with the specified ID exists. * @abstract * @private * @param {string} id The ID of the collection. * @param {existsCollectionCallback} callback The callback function to call when complete. */ _existsCollection(id, callback) { throw new Error('abstract function called'); } /** * Execute a query across all objects stored in all collections, using a query * string that is dependent on the current Blockchain platform. * @abstract * @param {string} queryString The query string for the current Blockchain platform. * @return {Promise} A promise that will be resolved with an array of objects * when complete, or rejected with an error. */ executeQuery(queryString) { return new Promise((resolve, reject) =&gt; { this._executeQuery(queryString, (error, result) =&gt; { if (error) { return reject(error); } return resolve(result); }); }); } /** * @callback executeQueryCallback * @protected * @param {Error} error The error if any. * @param {Object[]} objects The objects. */ /** * Execute a query across all objects stored in all collections, using a query * string that is dependent on the current Blockchain platform. * @abstract * @param {string} queryString The query string for the current Blockchain platform. * @param {executeQueryCallback} callback The callback function to call when complete. */ _executeQuery(queryString, callback) { throw new Error('abstract function called'); } /** * Check to see if the collection with the specified ID exists, and if not create it. * @param {string} id The ID of the collection. * @return {Promise} A promise that will be resolved with a {@link DataCollection} * when complete, or rejected with an error. */ ensureCollection(id) { const method = 'ensureCollection'; LOG.entry(method, id); return this.getCollection(id) .catch((error) =&gt; { LOG.debug(method, 'The collection does not exist, creating'); return this.createCollection(id); }) .then((collection) =&gt; { LOG.exit(method, collection); return collection; }); } } module.exports = DataService; × Search results Close "},"composer-runtime_lib_engine.js.html":{"id":"composer-runtime_lib_engine.js.html","title":"Source: composer-runtime/lib/engine.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const Context = require('./context'); const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('Engine'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class Engine { /** * Constructor. * @param {Container} container The chaincode container hosting this engine. */ constructor(container) { this.container = container; this.installLogger(); const method = 'constructor'; LOG.entry(method); LOG.exit(method); } /** * Get the chaincode container hosting this engine. * @return {Container} The chaincode container hosting this engine. */ getContainer() { return this.container; } /** * Install the runtime logger into the common module. */ installLogger() { let loggingService = this.container.getLoggingService(); let loggingProxy = { log: (level, method, msg, args) =&gt; { args = args || []; let formattedArguments = args.map((arg) =&gt; { return String(arg); }).join(', '); switch (level) { case 'debug': return loggingService.logDebug(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'warn': return loggingService.logWarning(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'info': return loggingService.logInfo(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'verbose': return loggingService.logDebug(util.format('@JS : %s %s %s', method, msg, formattedArguments)); case 'error': return loggingService.logError(util.format('@JS : %s %s %s', method, msg, formattedArguments)); } } }; Logger.setFunctionalLogger(loggingProxy); Logger._envDebug = 'composer:*'; } /** * Handle an initialisation (deploy) request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ init(context, fcn, args) { const method = 'init'; LOG.entry(method); LOG.entry(method, context, fcn, args); if (fcn !== 'init') { throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } else if (args.length !== 1) { throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'init', ['businessNetworkArchive'])); } let dataService = context.getDataService(); let businessNetworkBase64, businessNetworkHash, businessNetworkRecord, businessNetworkDefinition, compiledScriptBundle, compiledQueryBundle; let sysregistries, sysidentities; return Promise.resolve() .then(() =&gt; { // Start the transaction. return context.transactionStart(false); }) .then(() =&gt; { // Load, validate, and hash the business network definition. LOG.debug(method, 'Loading business network definition'); businessNetworkBase64 = args[0]; let businessNetworkArchive = Buffer.from(businessNetworkBase64, 'base64'); let sha256 = createHash('sha256'); businessNetworkHash = sha256.update(businessNetworkBase64, 'utf8').digest('hex'); LOG.debug(method, 'Calculated business network definition hash', businessNetworkHash); // Create the business network record. businessNetworkRecord = { data: businessNetworkBase64, hash: businessNetworkHash }; // Load the business network. return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetworkDefinition_) =&gt; { // Cache the business network. businessNetworkDefinition = businessNetworkDefinition_; LOG.debug(method, 'Loaded business network definition, storing in cache'); Context.cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition); // Cache the compiled script bundle. compiledScriptBundle = context.getScriptCompiler().compile(businessNetworkDefinition.getScriptManager()); LOG.debug(method, 'Loaded compiled script bundle, storing in cache'); Context.cacheCompiledScriptBundle(businessNetworkHash, compiledScriptBundle); // Cache the compiled query bundle. compiledQueryBundle = context.getQueryCompiler().compile(businessNetworkDefinition.getQueryManager()); LOG.debug(method, 'Loaded compiled query bundle, storing in cache'); Context.cacheCompiledQueryBundle(businessNetworkHash, compiledQueryBundle); // Get the sysdata collection where the business network definition is stored. LOG.debug(method, 'Loaded business network definition, storing in $sysdata collection'); return dataService.ensureCollection('$sysdata'); }) .then((sysdata) =&gt; { // Add the business network definition to the sysdata collection. return sysdata.add('businessnetwork', businessNetworkRecord); }) .then(() =&gt; { // Ensure that the system registries collection exists. LOG.debug(method, 'Ensuring that sysregistries collection exists'); return dataService.ensureCollection('$sysregistries') .then((sysregistries_) =&gt; { sysregistries = sysregistries_; }); }) .then(() =&gt; { // Ensure that the system identities collection exists. LOG.debug(method, 'Ensuring that sysidentities collection exists'); return dataService.ensureCollection('$sysidentities') .then((sysidentities_) =&gt; { sysidentities = sysidentities_; }); }) .then(() =&gt; { // Initialize the context. LOG.debug(method, 'Initializing context'); return context.initialize({ businessNetworkDefinition: businessNetworkDefinition, compiledScriptBundle: compiledScriptBundle, compiledQueryBundle: compiledQueryBundle, sysregistries: sysregistries, sysidentities: sysidentities }); }) .then(() =&gt; { // Create all the default registries for each asset and participant type. LOG.debug(method, 'Creating default registries'); let registryManager = context.getRegistryManager(); return registryManager.createDefaults(); }) .then(() =&gt; { // Create the default transaction registry if it does not exist. let registryManager = context.getRegistryManager(); return registryManager.ensure('Transaction', 'default', 'Default Transaction Registry'); }) .then(() =&gt; { return context.transactionPrepare() .then(() =&gt; { return context.transactionCommit(); }) .then(() =&gt; { return context.transactionEnd(); }); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); return context.transactionRollback() .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { throw error; }); }) .then(() =&gt; { LOG.exit(method); }); } /** * Handle an initialisation (deploy) request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _init(context, fcn, args, callback) { this.init(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle an invoke request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ invoke(context, fcn, args) { const method = 'invoke'; LOG.entry(method, context, fcn, args); if (this[fcn]) { LOG.debug(method, 'Initializing context'); return context.initialize() .then(() =&gt; { return context.transactionStart(false); }) .then(() =&gt; { LOG.debug(method, 'Calling engine function', fcn); return this[fcn](context, args); }) .then((result) =&gt; { return context.transactionPrepare() .then(() =&gt; { return context.transactionCommit(); }) .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { return result; }); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); return context.transactionRollback() .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { throw error; }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } else { LOG.error(method, 'Unsupported function', fcn, args); throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } } /** * Handle an invoke request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _invoke(context, fcn, args, callback) { this.invoke(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle a query request. * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ query(context, fcn, args) { const method = 'query'; LOG.entry(method, context, fcn, args); if (this[fcn]) { LOG.debug(method, 'Initializing context'); return context.initialize() .then(() =&gt; { return context.transactionStart(true); }) .then(() =&gt; { LOG.debug(method, 'Calling engine function', fcn); return this[fcn](context, args); }) .then((result) =&gt; { return context.transactionPrepare() .then(() =&gt; { return context.transactionCommit(); }) .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { return result; }); }) .catch((error) =&gt; { LOG.error(method, 'Caught error, rethrowing', error); return context.transactionRollback() .then(() =&gt; { return context.transactionEnd(); }) .then(() =&gt; { throw error; }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } else { LOG.error(method, 'Unsupported function', fcn, args); throw new Error(util.format('Unsupported function &quot;%s&quot; with arguments &quot;%j&quot;', fcn, args)); } } /** * Handle a query request. * @private * @param {Context} context The request context. * @param {string} fcn The name of the chaincode function to invoke. * @param {string[]} args The arguments to pass to the chaincode function. * @param {function} callback The callback function to call when complete. */ _query(context, fcn, args, callback) { this.query(context, fcn, args) .then((result) =&gt; { callback(null, result); }) .catch((error) =&gt; { callback(error, null); }); } /** * Handle a ping request. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ ping(context, args) { const method = 'ping'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'ping', [])); } let participantFQI = null; let participant = context.getParticipant(); if (participant) { participantFQI = participant.getFullyQualifiedIdentifier(); } let result = { version: this.container.getVersion(), participant: participantFQI }; LOG.exit(method, result); return Promise.resolve(result); } } /** * Add all of the methods of the source class to the engine class. * @private * @param {Object} sourceClass The source class to copy methods from. */ function mixin(sourceClass) { Object.getOwnPropertyNames(sourceClass.prototype).forEach((method) =&gt; { if (method !== 'constructor') { Engine.prototype[method] = sourceClass.prototype[method]; } }); } mixin(require('./engine.businessnetworks')); mixin(require('./engine.identities')); mixin(require('./engine.queries')); mixin(require('./engine.registries')); mixin(require('./engine.resources')); mixin(require('./engine.transactions')); module.exports = Engine; × Search results Close "},"composer-runtime_lib_engine.businessnetworks.js.html":{"id":"composer-runtime_lib_engine.businessnetworks.js.html","title":"Source: composer-runtime/lib/engine.businessnetworks.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.businessnetworks.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const BusinessNetworkDefinition = require('composer-common').BusinessNetworkDefinition; const Context = require('./context'); const createHash = require('sha.js'); const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineBusinessNetworks'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineBusinessNetworks { /** * Get the business network archive. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getBusinessNetwork(context, args) { const method = 'getBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getBusinessNetwork', [])); } let dataService = context.getDataService(); return dataService.getCollection('$sysdata') .then((sysdata) =&gt; { return sysdata.get('businessnetwork'); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Undeploy the business network; * Doesn't actually undeploy the nework but merely puts it beyond use. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ undeployBusinessNetwork(context, args){ const method = 'undeployBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, method, [])); } let dataService = context.getDataService(); let sysdata; return dataService.getCollection('$sysdata') .then((sysdata_) =&gt; { sysdata = sysdata_; // Validate the business network archive and store it. return sysdata.get('businessnetwork'); }) .then((businessNetwork) =&gt; { businessNetwork.undeployed = true; return sysdata.update('businessnetwork', businessNetwork); }) .then(() =&gt; { LOG.exit(method); }); } /** * Update the business network archive. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateBusinessNetwork(context, args) { const method = 'updateBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'updateBusinessNetwork', ['businessNetworkArchive'])); } let dataService = context.getDataService(); let businessNetworkBase64, businessNetworkHash, businessNetworkDefinition, compiledScriptBundle, compiledQueryBundle; return Promise.resolve() .then(() =&gt; { // Load, validate, and hash the business network definition. LOG.debug(method, 'Loading business network definition'); businessNetworkBase64 = args[0]; let businessNetworkArchive = Buffer.from(businessNetworkBase64, 'base64'); let sha256 = createHash('sha256'); businessNetworkHash = sha256.update(businessNetworkBase64, 'utf8').digest('hex'); LOG.debug(method, 'Calculated business network definition hash', businessNetworkHash); return BusinessNetworkDefinition.fromArchive(businessNetworkArchive); }) .then((businessNetworkDefinition_) =&gt; { // Cache the business network. businessNetworkDefinition = businessNetworkDefinition_; LOG.debug(method, 'Loaded business network definition, storing in cache'); Context.cacheBusinessNetwork(businessNetworkHash, businessNetworkDefinition); // Cache the compiled script bundle. compiledScriptBundle = context.getScriptCompiler().compile(businessNetworkDefinition.getScriptManager()); LOG.debug(method, 'Loaded compiled script bundle, storing in cache'); Context.cacheCompiledScriptBundle(businessNetworkHash, compiledScriptBundle); // Cache the compiled query bundle. compiledQueryBundle = context.getQueryCompiler().compile(businessNetworkDefinition.getQueryManager()); LOG.debug(method, 'Loaded compiled query bundle, storing in cache'); Context.cacheCompiledQueryBundle(businessNetworkHash, compiledQueryBundle); // Get the sysdata collection where the business network definition is stored. LOG.debug(method, 'Loaded business network definition, storing in $sysdata collection'); return dataService.getCollection('$sysdata'); }) .then((sysdata) =&gt; { // Update the business network definition in the sysdata collection. return sysdata.update('businessnetwork', { data: businessNetworkBase64, hash: businessNetworkHash }); }) .then(() =&gt; { // Reinitialize the context to reload the business network. LOG.debug(method, 'Reinitializing context'); return context.initialize({ businessNetworkDefinition: businessNetworkDefinition, compiledScriptBundle: compiledScriptBundle, compiledQueryBundle: compiledQueryBundle, reinitialize: true }); }) .then(() =&gt; { // Create all other default registries. LOG.debug(method, 'Creating default registries'); let registryManager = context.getRegistryManager(); return registryManager.createDefaults(); }) .then(() =&gt; { LOG.exit(method); }); } /** * Reset the business network by clearing all data. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resetBusinessNetwork(context, args) { const method = 'resetBusinessNetwork'; LOG.entry(method, context, args); if (args.length !== 0) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resetBusinessNetwork', [])); } let dataService = context.getDataService(); return dataService.getCollection('$sysregistries') .then((sysregistries) =&gt; { return sysregistries.getAll() .then((registries) =&gt; { return registries.reduce((cur, next) =&gt; { return cur.then(() =&gt; { let registryType = next.type; let registryId = next.id; LOG.debug(method, 'Deleting collection', registryType, registryId); return dataService.deleteCollection(registryType + ':' + registryId) .then(() =&gt; { LOG.debug(method, 'Deleting record of collection from $sysregistries', registryType, registryId); return sysregistries.remove(registryType + ':' + registryId); }); }); }, Promise.resolve()); }); }) .then(() =&gt; { // Create the default transaction registry as it won't exist // in v1.0 if we queried it's existence it would still be there but // we know it isn't really. let registryManager = context.getRegistryManager(); return registryManager.add('Transaction', 'default', 'Default Transaction Registry', true); }) .then(() =&gt; { // Create all other default registries. LOG.debug(method, 'Creating default registries'); let registryManager = context.getRegistryManager(); // force creation of defaults as we know the don't exist return registryManager.createDefaults(true); }) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineBusinessNetworks; × Search results Close "},"composer-runtime_lib_engine.identities.js.html":{"id":"composer-runtime_lib_engine.identities.js.html","title":"Source: composer-runtime/lib/engine.identities.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.identities.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineIdentities'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineIdentities { /** * Add a mapping from the specified identity, or user ID, to the specified * participant. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addParticipantIdentity(context, args) { const method = 'addParticipantIdentity'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addParticipantIdentity', ['participantId', 'userId'])); } let participantId = args[0]; let userId = args[1]; let identityManager = context.getIdentityManager(); return identityManager.addIdentityMapping(participantId, userId) .then(() =&gt; { LOG.exit(method); }); } /** * Remove any mapping for the specified identity, or user ID. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeIdentity(context, args) { const method = 'removeIdentity'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'removeIdentity', ['userId'])); } let userId = args[0]; let identityManager = context.getIdentityManager(); return identityManager.removeIdentityMapping(userId) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineIdentities; × Search results Close "},"composer-runtime_lib_engine.queries.js.html":{"id":"composer-runtime_lib_engine.queries.js.html","title":"Source: composer-runtime/lib/engine.queries.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.queries.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Registry = require('./registry'); const util = require('util'); const LOG = Logger.getLog('EngineQueries'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineQueries { /** * Execute a query. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ executeQuery(context, args) { const method = 'executeQuery'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'executeQuery', ['queryType', 'query', 'parameters'])); } // Process the parameters. const queryType = args[0], query = args[1], parametersAsJSON = args[2]; LOG.debug(method, 'queryType', queryType); // Validate the query type. if (queryType !== 'build' &amp;&amp; queryType !== 'named') { throw new Error(util.format('Invalid argument &quot;queryType&quot; with value &quot;%s&quot;, expecting &quot;build&quot; or &quot;named&quot;', [queryType])); } // Build the query if necessary. let identifier; if (queryType === 'build') { identifier = context.getCompiledQueryBundle().buildQuery(query); } else { identifier = query; } // Parse the parameters. const parameters = JSON.parse(parametersAsJSON); // Execute the query. const dataService = context.getDataService(); const serializer = context.getSerializer(); const accessController = context.getAccessController(); return context.getCompiledQueryBundle().execute(dataService, identifier, parameters) .then((objects) =&gt; { const resources = objects.map((object) =&gt; { object = Registry.removeInternalProperties(object); return serializer.fromJSON(object); }).filter((resource) =&gt; { try { accessController.check(resource, 'READ'); return true; } catch (e) { return false; } }).map((resource) =&gt; { return serializer.toJSON(resource); }); LOG.exit(method, resources); return resources; }); } } module.exports = EngineQueries; × Search results Close "},"composer-runtime_lib_engine.registries.js.html":{"id":"composer-runtime_lib_engine.registries.js.html","title":"Source: composer-runtime/lib/engine.registries.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.registries.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineRegistries'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineRegistries { /** * Get all registries. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getAllRegistries(context, args) { const method = 'getAllRegistries'; LOG.entry(method, context, args); if (args.length !== 1) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getAllRegistries', ['registryType'])); } let registryType = args[0]; return context.getRegistryManager().getAll(registryType) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getRegistry(context, args) { const method = 'getRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Determine whether an asset registry exists. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved with a boolean indicating * whether the asset registry exists. */ existsRegistry(context, args) { const method = 'existsRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'existsRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().exists(registryType, registryId) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Add a new registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addRegistry(context, args) { const method = 'addRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addRegistry', ['registryType', 'registryId', 'registryName'])); } let registryType = args[0]; let registryId = args[1]; let registryName = args[2]; return context.getRegistryManager().add(registryType, registryId, registryName) .then(() =&gt; { LOG.exit(method); }); } } module.exports = EngineRegistries; × Search results Close "},"composer-runtime_lib_engine.resources.js.html":{"id":"composer-runtime_lib_engine.resources.js.html","title":"Source: composer-runtime/lib/engine.resources.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.resources.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineResources'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineResources { /** * Get all resources in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getAllResourcesInRegistry(context, args) { const method = 'getAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getAllResourcesInRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return context.getSerializer().toJSON(resource); }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified resource in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ getResourceInRegistry(context, args) { const method = 'getResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'getResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.get(resourceId); }) .then((resource) =&gt; { return context.getSerializer().toJSON(resource); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Determine whether the specified resource exists in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved with a boolean indicating whether * the resource exists in the registry. */ existsResourceInRegistry(context, args) { const method = 'existsResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'existsResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.exists(resourceId); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Add an array of resources to the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addAllResourcesToRegistry(context, args) { const method = 'addAllResourcesToRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addAllResourcesToRegistry', ['registryType', 'registryId', 'serializedResources'])); } let registryType = args[0]; let registryId = args[1]; let serializedResources = JSON.parse(args[2]); let resources = serializedResources.map((serializedResource) =&gt; { return context.getSerializer().fromJSON(serializedResource); }); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.addAll(resources); }) .then(() =&gt; { LOG.exit(method); }); } /** * Add a resource to the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ addResourceToRegistry(context, args) { const method = 'addResourceToRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'addResourceToRegistry', ['registryType', 'registryId', 'serializedResource'])); } let registryType = args[0]; let registryId = args[1]; let serializedResource = JSON.parse(args[2]); let resource = context.getSerializer().fromJSON(serializedResource); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.add(resource); }) .then(() =&gt; { LOG.exit(method); }); } /** * Update an array of resources in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateAllResourcesInRegistry(context, args) { const method = 'updateAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'updateAllResourcesInRegistry', ['registryType', 'registryId', 'serializedResources'])); } let registryType = args[0]; let registryId = args[1]; let serializedResources = JSON.parse(args[2]); let resources = serializedResources.map((serializedResource) =&gt; { return context.getSerializer().fromJSON(serializedResource); }); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.updateAll(resources); }) .then(() =&gt; { LOG.exit(method); }); } /** * Update a resource in the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ updateResourceInRegistry(context, args) { const method = 'updateResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'updateResourceInRegistry', ['registryType', 'registryId', 'serializedResource'])); } let registryType = args[0]; let registryId = args[1]; let serializedResource = JSON.parse(args[2]); let resource = context.getSerializer().fromJSON(serializedResource); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.update(resource); }) .then(() =&gt; { LOG.exit(method); }); } /** * Remove an array of resources from the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeAllResourcesFromRegistry(context, args) { const method = 'removeAllResourcesFromRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'removeAllResourcesFromRegistry', ['registryType', 'registryId', 'resourceIds'])); } let registryType = args[0]; let registryId = args[1]; let resourceIds = JSON.parse(args[2]); return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.removeAll(resourceIds); }) .then(() =&gt; { LOG.exit(method); }); } /** * Remove a resource from the specified registry. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ removeResourceFromRegistry(context, args) { const method = 'removeResourceFromRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'removeResourceFromRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.remove(resourceId); }) .then(() =&gt; { LOG.exit(method); }); } /** * Get all resources in the specified registry, and recursively resolve all * their relationships to other resources. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resolveAllResourcesInRegistry(context, args) { const method = 'resolveAllResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resolveAllResourcesInRegistry', ['registryType', 'registryId'])); } let registryType = args[0]; let registryId = args[1]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { let resolver = context.getResolver(); return resources.reduce((result, resource) =&gt; { return result.then(() =&gt; { LOG.debug(method, 'Resolving resource', resource.getFullyQualifiedIdentifier()); return resolver.resolve(resource); }); }, Promise.resolve()) .then(() =&gt; { LOG.debug(method, 'Resolved all resources', resources.length); return resources; }); }) .then((resources) =&gt; { return resources.map((resource) =&gt; { return context.getSerializer().toJSON(resource, { permitResourcesForRelationships: true }); }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Get the specified resource in the specified registry, and recursively resolve * all its relationships to other resources. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ resolveResourceInRegistry(context, args) { const method = 'resolveResourceInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'resolveResourceInRegistry', ['registryType', 'registryId', 'resourceId'])); } let registryType = args[0]; let registryId = args[1]; let resourceId = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registry) =&gt; { return registry.get(resourceId); }) .then((resource) =&gt; { let resolver = context.getResolver(); LOG.debug(method, 'Resolving resource', resource.getFullyQualifiedIdentifier()); return resolver.resolve(resource); }) .then((resource) =&gt; { return context.getSerializer().toJSON(resource, { permitResourcesForRelationships: true }); }) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * Query all of the the resources in the specified registry using the given * expression, and return all of the resources for which the expression returns * a truthy value. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ findResourcesInRegistry(context, args) { const method = 'findResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'findResourcesInRegistry', ['registryType', 'registryId', 'expression'])); } let registryType = args[0]; let registryId = args[1]; let expression = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { let queryExecutor = context.getQueryExecutor(); return queryExecutor.queryAll(expression, resources) .then((queryResults) =&gt; { let result = []; queryResults.forEach((queryResult, index) =&gt; { let resource = resources[index]; LOG.debug(method, 'Checking query results for resource', resource.getFullyQualifiedIdentifier()); if (queryResult) { LOG.debug(method, 'Query returned truthy value for resource'); result.push(context.getSerializer().toJSON(resource, { convertResourcesToRelationships: true })); } else { LOG.debug(method, 'Query returned falsey value for resource'); } }); LOG.exit(method, result); return result; }); }); } /** * Query all of the the resources in the specified registry using the given * expression, and return all of the truthy results. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ queryResourcesInRegistry(context, args) { const method = 'queryResourcesInRegistry'; LOG.entry(method, context, args); if (args.length !== 3) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'queryResourcesInRegistry', ['registryType', 'registryId', 'expression'])); } let registryType = args[0]; let registryId = args[1]; let expression = args[2]; return context.getRegistryManager().get(registryType, registryId) .then((registryManager) =&gt; { return registryManager.getAll(); }) .then((resources) =&gt; { let queryExecutor = context.getQueryExecutor(); return queryExecutor.queryAll(expression, resources) .then((queryResults) =&gt; { let result = queryResults.filter((queryResult, index) =&gt; { let resource = resources[index]; LOG.debug(method, 'Checking query results for resource', resource.getFullyQualifiedIdentifier()); if (queryResult) { LOG.debug(method, 'Query returned truthy value for resource'); return true; } else { LOG.debug(method, 'Query returned falsey value for resource'); return false; } }); LOG.exit(method, result); return result; }); }); } } module.exports = EngineResources; × Search results Close "},"composer-runtime_lib_engine.transactions.js.html":{"id":"composer-runtime_lib_engine.transactions.js.html","title":"Source: composer-runtime/lib/engine.transactions.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/engine.transactions.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const util = require('util'); const LOG = Logger.getLog('EngineTransactions'); /** * The JavaScript engine responsible for processing chaincode commands. * @protected * @memberof module:composer-runtime */ class EngineTransactions { /** * Submit a transaction for execution. * @param {Context} context The request context. * @param {string[]} args The arguments to pass to the chaincode function. * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ submitTransaction(context, args) { const method = 'submitTransaction'; LOG.entry(method, context, args); if (args.length !== 2) { LOG.error(method, 'Invalid arguments', args); throw new Error(util.format('Invalid arguments &quot;%j&quot; to function &quot;%s&quot;, expecting &quot;%j&quot;', args, 'submitTransaction', ['registryId', 'serializedResource'])); } // Find the default transaction registry. let registryManager = context.getRegistryManager(); let transaction = null, resolvedTransaction = null; // Parse the transaction from the JSON string.. LOG.debug(method, 'Parsing transaction from JSON'); let transactionData = JSON.parse(args[1]); // Now we need to convert the JavaScript object into a transaction resource. LOG.debug(method, 'Parsing transaction from parsed JSON object'); // First we parse *our* copy, that is not resolved. This is the copy that gets added to the // transaction registry, and is the one in the context (for adding log entries). transaction = context.getSerializer().fromJSON(transactionData); // Then we parse the *users* copy, that is resolved, and they can modify to their hearts content. // This is only given to the user, and is discarded afterwards. resolvedTransaction = context.getSerializer().fromJSON(transactionData); // Store the transaction in the context. context.setTransaction(transaction); // Resolve the users copy of the transaction. LOG.debug(method, 'Parsed transaction, resolving it', resolvedTransaction); return context.getResolver().resolve(resolvedTransaction) .then(() =&gt; { // Execute the transaction. let api = context.getApi(); return context.getCompiledScriptBundle().execute(api, resolvedTransaction); }) .then(() =&gt; { // Get the default transaction registry. LOG.debug(method, 'Getting default transaction registry'); return registryManager.get('Transaction', 'default'); }) .then((transactionRegistry) =&gt; { // Store the transaction in the transaction registry. LOG.debug(method, 'Storing executed transaction in transaction registry'); return transactionRegistry.add(transaction); }); } } module.exports = EngineTransactions; × Search results Close "},"composer-runtime_lib_eventservice.js.html":{"id":"composer-runtime_lib_eventservice.js.html","title":"Source: composer-runtime/lib/eventservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/eventservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Service = require('./service'); const LOG = Logger.getLog('EventService'); /** * Base class representing the event service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class EventService extends Service { /** * Constructor. */ constructor() { super(); this.eventBuffer = []; } /** * Add an event to the buffer * @param {Resource} event The event to be emitted * when complete, or rejected with an error. */ emit(event) { const method = 'emit'; LOG.entry(method, event); this.eventBuffer.push(event); LOG.debug(method, this.eventBuffer); LOG.exit(method); } /** * Get an array of emitted events * @return {Resource[]} - An array of emitted events */ getEvents() { const method = 'getEvents'; LOG.entry(method); LOG.exit(method, this.eventBuffer); return this.eventBuffer; } /** * Called at the start of a transaction. * @param {boolean} readOnly Is the transaction read-only? * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionStart(readOnly) { return super.transactionStart(readOnly) .then(() =&gt; { this.eventBuffer = []; }); } } module.exports = EventService; × Search results Close "},"composer-runtime_lib_api_factory.js.html":{"id":"composer-runtime_lib_api_factory.js.html","title":"Source: composer-runtime/lib/api/factory.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/factory.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Factory'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getFactory getFactory} * method instead. * * @class Factory * @classdesc A factory creates new instances of assets, participants, transactions, * and relationships. * @memberof module:composer-runtime * @public */ /** * A class that represents a factory in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class Factory { /** * Constructor. * @param {Factory} factory The factory to use. * @private */ constructor(factory) { const method = 'constructor'; LOG.entry(method, factory); /** * Create a new resource (an instance of an asset, participant, or transaction). The * properties of the new instance should be set as standard JavaScript * object properties. The new instance can then be stored in a registry * using the appropriate registry APIs, for example {@link * module:composer-runtime.AssetRegistry AssetRegistry}. * @example * // Get the factory. * var factory = getFactory(); * // Create a new vehicle. * var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); * // Set the properties of the new vehicle. * vehicle.colour = 'BLUE'; * vehicle.manufacturer = 'Toyota'; * @public * @method module:composer-runtime.Factory#newResource * @param {string} ns The namespace of the resource to create. * @param {string} type The type of the resource to create. * @param {string} id The identifier of the new resource. * @return {Resource} The new instance of the resource. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newResource = function newResource(ns, type, id) { return factory.newResource(ns, type, id); }; /** * Create a new relationship with a given namespace, type, and identifier. * A relationship is a typed pointer to an instance. For example, a new * relationship with namespace 'org.acme', type 'Vehicle' and identifier * 'VEHICLE_1' creates` a pointer that points at an existing instance of * org.acme.Vehicle with the identifier 'VEHICLE_1'. * @example * // The existing driver of the vehicle. * var driver; * // Get the factory. * var factory = getFactory(); * // Create a new relationship to the vehicle. * var vehicle = factory.newRelationship('org.acme', 'Vehicle', 'VEHICLE_1'); * // Set the relationship as the value of the vehicle property of the driver. * driver.vehicle = vehicle; * @public * @method module:composer-runtime.Factory#newRelationship * @param {string} ns The namespace of the resource referenced by the relationship. * @param {string} type The type of the resource referenced by the relationship. * @param {string} id The identifier of the resource referenced by the relationship. * @return {Relationship} The new instance of the relationship. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newRelationship = function newRelationship(ns, type, id) { return factory.newRelationship(ns, type, id); }; /** * Create a new concept with a given namespace, type, and identifier. * A concept is an advanced data structure * @example * // The existing driver of the vehicle. * var person; * // Get the factory. * var factory = getFactory(); * // Create a new relationship to the vehicle. * var record = factory.newConcept('org.acme', 'Record'); * // Add the record to the persons array of records. * person.records.push(record); * @public * @method module:composer-runtime.Factory#newConcept * @param {string} ns The namespace of the concept. * @param {string} type The type of the concept. * @return {Concept} The new instance of the concept. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newConcept = function newConcept(ns, type) { return factory.newConcept(ns, type); }; /** * Create a new type with a given namespace and type * @public * @method module:composer-runtime.Factory#newEvent * @param {string} ns The namespace of the event. * @param {string} type The type of the event. * @return {Resource} The new instance of the event. * @throws {Error} If the specified type (specified by the namespace and * type) is not defined in the current version of the business network. */ this.newEvent = function newEvent(ns, type) { return factory.newEvent(ns, type); }; Object.freeze(this); LOG.exit(method); } } module.exports = Factory; × Search results Close "},"composer-runtime_lib_httpservice.js.html":{"id":"composer-runtime_lib_httpservice.js.html","title":"Source: composer-runtime/lib/httpservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/httpservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const Service = require('./service'); const LOG = Logger.getLog('HTTPService'); /** * Base class representing the http service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class HTTPService extends Service { /** * HTTP POST of a typed instance to a URL. The instance is serialized to JSON * and the JSON text is in the body of the HTTP POST. * @param {string} url - the URL to post data to * @param {Object} data - the data to POST. Data must be an object capable of being converted to a JSON string. * @return {Promise} A JS object that captures the statusCode and body of the HTTP POST response. An HTTP status code that is not 200 will cause the Promise to be rejected. The runtime will attempt to convert * the body to a JS object using JSON.parse. */ post(url,data) { const method = 'post'; LOG.entry(method, url, data); this.url = url; this.data = data; return this._post() .then((responseThing) =&gt; { let response = null; if(typeof responseThing === 'string' ) { response = JSON.parse(responseThing); } else { response = responseThing; } LOG.info('Reponse from URL ' + url, JSON.stringify(response)); if(response.statusCode &gt;= 200 &amp;&amp; response.statusCode &lt; 300) { if(response.body &amp;&amp; typeof response.body === 'string') { try { response.body = JSON.parse(response.body); } catch(err) { LOG.warn('Body data could not be converted to JS object', response.body); } } return Promise.resolve(response); } else { LOG.error('Error statusCode ', response.statusCode); return Promise.reject(JSON.stringify(response)); } }) .then((response) =&gt; { LOG.exit(method); return Promise.resolve(response); }); } /** * Post data * @abstract * @return {Promise} A Promise that return the JSON text for the HTTP POST. It captures the status code, header and body of the HTTP POST. The body must also be returned as embedded JSON text. * @throws {Error} throws an error if there is an issue */ _post() { throw new Error('abstract function called'); } } module.exports = HTTPService; × Search results Close "},"composer-runtime_lib_identityservice.js.html":{"id":"composer-runtime_lib_identityservice.js.html","title":"Source: composer-runtime/lib/identityservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/identityservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Service = require('./service'); /** * Base class representing the identity service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class IdentityService extends Service { /** * Retrieve the current user ID. * @abstract * @return {string} The current user ID, or null if the current user ID cannot * be determined or has not been specified. */ getCurrentUserID() { throw new Error('abstract function called'); } } module.exports = IdentityService; × Search results Close "},"composer-runtime_lib_loggingservice.js.html":{"id":"composer-runtime_lib_loggingservice.js.html","title":"Source: composer-runtime/lib/loggingservice.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/loggingservice.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Service = require('./service'); /** * Base class representing the logging service provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class LoggingService extends Service { /** * Write a critical message to the log. * @abstract * @param {string} message The message to write to the log. */ logCritical(message) { throw new Error('abstract function called'); } /** * Write a debug message to the log. * @abstract * @param {string} message The message to write to the log. */ logDebug(message) { throw new Error('abstract function called'); } /** * Write an error message to the log. * @abstract * @param {string} message The message to write to the log. */ logError(message) { throw new Error('abstract function called'); } /** * Write a informational message to the log. * @abstract * @param {string} message The message to write to the log. */ logInfo(message) { throw new Error('abstract function called'); } /** * Write a notice message to the log. * @abstract * @param {string} message The message to write to the log. */ logNotice(message) { throw new Error('abstract function called'); } /** * Write a warning message to the log. * @abstract * @param {string} message The message to write to the log. */ logWarning(message) { throw new Error('abstract function called'); } } module.exports = LoggingService; × Search results Close "},"composer-runtime_lib_api_participantregistry.js.html":{"id":"composer-runtime_lib_api_participantregistry.js.html","title":"Source: composer-runtime/lib/api/participantregistry.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/participantregistry.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('ParticipantRegistry'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getParticipantRegistry getParticipantRegistry} * method instead. * * @class ParticipantRegistry * @classdesc An participant registry manages a set of participants. * @memberof module:composer-runtime * @public */ /** * A class that represents an participant registry in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class ParticipantRegistry { /** * Constructor. * @param {Registry} registry The registry to use. * @private */ constructor(registry) { const method = 'constructor'; LOG.entry(method, registry); /** * Get a list of all of the existing participants in this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get all of the drivers in the driver participant registry. * return participantRegistry.getAll(); * }) * .then(function (drivers) { * // Process the array of driver objects. * drivers.forEach(function (driver) { * console.log(driver.driverId); * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#getAll * @return {Promise} A promise. The promise is resolved with an array of * {@link Resource} instances representing all of the participants stored in this * participant registry. If the participant registry does not exist, or the current * user does not have access to the participant registry, then the promise will * be rejected with an error that describes the problem. */ this.getAll = function getAll() { return registry.getAll(); }; /** * Get the specified participant in this participant registry using the unique identifier * of the participant. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the specific driver from the driver participant registry. * return participantRegistry.get('VEHICLE_1'); * }) * .then(function (driver) { * // Process the the driver object. * console.log(driver.driverId); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#get * @param {string} id The ID of the participant. * @return {Promise} A promise. The promise is resolved with a {@link Resource} * instance representing the specified participant in this participant registry. If the * specified participant does not exist, or the current user does not have access * to the specified participant, then the promise will be rejected with an error * that describes the problem. */ this.get = function get(id) { return registry.get(id); }; /** * Determines whether a specific participant exists in this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Determine if the specific driver exists in the driver participant registry. * return participantRegistry.exists('VEHICLE_1'); * }) * .then(function (exists) { * // Process the the boolean result. * console.log('Driver exists', exists); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#exists * @param {string} id The ID of the participant. * @return {Promise} A promise. The promise is resolved with a boolean which * is true if the specified participant exists in this participant registry, * and false if the specified participant does not exist. */ this.exists = function exists(id) { return registry.exists(id); }; /** * Add all of the specified participants to this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Create the first driver. * var driver1 = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); * driver1.location = 'Southampton'; * // Create the second driver. * var driver2 = factory.newResource('org.acme', 'Driver', 'VEHICLE_2'); * driver2.location = 'GREEN'; * // Add the drivers to the driver participant registry. * return participantRegistry.addAll([driver1, driver2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#addAll * @param {Resource[]} participants The participants to add to this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been added to this participant registry. If the participants cannot be * added to this participant registry, or if the participants already exist in the * participant registry, then the promise will be rejected with an error * that describes the problem. */ this.addAll = function addAll(participants) { return registry.addAll(participants, { convertResourcesToRelationships: true }); }; /** * Add the specified participant to this participant registry. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Create the driver. * var driver = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); * driver.location = 'Southampton'; * // Add the driver to the driver participant registry. * return participantRegistry.add(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#add * @param {Resource} participant The participants to add to this participant registry. * @return {Promise} A promise. The promise is resolved when the participant has * been added to this participant registry. If the participant cannot be added to this * participant registry, or if the participant already exists in the participant registry, * then the promise will be rejected with an error that describes the problem. */ this.add = function add(participant) { return registry.add(participant, { convertResourcesToRelationships: true }); }; /** * Update all of the specified participants in this participant registry. * @example * // The existing drivers that have come from elsewhere. * var driver1; * var driver2; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Modify the properties of the first driver. * driver1.location = 'Hursley'; * // Modify the properties of the second driver. * driver2.location = 'London'; * // Update the drivers in the driver participant registry. * return participantRegistry.updateAll([driver1, driver2]); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#updateAll * @param {Resource[]} participants The participants to update in this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been updated in this participant registry. If the participants cannot be * updated in this participant registry, or if the participants do not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.updateAll = function updateAll(participants) { return registry.updateAll(participants, { convertResourcesToRelationships: true }); }; /** * Update the specified participant in this participant registry. * @example * // The existing driver that has come from elsewhere. * var driver; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Modify the properties of the driver. * driver.location = 'Hursley'; * // Update the driver in the driver participant registry. * return participantRegistry.update(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#update * @param {Resource} participant The participant to update in this participant registry. * @return {Promise} A promise. The promise is resolved when the participant * have been updated in this participant registry. If the participant cannot be * updated in this participant registry, or if the participant does not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.update = function update(participant) { return registry.update(participant, { convertResourcesToRelationships: true }); }; /** * Remove all of the specified participants from this participant registry. * @example * // The existing drivers that have come from elsewhere. * var driver1; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Remove the drivers from the driver participant registry. Note that * // one driver is specified as a driver instance, and the other * // driver is specified by the ID of the driver. * return participantRegistry.removeAll([driver1, 'VEHICLE_2']); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#removeAll * @param {string[]|Resource[]} participants The participants, or the IDs of the participants, * to remove from this participant registry. * @return {Promise} A promise. The promise is resolved when all of the * participants have been removed from this participant registry. If the participants cannot be * removed from this participant registry, or if the participants do not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.removeAll = function removeAll(participants) { return registry.removeAll(participants); }; /** * Remove the specified participant from this participant registry. * @example * // The existing driver that has come from elsewhere. * var driver; * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (participantRegistry) { * // Get the factory for creating new participant instances. * var factory = getFactory(); * // Remove the driver from the driver participant registry. * return participantRegistry.remove(driver); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @public * @method module:composer-runtime.ParticipantRegistry#remove * @param {string|Resource} participant The participant, or ID of the participant, to remove * from this participant registry. * @return {Promise} A promise. The promise is resolved when the participant * has been removed from this participant registry. If the participant cannot be * removed from this participant registry, or if the participant does not exist in the * participant registry, then the promise will be rejected with an error that * describes the problem. */ this.remove = function remove(participant) { return registry.remove(participant); }; Object.freeze(this); LOG.exit(method); } } module.exports = ParticipantRegistry; × Search results Close "},"composer-runtime_lib_api_query.js.html":{"id":"composer-runtime_lib_api_query.js.html","title":"Source: composer-runtime/lib/api/query.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/query.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Query'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#buildQuery buildQuery} * method instead. * * @class Query * @classdesc A query represents a built query. * @memberof module:composer-runtime * @public */ /** * A class that represents a built query in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class Query { /** * Constructor. * @param {string} identifier The identifier of the built query. * @private */ constructor(identifier) { const method = 'constructor'; LOG.entry(method, identifier); /** * Get the identifier for this built query. * @private * @method module:composer-runtime.Query#getIdentifier * @return {string} The identifier for this built query. */ this.getIdentifier = function getIdentifier() { return identifier; }; Object.freeze(this); LOG.exit(method); } } module.exports = Query; × Search results Close "},"composer-runtime_lib_resolver.js.html":{"id":"composer-runtime_lib_resolver.js.html","title":"Source: composer-runtime/lib/resolver.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/resolver.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const Logger = require('composer-common').Logger; const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const Relationship = require('composer-common').Relationship; const Resource = require('composer-common').Resource; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const LOG = Logger.getLog('Context'); /** * A class for resolving resources and their relationships to other resources. * @protected * @abstract * @memberof module:composer-runtime */ class Resolver { /** * Constructor. * @param {Introspector} introspector The introspector to use. * @param {RegistryManager} registryManager The registry manager to use. */ constructor(introspector, registryManager) { const method = 'constructor'; LOG.entry(method, registryManager); this.introspector = introspector; this.registryManager = registryManager; LOG.exit(method); } /** * Resolve the specified resource or relationship and all of its relationships. * @param {Resource|Relationship} identifiable The identifiable to resolve. * @return {Promise} A promise that is resolved with the resolved {@link Resource} * object when the resource is resolved, or rejected with an error. */ resolve(identifiable) { const method = 'resolve'; LOG.entry(method, identifiable.toString()); let resolveState = { cachedResources: new Map() }; if (identifiable instanceof Resource) { resolveState.cachedResources.set(identifiable.getFullyQualifiedIdentifier(), identifiable); return this.resolveResource(identifiable, resolveState) .then((result) =&gt; { LOG.exit(method, result.toString()); return result; }); } else if (identifiable instanceof Relationship) { return this.resolveRelationship(identifiable, resolveState) .then((result) =&gt; { LOG.exit(method, result.toString()); return result; }); } else { LOG.error(method, 'unsupported type for identifiable'); throw new Error('unsupported type for identifiable'); } } /** * Resolve the specified resource. * @private * @param {Resource} resource The resource to resolve. * @param {Object} resolveState The current resolve state. * @param {Map} resolveState.cachedResources The cache of resolved resources. * @return {Promise} A promise that is resolved with a {@link Resource} object, * or rejected with an error. */ resolveResource(resource, resolveState) { const method = 'resolveResource'; LOG.entry(method, resource.toString(), resolveState); let classDeclaration = resource.getClassDeclaration(); return classDeclaration.getProperties().reduce((result, property) =&gt; { // Get the property value. LOG.debug(method, 'Looking at property', property.getName()); let value = resource[property.getName()]; if (value instanceof Resource) { // Replace the property value with the resolved resource. LOG.debug(method, 'Property value is a resource, resolving', value.toString()); return result.then(() =&gt; { return this.resolveResource(value, resolveState); }).then((newValue) =&gt; { resource[property.getName()] = newValue; }); } else if (value instanceof Relationship) { // Replace the property value with the resolved relationship. LOG.debug(method, 'Property value is a relationship, resolving', value.toString()); return result.then(() =&gt; { return this.resolveRelationship(value, resolveState); }).then((newValue) =&gt; { resource[property.getName()] = newValue; }); } else if (Array.isArray(value)) { // Go through each item in the array. LOG.debug(method, 'Property value is an array, iterating over values', value.length); return value.reduce((arrayReduceResult, item, index) =&gt; { // Handle the array item. if (item instanceof Resource) { // Replace the property value with the resolved resource. LOG.debug(method, 'Array item is a resource, resolving', item.toString()); return arrayReduceResult.then(() =&gt; { return this.resolveResource(item, resolveState); }).then((newItem) =&gt; { value[index] = newItem; }); } else if (item instanceof Relationship) { // Replace the property value with the resolved relationship. LOG.debug(method, 'Property value is a relationship, resolving', item.toString()); return arrayReduceResult.then(() =&gt; { return this.resolveRelationship(item, resolveState); }).then((newItem) =&gt; { value[index] = newItem; }); } else { LOG.debug(method, 'Array item is neither a resource or a relationship, ignoring', item); return arrayReduceResult; } }, result); } else { LOG.debug(method, 'Property value is neither a resource or a relationship, ignoring', value); return result; } }, Promise.resolve()) .then(() =&gt; { LOG.exit(method, resource.toString()); return resource; }); } /** * Get the registry for the specified relationship. * @private * @param {Relationship} relationship The relationship to resolve. * @return {Promise} A promise that is resolved with a {@link Registry} object, * or rejected with an error. */ getRegistryForRelationship(relationship) { const method = 'getRegistryForRelationship'; LOG.entry(method, relationship.toString()); let registryId = relationship.getFullyQualifiedType(); let classDeclaration = this.introspector.getClassDeclaration(registryId); LOG.debug(method, 'Got class declaration', classDeclaration); let classType; if (classDeclaration instanceof AssetDeclaration) { classType = 'Asset'; } else if (classDeclaration instanceof ParticipantDeclaration) { classType = 'Participant'; } else if (classDeclaration instanceof TransactionDeclaration) { classType = 'Transaction'; // Special case for this one! registryId = 'default'; } else { throw new Error('Unsupported class declaration type ' + classDeclaration.toString()); } LOG.debug(method, 'Getting registry', registryId); return this.registryManager.get(classType, registryId) .then((registry) =&gt; { LOG.exit(method, registry); return registry; }); } /** * Resolve the specified relationship. * @private * @param {Relationship} relationship The relationship to resolve. * @param {Object} resolveState The current resolve state. * @param {Map} resolveState.cachedResources The cache of resolved resources. * @param {boolean} [resolveState.skipRecursion] Set to true to skip resolving the resolved resource. * @return {Promise} A promise that is resolved with a {@link Resource} object, * or rejected with an error. */ resolveRelationship(relationship, resolveState) { const method = 'resolveRelationship'; LOG.entry(method, relationship.toString(), resolveState); let fqi = relationship.getFullyQualifiedIdentifier(); if (resolveState.cachedResources.has(fqi)) { LOG.debug(method, 'Target resource is already present in cache', fqi); let resource = resolveState.cachedResources.get(fqi); LOG.exit(method, resource.toString()); return Promise.resolve(resource); } return this.getRegistryForRelationship(relationship) .then((registry) =&gt; { let resourceId = relationship.getIdentifier(); LOG.debug(method, 'Getting resource in registry', resourceId); return registry.get(resourceId); }) .then((resource) =&gt; { LOG.debug(method, 'Got resource from registry, adding to cache'); resolveState.cachedResources.set(fqi, resource); if (resolveState.skipRecursion) { LOG.debug(method, 'Got resource from registry, but skipping resolve'); return resource; } else { LOG.debug(method, 'Got resource from registry, resolving'); return this.resolveResource(resource, resolveState); } }) .then((resource) =&gt; { LOG.exit(method, resource.toString()); return resource; }); } } module.exports = Resolver; × Search results Close "},"composer-runtime_lib_api_serializer.js.html":{"id":"composer-runtime_lib_api_serializer.js.html","title":"Source: composer-runtime/lib/api/serializer.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api/serializer.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Logger = require('composer-common').Logger; const LOG = Logger.getLog('Serializer'); /** * Do not attempt to create an instance of this class.&lt;br&gt; * You must use the {@link module:composer-runtime#getSerializer getSerializer} * method instead. * * @class Serializer * @classdesc A serializer serializes instances of assets, participants, transactions, * and relationships to and from a JSON serialization format. * @memberof module:composer-runtime * @public */ /** * A class that represents a serializer in the transaction processor API. The * transaction processor API should expose no internal properties or internal * methods which could be accessed or misused. * @private */ class Serializer { /** * Constructor. * @param {Serializer} serializer The serializer to use. * @private */ constructor(serializer) { const method = 'constructor'; LOG.entry(method, serializer); /** * Convert a {@link Resource} to a JavaScript object suitable for long-term * peristent storage. * @example * // Get the serializer. * var serializer = getSerializer(); * // Serialize a vehicle. * var json = serializer.toJSON(vehicle); * @public * @method module:composer-runtime.Serializer#toJSON * @param {Resource} resource The resource instance to convert to JSON. * @param {Object} [options] The optional serialization options. * @param {boolean} [options.validate] Validate the structure of the resource * with its model prior to serialization, true by default. * @param {boolean} [options.convertResourcesToRelationships] Convert resources that * are specified for relationship fields into relationships, false by default. * @param {boolean} [options.permitResourcesForRelationships] Permit resources in the * place of relationships (serializing them as resources), false by default. * @return {Object} The JavaScript object that represents the resource * @throws {Error} If the specified resource is not an instance of * {@link Resource} or if it fails validation during serialization. */ this.toJSON = function toJSON(resource, options) { return serializer.toJSON(resource, options); }; /** * Create a {@link Resource} from a JavaScript object representation. * The JavaScript object should have been created by calling the * {@link Serializer#toJSON toJSON} API. * The {@link Resource} is populated based on the JavaScript object. * @example * // Get the serializer. * var serializer = getSerializer(); * // Serialize a vehicle. * var vehicle = serializer.fromJSON(json); * @public * @method module:composer-runtime.Serializer#fromJSON * @param {Object} json The JavaScript object for the resource. * @param {Object} [options] The optional serialization options. * @param {boolean} [options.acceptResourcesForRelationships] Handle JSON objects * in the place of strings for relationships, false by default. * @return {Resource} The resource. * @throws {Error} If the specified resource is not an instance of * {@link Resource} or if it fails validation during serialization. */ this.fromJSON = function fromJSON(json, options) { return serializer.fromJSON(json, options); }; Object.freeze(this); LOG.exit(method); } } module.exports = Serializer; × Search results Close "},"composer-runtime_lib_service.js.html":{"id":"composer-runtime_lib_service.js.html","title":"Source: composer-runtime/lib/service.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/service.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Base class for all services provided by a {@link Container}. * @protected * @abstract * @memberof module:composer-runtime */ class Service { /** * Constructor. */ constructor() { } /** * Called at the start of a transaction. * @abstract * @param {boolean} readOnly Is the transaction read-only? * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionStart(readOnly) { return new Promise((resolve, reject) =&gt; { this._transactionStart(readOnly, (error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionStartCallback * @protected * @param {Error} error The error if any. */ /** * Called at the start of a transaction. * @abstract * @param {boolean} readOnly Is the transaction read-only? * @param {transactionStartCallback} callback The callback function to call when complete. */ _transactionStart(readOnly, callback) { callback(); } /** * Called when a transaction is preparing to commit. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionPrepare() { return new Promise((resolve, reject) =&gt; { this._transactionPrepare((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionPrepareCallback * @protected * @param {Error} error The error if any. */ /** * Called when a transaction is preparing to commit. * @abstract * @param {transactionPrepareCallback} callback The callback function to call when complete. */ _transactionPrepare(callback) { callback(); } /** * Called when a transaction is rolling back. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionRollback() { return new Promise((resolve, reject) =&gt; { this._transactionRollback((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionRollbackCallback * @protected * @param {Error} error The error if any. */ /** * Called when a transaction is rolling back * @abstract * @param {transactionRollbackCallback} callback The callback function to call when complete. */ _transactionRollback(callback) { callback(); } /** * Called when a transaction is committing. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionCommit() { return new Promise((resolve, reject) =&gt; { this._transactionCommit((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionCommitCallback * @protected * @param {Error} error The error if any. */ /** * Called when a transaction is committing. * @abstract * @param {transactionCommitCallback} callback The callback function to call when complete. */ _transactionCommit(callback) { callback(); } /** * Called at the end of a transaction. * @abstract * @return {Promise} A promise that will be resolved when complete, or rejected * with an error. */ transactionEnd() { return new Promise((resolve, reject) =&gt; { this._transactionEnd((error) =&gt; { if (error) { return reject(error); } return resolve(); }); }); } /** * @callback transactionEndCallback * @protected * @param {Error} error The error if any. */ /** * Called at the end of a transaction. * @abstract * @param {transactionEndCallback} callback The callback function to call when complete. */ _transactionEnd(callback) { callback(); } } module.exports = Service; × Search results Close "},"composer-runtime_lib_transactionlogger.js.html":{"id":"composer-runtime_lib_transactionlogger.js.html","title":"Source: composer-runtime/lib/transactionlogger.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/transactionlogger.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const jsonpatch = require('fast-json-patch'); const Logger = require('composer-common').Logger; const LOG = Logger.getLog('TransactionLogger'); /* istanbul ignore next */ /** * A class for logging the changes made by a transaction. * @protected * @abstract * @memberof module:composer-runtime */ class TransactionLogger { /** * Create a logger for the specified transaction. * @param {Resource} transaction The transaction. * @param {RegistryManager} registryManager The registry manager. * @param {Serializer} serializer The serializer. */ constructor(transaction, registryManager, serializer) { const method = 'constructor'; LOG.entry(method, transaction, registryManager, serializer); this.transaction = transaction; this.registryManager = registryManager; this.serializer = serializer; registryManager.on('resourceadded', this.onResourceAdded.bind(this)); registryManager.on('resourceupdated', this.onResourceUpdated.bind(this)); registryManager.on('resourceremoved', this.onResourceRemoved.bind(this)); LOG.exit(method); } /** * Handle a resource being added to a registry. * @param {Registry#resourceadded} event The resource added event. */ onResourceAdded(event) { const method = 'onResourceAdded'; LOG.entry(method, event); LOG.exit(); } /** * Handle a resource being added to a registry. * @param {Registry#resourceupdated} event The resource added event. */ onResourceUpdated(event) { const method = 'onResourceUpdated'; LOG.entry(method, event); // Serialize both the old and new resources. let oldJSON = this.serializer.toJSON(event.oldResource, { convertResourcesToRelationships: true }); LOG.debug(method, 'Serialized old resource'); let newJSON = this.serializer.toJSON(event.newResource, { convertResourcesToRelationships: true }); LOG.debug(method, 'Serialized new resource'); // Generate a JSON Patch from the two resources. let patches = jsonpatch.compare(oldJSON, newJSON); LOG.debug(method, 'Generated JSON Patch', patches); LOG.exit(); } /** * Handle a resource being added to a registry. * @param {Registry#resourceremoved} event The resource added event. */ onResourceRemoved(event) { const method = 'onResourceRemoved'; LOG.entry(method, event); LOG.exit(); } } module.exports = TransactionLogger; × Search results Close "},"composer-runtime_lib_api.js.html":{"id":"composer-runtime_lib_api.js.html","title":"Source: composer-runtime/lib/api.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/api.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetRegistry = require('./api/assetregistry'); const Factory = require('./api/factory'); const Logger = require('composer-common').Logger; const ParticipantRegistry = require('./api/participantregistry'); const Query = require('./api/query'); const Registry = require('./registry'); const Serializer = require('./api/serializer'); const LOG = Logger.getLog('Api'); /** * A class that contains the root of the transaction processor API. Methods in this * class are made available as global functions which can be called by transaction * processor functions. The transaction processor API should expose no internal * properties or internal methods which could be accessed or misused. * @private * @class * @memberof module:composer-runtime */ class Api { /** * The runtime API method names. * @private * @returns {String[]} The runtime API method names. */ static getMethodNames() { return [ 'getFactory', 'getSerializer', 'getAssetRegistry', 'getParticipantRegistry', 'getCurrentParticipant', 'post', 'emit', 'buildQuery', 'query' ]; } /** * Constructor. * @param {Context} context The transaction context. * @private */ constructor(context) { const method = 'constructor'; LOG.entry(method, context); // Get all the things from the context. const factory = context.getFactory(); const serializer = context.getSerializer(); const participant = context.getParticipant(); const registryManager = context.getRegistryManager(); const httpService = context.getHTTPService(); const eventService = context.getEventService(); const dataService = context.getDataService(); const accessController = context.getAccessController(); /** * Get the factory. The factory can be used to create new instances of * assets, participants, and transactions for storing in registries. The * factory can also be used for creating relationships to assets, particpants, * and transactions. * @example * // Get the factory. * var factory = getFactory(); * @method module:composer-runtime#getFactory * @public * @return {module:composer-runtime.Factory} The factory. */ this.getFactory = function getFactory() { const method = 'getFactory'; LOG.entry(method); let result = new Factory(factory); LOG.exit(method, result); return result; }; /** * Get the serializer. The serializer can be used to create new instances of * assets, participants, and transactions from a JavaScript object, or to create * a JavaScript object suitable for long-lived persistence. * @example * // Get the serializer. * var ser = getSerializer(); * @method module:composer-runtime#getSerializer * @public * @return {module:composer-common.Serializer} The serializer. */ this.getSerializer = function getSerializer() { const method = 'getSerializer'; LOG.entry(method); let result = new Serializer(serializer); LOG.exit(method, result); return result; }; /** * Get an existing asset registry using the unique identifier of the asset * registry. An asset registry can be used to retrieve, update, or delete * existing assets, or create new assets. * @example * // Get the vehicle asset registry. * return getAssetRegistry('org.acme.Vehicle') * .then(function (vehicleAssetRegistry) { * // Call methods on the vehicle asset registry. * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#getAssetRegistry * @public * @param {string} id The ID of the asset registry. * @return {Promise} A promise. The promise is resolved with an {@link * module:composer-runtime.AssetRegistry AssetRegistry} instance * representing the asset registry if it exists. If the asset registry * does not exist, or the current user does not have access to the asset * registry, then the promise will be rejected with an error that describes * the problem. */ this.getAssetRegistry = function getAssetRegistry(id) { const method = 'getAssetRegistry'; LOG.entry(method, id); return registryManager.get('Asset', id) .then((registry) =&gt; { let result = new AssetRegistry(registry); LOG.exit(method, result); return result; }); }; /** * Get an existing participant registry using the unique identifier of the participant * registry. An participant registry can be used to retrieve, update, or delete * existing participants, or create new participants. * @example * // Get the driver participant registry. * return getParticipantRegistry('org.acme.Driver') * .then(function (driverParticipantRegistry) { * // Call methods on the driver participant registry. * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#getParticipantRegistry * @public * @param {string} id The ID of the participant registry. * @return {Promise} A promise. The promise is resolved with an {@link * module:composer-runtime.ParticipantRegistry ParticipantRegistry} instance * representing the participant registry if it exists. If the participant registry * does not exist, or the current user does not have access to the participant * registry, then the promise will be rejected with an error that describes * the problem. */ this.getParticipantRegistry = function getParticipantRegistry(id) { const method = 'getParticipantRegistry'; LOG.entry(method, id); return registryManager.get('Participant', id) .then((registry) =&gt; { let result = new ParticipantRegistry(registry); LOG.exit(method, result); return result; }); }; /** * Get the current participant. The current participant is determined by * the identity that was used to submit the current transaction. * @example * // Get the current participant. * var currentParticipant = getCurrentParticipant(); * // Check to see if the current participant is a driver. * if (currentParticipant.getFullyQualifiedType() !== 'org.acme.Driver') { * // Throw an error as the current participant is not a driver. * throw new Error('Current participant is not a driver'); * } * // Check to see if the current participant is the first driver. * if (currentParticipant.getFullyQualifiedIdentifier() !== 'org.acme.Driver#DRIVER_1') { * // Throw an error as the current participant is not a driver. * throw new Error('Current participant is not the first driver'); * } * @method module:composer-runtime#getCurrentParticipant * @public * @return {module:composer-common.Resource} The current participant, * or null if the transaction was submitted using an identity that does * not map to a participant. */ this.getCurrentParticipant = function getCurrentParticipant() { const method = 'getCurrentParticipant'; LOG.entry(method); let result = participant; LOG.exit(method, result); return result; }; /** * Post a typed instance to a HTTP URL * @method module:composer-runtime#post * @param {string} url The URL to post the data to * @param {Typed} typed The typed instance to be posted. The instance will be serialized to JSON. * @return {Promise} A promise. The promise is resolved with a HttpResponse * that represents the result of the HTTP POST. * @public */ this.post = function post(url, typed) { const method = 'post'; LOG.entry(method, url, typed); const options = {}; options.convertResourcesToRelationships = true; options.permitResourcesForRelationships = true; const data = serializer.toJSON(typed, options); LOG.debug(method, typed.getFullyQualifiedType(), data); return httpService.post(url, data) .then((response) =&gt; { LOG.exit(method); return Promise.resolve(response); }); }; /** * Emit an event defined in the transaction * @method module:composer-runtime#emit * @param {Resource} event The event to be emitted * @public */ this.emit = function emit(event) { const method = 'emit'; LOG.entry(method, event); event.setIdentifier(context.getTransaction().getIdentifier() + '#' + context.getEventNumber()); let serializedEvent = serializer.toJSON(event, { convertResourcesToRelationships: true }); context.incrementEventNumber(); LOG.debug(method, event.getFullyQualifiedIdentifier(), serializedEvent); eventService.emit(serializedEvent); LOG.exit(method); }; /** * Build a query ready for later execution. The specified query string must be written * in the Composer query language. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Build a query. * var query = buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); * // Execute the query. * return query(query, { inputValue: 'blue' }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#buildQuery * @param {string} query The query string, written using the Composer query language. * @return {Query} The built query, which can be passed in a call to query. * @public */ this.buildQuery = function buildQuery(query) { const method = 'buildQuery'; LOG.entry(method, query); const identifier = context.getCompiledQueryBundle().buildQuery(query); const result = new Query(identifier); LOG.exit(method, result); return result; }; /** * Execute a query defined in a Composer query file, or execute a query built with buildQuery. * * This functionality is Blockchain platform dependent. For example, when a Composer * business network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must be * configured with the CouchDB database for the world state. * @example * // Execute the query. * return query('Q1', { inputValue: 'blue' }) * .then(function (assets) { * assets.forEach(function (asset) { * // Process each asset. * }); * }) * .catch(function (error) { * // Add optional error handling here. * }); * @method module:composer-runtime#query * @param {string|Query} query The name of the query, or a built query. * @param {Object} [parameters] The parameters for the query. * @return {Promise} A promise that will be resolved with an array of * {@link module:composer-common.Resource Resource} representing the * resources returned by the query. * @public */ this.query = function query(query, parameters) { const method = 'query'; LOG.entry(method, query); let identifier; if (query instanceof Query) { identifier = query.getIdentifier(); } else if (typeof query === 'string') { identifier = query; } else { throw new Error('Invalid query; expecting a built query or the name of a query'); } return context.getCompiledQueryBundle().execute(dataService, identifier, parameters) .then((objects) =&gt; { const resources = objects.map((object) =&gt; { object = Registry.removeInternalProperties(object); return serializer.fromJSON(object); }).filter((resource) =&gt; { try { accessController.check(resource, 'READ'); return true; } catch (e) { return false; } }); LOG.exit(method, resources); return resources; }); }; Object.freeze(this); LOG.exit(method); } } module.exports = Api; × Search results Close "},"composer-runtime_lib_querycompiler.js.html":{"id":"composer-runtime_lib_querycompiler.js.html","title":"Source: composer-runtime/lib/querycompiler.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/querycompiler.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const CompiledQueryBundle = require('./compiledquerybundle'); const createHash = require('sha.js'); const Limit = require('composer-common').Limit; const Logger = require('composer-common').Logger; const OrderBy = require('composer-common').OrderBy; const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const Query = require('composer-common').Query; const QueryFile = require('composer-common').QueryFile; const QueryManager = require('composer-common').QueryManager; const Select = require('composer-common').Select; const Skip = require('composer-common').Skip; const TransactionDeclaration = require('composer-common').TransactionDeclaration; const Where = require('composer-common').Where; const LOG = Logger.getLog('QueryCompiler'); /** * A query compiler compiles all queries in a query manager into a compiled * query bundle that can easily be called by the runtime. * @protected */ class QueryCompiler { /** * Compile all the queries in the specified query manager into a compiled * query bundle for use by the runtime. * @param {QueryManager} queryManager The query manager to process. * @return {CompiledQueryBundle} The compiled query bundle. */ compile(queryManager) { const method = 'compile'; LOG.entry(method, queryManager); const compiledQueries = queryManager.accept(this, {}); const result = new CompiledQueryBundle(this, queryManager, compiledQueries); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle all objects from the query manager. * @param {Object} thing The object being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visit(thing, parameters) { const method = 'visit'; LOG.entry(method, thing, parameters); let result = null; if (thing instanceof QueryManager) { result = this.visitQueryManager(thing, parameters); } else if (thing instanceof QueryFile) { result = this.visitQueryFile(thing, parameters); } else if (thing instanceof Query) { result = this.visitQuery(thing, parameters); } else if (thing instanceof Select) { result = this.visitSelect(thing, parameters); } else if (thing instanceof Where) { result = this.visitWhere(thing, parameters); } else if (thing instanceof OrderBy) { result = this.visitOrderBy(thing, parameters); } else if (thing instanceof Limit) { result = this.visitLimit(thing, parameters); } else if (thing instanceof Skip) { result = this.visitSkip(thing, parameters); } else if (thing.type === 'BinaryExpression') { result = this.visitBinaryExpression(thing, parameters); } else if (thing.type === 'Identifier') { result = this.visitIdentifier(thing, parameters); } else if (thing.type === 'Literal') { result = this.visitLiteral(thing, parameters); } else { throw new Error('Unrecognised type: ' + typeof thing + ', value: ' + JSON.stringify(thing)); } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a query manager by visiting all of the query files. * @param {QueryManager} queryManager The query manager being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitQueryManager(queryManager, parameters) { const method = 'visitQueryManager'; LOG.entry(method, queryManager, parameters); // Compile all of the query files in this query manager. let compiledQueries = []; const queryFile = queryManager.getQueryFile(); if (queryFile) { compiledQueries = queryManager.getQueryFile().accept(this, parameters); } LOG.exit(method, compiledQueries); return compiledQueries; } /** * Visitor design pattern; handle a query file by visiting all of the queries. * @param {QueryFile} queryFile The query file being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitQueryFile(queryFile, parameters) { const method = 'visitQueryFile'; LOG.entry(method, queryFile, parameters); // Compile all of the queries in this query file. const compiledQueries = queryFile.getQueries().map((query) =&gt; { return query.accept(this, parameters); }); LOG.exit(method, compiledQueries); return compiledQueries; } /** * Visitor design pattern; handle a query by visiting the select statement. * @param {Query} query The query being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitQuery(query, parameters) { const method = 'visitQuery'; LOG.entry(method, query, parameters); // Process the select statement, which will return a Mango query. const select = query.getSelect(); const requiredParameters = []; parameters.requiredParameters = requiredParameters; const parametersToUse = {}; parameters.parametersToUse = parametersToUse; const compiledQuery = select.accept(this, parameters); // If there are no required parameters, then we can use a trivial generator function. let compiledQueryGenerator; if (requiredParameters.length === 0) { // Serialize the compiled query string and always return that. compiledQueryGenerator = this.buildTrivialCompiledQueryGenerator(compiledQuery); // Otherwise we have to build a more complex generator function. } else { // No short cuts here! compiledQueryGenerator = this.buildComplexCompiledQueryGenerator(compiledQuery, requiredParameters, parametersToUse); } // Generate a hash for the query. const hash = this.generateQueryHash(query); // Generate a result object containing all the data. const result = { name: query.getName(), text: select.getText(), hash: hash, generator: compiledQueryGenerator }; LOG.exit(method, result); return result; } /** * Build a trivial (no parameters) compiled query generator. * @param {Object} compiledQuery The compiled query. * @return {Function} The compiled query generator. */ buildTrivialCompiledQueryGenerator(compiledQuery) { const compiledQueryString = JSON.stringify(compiledQuery); return (inputParameters) =&gt; { if (Object.keys(inputParameters).length !== 0) { throw new Error('No parameters should be specified for this query'); } return compiledQueryString; }; } /** * Build a complex (one or more parameters) compiled query generator. * @param {Object} compiledQuery The compiled query. * @param {string[]} requiredParameters The required parameters. * @param {Object} parametersToUse The parameters to use. * @return {Function} The compiled query generator. */ buildComplexCompiledQueryGenerator(compiledQuery, requiredParameters, parametersToUse) { return (inputParameters) =&gt; { // Check for all required parameters. requiredParameters.forEach((requiredParameter) =&gt; { if (inputParameters[requiredParameter] === undefined) { throw new Error('Required parameter ' + requiredParameter + ' has not been specified'); } }); // Check for any extraneous parameters. Object.keys(inputParameters).forEach((inputParameter) =&gt; { if (requiredParameters.indexOf(inputParameter) === -1) { throw new Error('Invalid or extraneous parameter ' + inputParameter + ' has been specified'); } }); // Delete all parameters from the last execution. Object.keys(parametersToUse).forEach((parameterToUse) =&gt; { delete parametersToUse[parameterToUse]; }); // Assign the input parameters and serialize the compiled query string. // Note that this will fire all the functions which look up parameters // from the parameters to use object. Object.assign(parametersToUse, inputParameters); return JSON.stringify(compiledQuery); }; } /** * Generate a unique hash for the query. * @param {Query} query The query. * @return {string} A unique hash for the query. */ generateQueryHash(query) { const text = query.getSelect().getText(); const sha256 = createHash('sha256'); return sha256.update(text, 'utf8').digest('hex'); } /** * Visitor design pattern; handle a select statement. * @param {Select} select The select statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitSelect(select, parameters) { const method = 'visitSelect'; LOG.entry(method, select, parameters); // Handle the resource clause, which will always exist. const resource = select.getResource(); const query = { selector: {} }; query.selector.$class = resource; // Look up the type for this resource. const modelManager = select.getQuery().getQueryFile().getModelManager(); const classDeclaration = modelManager.getType(resource); if (classDeclaration instanceof AssetDeclaration) { query.selector.$registryType = 'Asset'; } else if (classDeclaration instanceof ParticipantDeclaration) { query.selector.$registryType = 'Participant'; } else if (classDeclaration instanceof TransactionDeclaration) { query.selector.$registryType = 'Transaction'; } else { throw new Error('The query compiler does not support resources of this type'); } // Handle the from clause, if it exists. const registry = select.getRegistry(); if (registry) { query.selector.$registryID = registry; } else { query.selector.$registryID = resource; } // Handle the where clause, if it exists. const where = select.getWhere(); if (where) { const queryAdditions = where.accept(this, parameters); Object.assign(query.selector, queryAdditions.selector); } // Handle the order by clause, if it exists. const orderBy = select.getOrderBy(); if (orderBy) { const queryAdditions = orderBy.accept(this, parameters); Object.assign(query, queryAdditions); } // Handle the limit clause, if it exists. Note that the limit // clause can reference a parameter. const limit = select.getLimit(); if (limit) { const queryAdditions = limit.accept(this, parameters); Object.assign(query, queryAdditions); } // Handle the skip clause, if it exists. Note that the skip // clause can reference a parameter. const skip = select.getSkip(); if (skip) { const queryAdditions = skip.accept(this, parameters); Object.assign(query, queryAdditions); } LOG.exit(method, query); return query; } /** * Visitor design pattern; handle a where statement. * @param {Where} where The where statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitWhere(where, parameters) { const method = 'visitWhere'; LOG.entry(method, where, parameters); // Simply visit the AST, which will generate a selector. // The root of the AST is probably a binary expression. const selector = this.visit(where.getAST(), parameters); const result = { selector }; LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an order by statement. * @param {OrderBy} orderBy The order by statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitOrderBy(orderBy, parameters) { const method = 'visitOrderBy'; LOG.entry(method, orderBy, parameters); // Iterate over the sort criteria. const result = { sort: [] }; orderBy.getSortCriteria().forEach((sort) =&gt; { const temp = {}; temp[sort.getPropertyPath()] = sort.getDirection().toLowerCase(); result.sort.push(temp); }); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a limit statement. * @param {Limit} limit The limit statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitLimit(limit, parameters) { const method = 'visitLimit'; LOG.entry(method, limit, parameters); // Get the limit value from the AST. const limitValue = this.visit(limit.getAST(), parameters); // Define a limit property on the query; if the limit value is a parameter, // then define a getter to read the current parameter setting. const property = { enumerable: true, configurable: false }; if (typeof limitValue === 'function') { property.get = limitValue; } else { property.value = limitValue; } const result = {}; Object.defineProperty(result, 'limit', property); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a skip statement. * @param {Skip} skip The skip statement being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitSkip(skip, parameters) { const method = 'visitSkip'; LOG.entry(method, skip, parameters); // Get the skip value from the AST. const skipValue = this.visit(skip.getAST(), parameters); // Define a skip property on the query; if the skip value is a parameter, // then define a getter to read the current parameter setting. const property = { enumerable: true, configurable: false }; if (typeof skipValue === 'function') { property.get = skipValue; } else { property.value = skipValue; } const result = {}; Object.defineProperty(result, 'skip', property); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a binary expression. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitBinaryExpression(ast, parameters) { const method = 'visitBinaryExpression'; LOG.entry(method, ast, parameters); // Binary expressions are handled differently in Mango based on the type, // so figure out the type and handle it appropriately. const arrayCombinationOperators = [ 'AND', 'OR' ]; const conditionOperators = [ '&lt;', '&lt;=', '&gt;', '&gt;=', '==', '!=' ]; let result; if (arrayCombinationOperators.indexOf(ast.operator) !== -1) { result = this.visitArrayCombinationOperator(ast, parameters); } else if (conditionOperators.indexOf(ast.operator) !== -1) { result = this.visitConditionOperator(ast, parameters); } else { throw new Error('The query compiler does not support this binary expression'); } LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an array combination operator. * Array combination operators are operators that act on two or more pieces * of data, such as 'AND' and 'OR'. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitArrayCombinationOperator(ast, parameters) { const method = 'visitArrayCombinationOperator'; LOG.entry(method, ast, parameters); // Map the input operator to the Mango operator. const validOperators = { AND: '$and', OR: '$or' }; const operator = validOperators[ast.operator]; if (!operator) { throw new Error('The query compiler does not support this operator'); } // Build the Mango selector for this operator. const result = {}; result[operator] = [ this.visit(ast.left, parameters), this.visit(ast.right, parameters) ]; LOG.exit(method, result); return result; } /** * Visitor design pattern; handle a condition operator. * Condition operators are operators that compare two pieces of data, such * as '&gt;=' and '!='. * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitConditionOperator(ast, parameters) { const method = 'visitConditionOperator'; LOG.entry(method, ast, parameters); // Map the input operator to the Mango operator. const validOperators = { '&lt;': '$lt', '&lt;=': '$lte', '&gt;': '$gt', '&gt;=': '$gte', '==': '$eq', '!=': '$ne' }; let operator = validOperators[ast.operator]; if (!operator) { throw new Error('The query compiler does not support this operator'); } // Grab the left hand side of this expression. let left = this.visit(ast.left, parameters); const leftIsIdentifier = (ast.left.type === 'Identifier' &amp;&amp; typeof left !== 'function'); const leftIsLiteral = (ast.left.type === 'Literal' || typeof left === 'function'); // Grab the right hand side of this expression. let right = this.visit(ast.right, parameters); const rightIsIdentifier = (ast.right.type === 'Identifier' &amp;&amp; typeof right !== 'function'); const rightIsLiteral = (ast.right.type === 'Literal' || typeof right === 'function'); // Check for invalid left and right expressions. if (leftIsLiteral === rightIsLiteral || leftIsIdentifier === rightIsIdentifier) { // Either two literals or two identifiers. throw new Error('The query compiler cannot compile condition operators that do not have an identifier and a literal'); } // Check for a conditional with a literal on the left, and swap the operands. if (leftIsLiteral) { // Since we are going to swap the operands around, we also need to change the operator. const mirrorOperators = { '&lt;': '$gt', // a &lt; b becomes b &gt; a '&lt;=': '$gte', // a &lt;= b becomes b &gt;= a '&gt;': '$lt', // a &gt; b becomes b &lt; a '&gt;=': '$lte', // a &gt;= b becomes b &lt;= a '==': '$eq', // no change '!=': '$ne' // no change }; operator = mirrorOperators[ast.operator]; // Swap the operands around. const temp = left; left = right; right = temp; } // Validate the right hand side; it can be any primitive value. if (right !== null &amp;&amp; typeof right === 'object') { throw new Error('The query compiler cannot compile a condition with a complex value literal'); } // Build the Mango selector for this operator. const result = {}; result[left] = {}; const property = { enumerable: true, configurable: false }; if (typeof right === 'function') { property.get = right; } else { property.value = right; } Object.defineProperty(result[left], operator, property); LOG.exit(method, result); return result; } /** * Visitor design pattern; handle an identifier. * Identifiers are either references to properties in the data being queried, * or references to a query parameter (these are of the format _$varname). * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitIdentifier(ast, parameters) { const method = 'visitIdentifier'; LOG.entry(method, ast, parameters); // Check to see if this is a parameter reference. const parameterMatch = ast.name.match(/^_\\$(.+)/); if (parameterMatch) { const parameterName = parameterMatch[1]; parameters.requiredParameters.push(parameterName); const parametersToUse = parameters.parametersToUse; const selector = () =&gt; { return parametersToUse[parameterName]; }; LOG.exit(method, selector); return selector; } // Otherwise it's a property name. // TODO: We should validate that it is a property name! const selector = ast.name; LOG.exit(method, selector); return selector; } /** * Visitor design pattern; handle a literal. * Literals are just plain old literal values ;-) * @param {Object} ast The abstract syntax tree being visited. * @param {Object} parameters The parameters. * @return {Object} The result of visiting, or null. * @private */ visitLiteral(ast, parameters) { const method = 'visitLiteral'; LOG.entry(method, ast, parameters); const selector = ast.value; LOG.exit(method, selector); return selector; } } module.exports = QueryCompiler; × Search results Close "},"composer-runtime_lib_queryexecutor.js.html":{"id":"composer-runtime_lib_queryexecutor.js.html","title":"Source: composer-runtime/lib/queryexecutor.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/queryexecutor.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const jsonata = require('jsonata'); const Logger = require('composer-common').Logger; const Relationship = require('composer-common').Relationship; const Resource = require('composer-common').Resource; const LOG = Logger.getLog('QueryEngine'); /** * Design documentation: * * The aim of this class to execute queries (currently JSONata expressions) on a * resource or a set of resources. In order for this query support to be useful, * the queries must be able to navigate relationships between resources. For example, * I might want to execute a query of &quot;find all the animals which are in a field, * where that field is owned by a business, where that business is run by a farmer * with the email address alice@farmers.com&quot;. * * We do not want to eagerly resolve all visible relationships, as this is slow. * Most business networks are large and complex, with many relationships between * resources, and additionally those relationships can be circular. * * Ideally, we would only resolve relationships that are needed in order to * successfully execute the query. We can do this by creating &quot;special&quot; properties * on the relationship object for each of the properties that should exist on the * target resource. When the &quot;special&quot; property is accessed by the query, a function * can be executed to resolve that relationship and replace it with the target * resource. */ /** * A class for executing queries using JSONata expressions against resources. * @protected */ class QueryExecutor { /** * Constructor. * @param {Resolver} resolver The resolver to use. */ constructor(resolver) { const method = 'constructor'; LOG.entry(method, resolver); this.resolver = resolver; LOG.exit(method); } /** * Query all of the specified resources using the given JSONata expression. * @param {string} expression The JSONata expression. * @param {Resource[]} resources The resource to query. * @return {Promise} A promise that will be resolved with the results of the * query, or rejected with an error. */ queryAll(expression, resources) { const method = 'queryAll'; LOG.entry(method, expression, resources); // Compile the expression. LOG.debug(method, 'Compiling JSONata expression'); const compiledExpression = jsonata(expression); LOG.debug(method, 'Compiled JSONata expression'); // Prepare the root resources. let cachedResources = new Map(); resources.forEach((resource) =&gt; { LOG.debug(method, 'Preparing resource', resource.getFullyQualifiedIdentifier()); let fqi = resource.getFullyQualifiedIdentifier(); cachedResources.set(fqi, resource); this.prepareResource(resource); }); // Process the query by calling the method that does the bulk of the work. let promise = Promise.resolve(); let result = []; resources.forEach((resource) =&gt; { promise = promise.then(() =&gt; { LOG.debug(method, 'Executing query on resource', resource.getFullyQualifiedIdentifier()); return this.queryInternal(compiledExpression, resource, cachedResources) .then((thisResult) =&gt; { LOG.debug(method, 'Executed query, adding result to list'); result.push(thisResult); }); }); }); return promise .then(() =&gt; { LOG.exit(method, result); return result; }); } /** * Query the specified resource using the given JSONata expression. * @param {string} expression The JSONata expression. * @param {Resource} resource The resource to query. * @return {Promise} A promise that will be resolved with the results of the * query, or rejected with an error. */ query(expression, resource) { const method = 'query'; LOG.entry(method, expression, resource.toString()); // Compile the expression. LOG.debug(method, 'Compiling JSONata expression'); const compiledExpression = jsonata(expression); LOG.debug(method, 'Compiled JSONata expression'); // Prepare the root resource. let cachedResources = new Map(); let fqi = resource.getFullyQualifiedIdentifier(); cachedResources.set(fqi, resource); this.prepareResource(resource); // Process the query by calling the method that does the bulk of the work. return this.queryInternal(compiledExpression, resource, cachedResources) .then((result) =&gt; { LOG.exit(method, result); return result; }); } /** * @private * @typedef {Object} FoundRelationship * @property {Relationship} relationship The relationship. * @property {function} resolve The function to set the resolved value. */ /** * Query the specified resource using the given JSONata expression. * @private * @param {Object} compiledExpression The compiled JSONata expression. * @param {Resource} resource The resource to query. * @param {Map} cachedResources The cache of resources. * @return {Promise} A promise that will be resolved with the results of the * query, or rejected with an error. */ queryInternal(compiledExpression, resource, cachedResources) { const method = 'queryInternal'; LOG.entry(method, compiledExpression, resource, cachedResources); // Evaluate the expression. LOG.debug(method, 'Evaluating JSONata expression'); return new Promise((resolve, reject) =&gt; { compiledExpression.evaluate(resource, null, (error, result) =&gt; { if (error) { return reject(error); } LOG.exit(method); resolve(result); }); }); } /** * Find all of the relationships in the specified resource. * @private * @param {Resource} resource The resource to resolve. * @return {FoundRelationship[]} The relationships in the specified resource. */ findRelationships(resource) { const method = 'findRelationships'; LOG.entry(method, resource.toString()); let classDeclaration = resource.getClassDeclaration(); let result = []; classDeclaration.getProperties().forEach((property) =&gt; { LOG.debug(method, 'Looking at property', property.getName()); let value = resource[property.getName()]; if (value instanceof Resource) { LOG.debug(method, 'Found resource property, recursing'); result.concat(this.findRelationships(value)); } else if (value instanceof Relationship) { LOG.debug(method, 'Found relationship property'); result.push({ relationship: value, resolve: (newValue) =&gt; { LOG.debug( method, 'Replacing relationship property with resolved resource', resource.getFullyQualifiedIdentifier(), property.getName(), newValue.getFullyQualifiedIdentifier() ); resource[property.getName()] = newValue; } }); } else if (Array.isArray(value)) { LOG.debug(method, 'Found array property, iterating'); value.forEach((item, index) =&gt; { if (item instanceof Resource) { LOG.debug(method, 'Found array resource property, recursing'); result.concat(this.findRelationships(item)); } else if (item instanceof Relationship) { LOG.debug(method, 'Found array relationship property'); result.push({ relationship: item, resolve: (newValue) =&gt; { LOG.debug( method, 'Replacing array relationship property with resolved resource', resource.getFullyQualifiedIdentifier(), property.getName(), index, newValue.getFullyQualifiedIdentifier() ); resource[property.getName()][index] = newValue; } }); } else { LOG.debug(method, 'Found array primitive value, ignoring'); } }); } else { LOG.debug(method, 'Found primitive value, ignoring'); } }); LOG.exit(method, result); return result; } /** * Modify the specified relationship so that for every property on the target * resource, a &quot;special&quot; property is added to the relationship with the same * name, which when accessed calls the specified callback. * @private * @param {Relationship} relationship The relationship to modify. * @param {function} callback The function to call when the &quot;special&quot; properties * are accessed. */ modifyRelationship(relationship, callback) { const method = 'modifyRelationship'; LOG.entry(method, relationship.toString()); LOG.debug(method, 'Adding hidden $resolved property'); Object.defineProperty(relationship, '$resolved', { enumerable: false, configurable: false, value: false, writable: true }); let classDeclaration = relationship.getClassDeclaration(); classDeclaration.getProperties().forEach((property) =&gt; { LOG.debug(method, 'Adding special property', property.getName()); Object.defineProperty(relationship, property.getName(), { enumerable: true, configurable: false, get: () =&gt; { LOG.debug(method, 'Special property accessed', relationship.getFullyQualifiedIdentifier(), property.getName()); return callback() .then((resource) =&gt; { LOG.debug(method, 'Special property resolved, returning property value', resource.getFullyQualifiedIdentifier(), property.getName()); return resource[property.getName()]; }); } }); }); LOG.exit(method); } /** * Prepare the specified resource so that every relationship in the resource * is modified so that if the relationship is accessed, it adds itself to the * list of accessed relationships. * @private * @param {Resource} resource The resource to prepare. */ prepareResource(resource) { const method = 'prepareResource'; LOG.entry(method, resource.toString()); // Don't prepare an already prepared resource. if (resource.hasOwnProperty('$prepared')) { LOG.exit(method); return; } Object.defineProperty(resource, '$prepared', { enumerable: false, configurable: false, value: true, writable: true }); // Find all the relationships in this resource. const foundRelationships = this.findRelationships(resource); // Add properties to each relationship. foundRelationships.forEach((foundRelationship) =&gt; { LOG.debug(method, 'Found relationship object', foundRelationship.relationship.toString()); this.modifyRelationship(foundRelationship.relationship, (name) =&gt; { LOG.debug('Relationship accessed', foundRelationship.relationship.toString()); return this.resolver.resolveRelationship(foundRelationship.relationship, { cachedResources: new Map(), skipRecursion: true }) .then((resolvedResource) =&gt; { LOG.debug(method, 'Resolved accessed relationship', foundRelationship.relationship.toString()); this.prepareResource(resolvedResource); foundRelationship.resolve(resolvedResource); return resolvedResource; }); }); }); LOG.exit(method); } } module.exports = QueryExecutor; × Search results Close "},"composer-runtime_lib_registrymanager.js.html":{"id":"composer-runtime_lib_registrymanager.js.html","title":"Source: composer-runtime/lib/registrymanager.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/registrymanager.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const AssetDeclaration = require('composer-common').AssetDeclaration; const EventEmitter = require('events'); const Logger = require('composer-common').Logger; const ParticipantDeclaration = require('composer-common').ParticipantDeclaration; const Registry = require('./registry'); const LOG = Logger.getLog('RegistryManager'); /** * A class for managing and persisting registries. * @protected */ class RegistryManager extends EventEmitter { /** * Constructor. * @param {DataService} dataService The data service to use. * @param {Introspector} introspector The introspector to use. * @param {Serializer} serializer The serializer to use. * @param {AccessController} accessController The access controller to use. * @param {DataCollection} sysregistries The system registries collection to use. */ constructor(dataService, introspector, serializer, accessController, sysregistries) { super(); this.dataService = dataService; this.introspector = introspector; this.serializer = serializer; this.accessController = accessController; this.sysregistries = sysregistries; } /** * Create a new registry instance and subscribe to its events. * @private * @param {DataCollection} dataCollection The data collection. * @param {Serializer} serializer The serializer. * @param {AccessController} accessController The access controller. * @param {string} type The type. * @param {string} id The ID. * @param {string} name The name. * @return {Registry} The new registry instance. */ createRegistry(dataCollection, serializer, accessController, type, id, name) { let registry = new Registry(dataCollection, serializer, accessController, type, id, name); ['resourceadded', 'resourceupdated', 'resourceremoved'].forEach((event) =&gt; { registry.on(event, (data) =&gt; { this.emit(event, data); }); }); return registry; } /** * Ensure that the default registries exist. * @param {boolean} force if set to true, will add without checking for existence * @returns {Promise} A promise that is resolved once all default registries * have been created, or rejected with an error. */ createDefaults(force) { let assetDeclarations = this.introspector.getClassDeclarations().filter((classDeclaration) =&gt; { if (classDeclaration.isAbstract()) { return false; } return (classDeclaration instanceof AssetDeclaration); }); let participantDeclarations = this.introspector.getClassDeclarations().filter((classDeclaration) =&gt; { if (classDeclaration.isAbstract()) { return false; } return (classDeclaration instanceof ParticipantDeclaration); }); return Promise.resolve() .then(() =&gt; { return assetDeclarations.reduce((result, assetDeclaration) =&gt; { let fqn = assetDeclaration.getFullyQualifiedName(); if (force) { return this.add('Asset', fqn, `Asset registry for ${fqn}`, true); } else { return this.ensure('Asset', fqn, `Asset registry for ${fqn}`); } }, Promise.resolve()); }) .then(() =&gt; { return participantDeclarations.reduce((result, participantDeclaration) =&gt; { let fqn = participantDeclaration.getFullyQualifiedName(); if (force) { return this.add('Participant', fqn, `Participant registry for ${fqn}`, true); } else { return this.ensure('Participant', fqn, `Participant registry for ${fqn}`); } }, Promise.resolve()); }); } /** * Get all of the registries. * @param {string} type The type of the registry. * @return {Promise} A promise that is resolved with an array of {@link Registry} * objects when complete, or rejected with an error. */ getAll(type) { return this.sysregistries.getAll() .then((registries) =&gt; { registries = registries.filter((registry) =&gt; { return registry.type === type; }); return registries.reduce((prev, registry) =&gt; { let collectionID = registry.type + ':' + registry.id; return prev.then((result) =&gt; { return this.dataService.getCollection(collectionID) .then((dataCollection) =&gt; { result.push(this.createRegistry(dataCollection, this.serializer, this.accessController, registry.type, registry.id, registry.name)); return result; }); }); }, Promise.resolve([])); }); } /** * Get a registry with the specified type, and ID. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved with a {@link Registry} * objects when complete, or rejected with an error. */ get(type, id) { let collectionID = type + ':' + id; return this.sysregistries.get(collectionID) .then((registry) =&gt; { return this.dataService.getCollection(collectionID) .then((dataCollection) =&gt; { return this.createRegistry(dataCollection, this.serializer, this.accessController, registry.type, registry.id, registry.name); }); }); } /** * Determine whether a registry with the specified type and ID exists. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @return {Promise} A promise that is resolved with a boolean indicating * whether the registry exists. */ exists(type, id) { let collectionID = type + ':' + id; return this.sysregistries.exists(collectionID) .then((exists) =&gt; { return exists; }); } /** * An event signalling that a registry has been added. * @event RegistryManager#registryadded * @protected * @type {object} * @param {Registry} registry The registry. * @param {string} registryType The type of the registry. * @param {string} registryID The ID of the registry. * @param {string} registryName The name of the registry. */ /** * Add a new registry with the specified type, ID, and name. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. * @param {boolean} force true to force the creation of the collection without checking * @return {Promise} A promise that is resolved when complete, or rejected * with an error. */ add(type, id, name, force) { let collectionID = type + ':' + id; return this.sysregistries.add(collectionID, { type: type, id: id, name: name }, force) .then(() =&gt; { return this.dataService.createCollection(collectionID, force); }) .then((dataCollection) =&gt; { let result = this.createRegistry(dataCollection, this.serializer, this.accessController, type, id, name); this.emit('registryadded', { registry: result, registryType: type, registryID: id, registryName: name }); return result; }); } /** * Check to see if the specified registry exists, and create it if it does not. * @param {string} type The type of the registry. * @param {string} id The ID of the registry. * @param {string} name The name of the registry. * @param {boolean} force true to force the creation of the collection without checking * @return {Promise} A promise that is resolved when complete, or rejected * with an error. */ ensure(type, id, name) { const method = 'ensure'; LOG.entry(method, type, id, name); return this.get(type, id) .catch((error) =&gt; { LOG.debug(method, 'The registry does not exist, creating'); return this.add(type, id, name); }) .then((registry) =&gt; { LOG.exit(method, registry); return registry; }); } } module.exports = RegistryManager; × Search results Close "},"composer-runtime_lib_scriptcompiler.js.html":{"id":"composer-runtime_lib_scriptcompiler.js.html","title":"Source: composer-runtime/lib/scriptcompiler.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-runtime/lib/scriptcompiler.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Api = require('./api'); const assert = require('assert'); const CompiledScriptBundle = require('./compiledscriptbundle'); const Logger = require('composer-common').Logger; const SourceMapConsumer = require('source-map').SourceMapConsumer; const SourceMapGenerator = require('source-map').SourceMapGenerator; const SourceNode = require('source-map').SourceNode; const LOG = Logger.getLog('ScriptCompiler'); /** * A script compiler compiles all scripts in a script manager into a compiled * script bundle that can easily be called by the runtime. * @protected */ class ScriptCompiler { /** * Compile all the scripts in the specified script manager into a compiled * script bundle for use by the runtime. * @param {ScriptManager} scriptManager The script manager to process. * @return {CompiledScriptBundle} The compiled script bundle. */ compile(scriptManager) { const method = 'compile'; LOG.entry(method, scriptManager); // Create the compiler context. const rootNode = new SourceNode(null, null, null); const functionDeclarations = []; const context = { rootNode: rootNode, functionDeclarations: functionDeclarations }; // Define the globals. const globals = { assert: assert }; // Add the start section. rootNode.add('function __generator(__globals, __api) {\\n'); Object.keys(globals).forEach((globalName) =&gt; { LOG.debug(method, 'Adding global', globalName); rootNode.add(` var ${globalName} = __globals.${globalName};\\n`); }); Api.getMethodNames().forEach((methodName) =&gt; { LOG.debug(method, 'Adding API method', methodName); rootNode.add(` var ${methodName} = __api.${methodName}.bind(__api);\\n`); }); rootNode.add(' __globals = __api = null;\\n'); // Process the script manager. this.processScriptManager(context, scriptManager); // Add the end section. rootNode.add(' return {\\n'); context.functionDeclarations.forEach((functionDeclaration) =&gt; { LOG.debug(method, 'Adding function declaration', functionDeclaration.getName()); rootNode.add(` '${functionDeclaration.getName()}': ${functionDeclaration.getName()},\\n`); }); rootNode.add(' };'); rootNode.add('}\\n'); rootNode.add('__generator;\\n'); // Generate the combined source code and source map. const combined = rootNode.toStringWithSourceMap(); const sourceCode = combined.code; const sourceMap = combined.map; // Serialize the source map as base64. const sourceMapBase64 = Buffer.from(sourceMap.toString()).toString('base64'); // Combine the source code and the serialized source map. const finalSourceCode = sourceCode + '\\n//# sourceMappingURL=data:application/json;base64,' + sourceMapBase64; // Compile the source code into a generator function. // The &quot;new Function('return eval')&quot; hack stops the generator function getting access // to all our local variables. We could just use &quot;new Function&quot;, but that screws up // the source maps so they all need to be offset by 2. let generatorFunction = new Function('__generatorSource', 'return eval(__generatorSource)')(finalSourceCode); generatorFunction = generatorFunction.bind(null, globals); let result = new CompiledScriptBundle(functionDeclarations, generatorFunction); LOG.exit(method, result); return result; } /** * Process the specified script manager by processing the scripts in the script manager. * @param {Object} context The compiler context. * @param {ScriptManager} scriptManager The script manager to process. */ processScriptManager(context, scriptManager) { const method = 'processScriptManager'; LOG.entry(method, context, scriptManager); // Process all of the scripts in the script manager. scriptManager.getScripts().forEach((script) =&gt; { LOG.debug(method, 'Processing script', script.getIdentifier()); this.processScript(context, script); }); LOG.exit(method); } /** * Process the specified script by processing the function declarations in the script, * then convert the script into a script node and add it to the root node. * @param {Object} context The compiler context. * @param {Script} script The script to process. */ processScript(context, script) { const method = 'processScript'; LOG.entry(method, context, script); // Convert the script into a script node, and add it to the root node. const scriptNode = this.convertScriptToScriptNode(context, script); context.rootNode.add(scriptNode); // Store all the function declarations in this script. script.getFunctionDeclarations().forEach((functionDeclaration) =&gt; { LOG.debug(method, 'Adding function declaration', functionDeclaration.getName()); context.functionDeclarations.push(functionDeclaration); }); LOG.exit(method); } /** * Convert the specified script into a source map. * @param {Object} context The compiler context. * @param {Script} script The function declaration to process. * @return {String} The source map. */ convertScriptToSourceMap(context, script) { const method = 'convertScriptToSourceMap'; LOG.entry(method, context, script); // Create a new source map generator. const sourceMapGenerator = new SourceMapGenerator({ file: script.getIdentifier(), sourceRoot: process.cwd() }); // Get the parser tokens for the script. const tokens = script.getTokens(); // Add mappings for all of the tokens into the source map. tokens.forEach((token) =&gt; { sourceMapGenerator.addMapping({ source: script.getIdentifier(), original: token.loc.start, generated: token.loc.start }); }); // Inline the contents of the script into the source map. sourceMapGenerator.setSourceContent(script.getIdentifier(), script.getContents()); // Return the source map. const result = sourceMapGenerator.toString(); LOG.exit(method, result); return result; } /** * Convert the specified script into a script node with a source map. * @param {Object} context The compiler context. * @param {Script} script The function declaration to process. * @return {SourceNode} The script node. */ convertScriptToScriptNode(context, script) { const method = 'convertScriptToScriptNode'; LOG.entry(method, context, script); // Convert the script into a source map. let sourceFileName = script.getIdentifier(); let sourceCode = script.getContents(); let sourceMap = this.convertScriptToSourceMap(context, script); // Allow someone else to post-process the converted script. const transformedScript = this.transformScript(sourceFileName, sourceCode, sourceMap); sourceFileName = transformedScript.sourceFileName; sourceCode = transformedScript.sourceCode; sourceMap = transformedScript.sourceMap; // Create a new source node from the script contents and source map const sourceMapConsumer = new SourceMapConsumer(sourceMap); const result = SourceNode.fromStringWithSourceMap(sourceCode, sourceMapConsumer); LOG.exit(method, result); return result; } /** * Optional hook to transform a script into another format, for example * by using a code coverage instrumenter. * @param {String} sourceFileName The file name for the script. * @param {String} sourceCode The source code for the script. * @param {String} sourceMap The source map for the script. * @return {Object} The transformed script. */ transformScript(sourceFileName, sourceCode, sourceMap) { const method = 'transformScript'; LOG.entry(method, sourceFileName, sourceCode, sourceMap); const result = { sourceFileName: sourceFileName, sourceCode: sourceCode, sourceMap: sourceMap }; LOG.exit(method, result); return result; } } module.exports = ScriptCompiler; × Search results Close "},"composer-common_lib_wallet.js.html":{"id":"composer-common_lib_wallet.js.html","title":"Source: composer-common/lib/wallet.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/wallet.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; /** * Currently we have a wallet singleton, but this is temporary until * we decide how wallets fit into the administrative and client APIs. */ let theWallet = null; /** * Base class representing a wallet (a container of credentials). * @protected * @abstract */ class Wallet { /** * Get the wallet singleton. * @return {Wallet} The wallet singleton, or null if one * has not been specified. */ static getWallet() { return theWallet; } /** * Set the wallet singleton. * @param {Wallet} wallet The new wallet singleton. */ static setWallet(wallet) { theWallet = wallet; } /** * List all of the credentials in the wallet. * @abstract * @return {Promise} A promise that is resolved with * an array of credential names, or rejected with an * error. */ list() { throw new Error('abstract function called'); } /** * Check to see if the named credentials are in * the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * a boolean; true if the named credentials are in the * wallet, false otherwise. */ contains(name) { throw new Error('abstract function called'); } /** * Get the named credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved with * the named credentials, or rejected with an error. */ get(name) { throw new Error('abstract function called'); } /** * Add a new credential to the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ add(name, value) { throw new Error('abstract function called'); } /** * Update existing credentials in the wallet. * @abstract * @param {string} name The name of the credentials. * @param {string} value The credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ update(name, value) { throw new Error('abstract function called'); } /** * Remove existing credentials from the wallet. * @abstract * @param {string} name The name of the credentials. * @return {Promise} A promise that is resolved when * complete, or rejected with an error. */ remove(name) { throw new Error('abstract function called'); } } module.exports = Wallet; × Search results Close "},"composer-common_lib_log_tree.js.html":{"id":"composer-common_lib_log_tree.js.html","title":"Source: composer-common/lib/log/tree.js","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Source: composer-common/lib/log/tree.js /* * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ 'use strict'; const Node = require('./node.js'); /** Specific tree implementation to work with the inclusion/exclusion log statements * * @private */ class Tree { /** Create the tree and setup the root node */ constructor(){ this.root = new Node('composer',false); } /** Mark the root to be included - defaults to false */ setRootInclusion(){ this.root.setIncluded(); } /** * Add a new node to the tree * * @param {String} name name of the node to add * @param {boolean} include should this be included or not * @return {Node} the new node created */ addNode(name, include){ return this._insertChildNode(name,include,this.root); } /** * Find inclusion property for a given node * @param {String} name name of the node to search the tree for * @return {boolean} inclusion policy - true or false */ getInclusion(name){ return this._findNode(name,this.root); } /** * @param {String} name name of the node to search the tree for * @param {Node} parent parent node to start searching from * @return {boolean} inclusion policy - true or false * * @private */ _findNode(name, parent){ // split the name up based on the marker / let details = name.split(/\\//); let newNodeName = details.shift(); let foundNode = parent.findChild(newNodeName); if ( typeof foundNode === 'undefined' ){ return parent.isIncluded(); } else { return this._findNode(details.join('/'),foundNode); } } /** * Insert a new node based on this parent * @param {String} name name of the node to add * @param {boolean} include should this be included or not * @param {Node} parent node to use as the parent for the children * @return {Node} newly inserted node * * @private */ _insertChildNode(name, include, parent){ // split the name up based on the marker / let details = name.split(/\\//); let newNodeName = details.shift(); // Look to see if the node is in the parent already let child = parent.findChild(newNodeName); if (typeof child === 'undefined' ){ if (details.length === 0) { let newNode = new Node(newNodeName,include); parent.addChildNodeAtStart(newNode); // at the leaf node return the new node created return newNode; } else { let newNode = new Node(newNodeName,parent.isIncluded()); parent.addChildNodeAtStart(newNode); // request another new node to be created. return this._insertChildNode(details.join('/'),include,newNode); } } else { // we have found a node already that matches the name. return this._insertChildNode(details.join('/'),include,child); } } } module.exports = Tree; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Global Members theWallet Currently we have a wallet singleton, but this is temporary untilwe decide how wallets fit into the administrative and client APIs. Source: composer-common/lib/wallet.js, line 21 Methods getLogger(config, configElements) This the default core logger that is used for Hyperledger-Composer. This functionsetups up the Winston logging for both file and console output. Parameters: Name Type Description config Object JSON structure with specific configuration information configElements Array JSON struction with the DEBUG env variables for composer Source: composer-common/lib/log/winstonInjector.js, line 29 Returns: object that is the logger to use Type Object × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Modules Classes ConsoleLogger AdminConnection AssetRegistry BusinessNetworkConnection ParticipantRegistry Query Query Registry TransactionRegistry BaseException BaseModelException BusinessNetworkDefinition BusinessNetworkMetadata Concept Factory Identifiable IllegalModelException Introspector ParseException Relationship Resource SecurityContext SecurityException Serializer Typed TypeNotFoundException ValidatedConcept ValidatedResource ValidationException AssetRegistry Factory ParticipantRegistry Query Serializer × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Classes Classes ConsoleLogger AdminConnection AssetRegistry BusinessNetworkConnection ParticipantRegistry Query Query Registry TransactionRegistry BaseException BaseModelException BusinessNetworkDefinition BusinessNetworkMetadata Concept Factory Identifiable IllegalModelException Introspector ParseException Relationship Resource SecurityContext SecurityException Serializer Typed TypeNotFoundException ValidatedConcept ValidatedResource ValidationException AssetRegistry Factory ParticipantRegistry Query Serializer × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Hyperledger Composer APIHyperledger Composer is an application development framework for building Blockchain applications based on Hyperledger. This is the JavaScript documentation for the Hyperledger Composer Client, Admin, and Runtime JavaScript APIs. OverviewThe major components of Hyperledger Composer are: The Hyperledger Composer language for describing the structure of resources (assets, participantsand transactions) that participate in a blockchain backed business network. JavaScript APIs to query, create, update and delete resources and submit transactionsfrom client applications. Hyperledger Composer resources are stored on the Blockchain. JavaScript transaction processor functions that runs on Hyperledger Fabric when transactions aresubmitted for processing. These functions may update the state of resourcesstored on the Blockchain via server-side Hyperledger Composer APIs. Resources Documentation npm modules GitHub repositories ContributingTo read more about the community and guidelines for submitting pull requests,please read the Contributing document. × Search results Close "},"ConsoleLogger.html":{"id":"ConsoleLogger.html","title":"Class: ConsoleLogger","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ConsoleLogger ConsoleLogger A functional logger implementation that simply writes to the console. new ConsoleLogger() Source: composer-common/lib/log/consolelogger.js, line 22 Methods format(method, msg [, args]) Called to format. Parameters: Name Type Argument Description method string The method. msg string The message. args * &lt;optional&gt; The arguments. Source: composer-common/lib/log/consolelogger.js, line 31 Returns: The formatted message. Type string log(level, method, msg [, args]) Called to log. Parameters: Name Type Argument Description level string The logging level. method string The method. msg string The message. args * &lt;optional&gt; The arguments. Source: composer-common/lib/log/consolelogger.js, line 59 × Search results Close "},"module-composer-admin.html":{"id":"module-composer-admin.html","title":"Module: composer-admin","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-admin The composer-admin module. Defines the administration API for Hyperledger Composer.Hyperledger Composer is a framework for creating blockchain backed digital networks andexchanging assets between participants via processing transactions. Source: composer-admin/index.js, line 25 Classes AdminConnection × Search results Close "},"module-composer-admin.AdminConnection.html":{"id":"module-composer-admin.AdminConnection.html","title":"Class: AdminConnection","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: AdminConnection composer-admin. AdminConnection This class creates an administration connection to a Hyperledger Composer runtime. Theconnection can then be used to: Deploy BusinessNetworkDefinitionsUndeploy BusinessNetworkDefinitionsUpdate BusinessNetworkDefinitionsSend a ping message to the runtime to ensure it is running andcorrectly configured.Store a connection profile document in the connection profile store new AdminConnection( [options]) Create an instance of the AdminConnection class. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description fs Object &lt;optional&gt; specify an fs implementation to use. Source: composer-admin/lib/adminconnection.js, line 40 Methods connect(connectionProfile, enrollmentID, enrollmentSecret, businessNetworkIdentifier) Connects and logs in to the Hyperledger Fabric using a named connectionprofile. The connection profile must exist in the profile store. Parameters: Name Type Description connectionProfile string The name of the connection profile enrollmentID string the enrollment ID of the user enrollmentSecret string the enrollment secret of the user businessNetworkIdentifier string the id of the network (for update) or null Source: composer-admin/lib/adminconnection.js, line 83 Returns: A promise that indicates the connection is complete Type Promise Example // Connect to Hyperledger Fabric var adminConnection = new AdminConnection(); adminConnection.connect('testprofile', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(){ // Connected. }) .catch(function(error){ // Add optional error handling here. }); createProfile(connectionProfile, data) Stores a connection profile into the profile store being used by thisAdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile data Object The connection profile data Source: composer-admin/lib/adminconnection.js, line 121 Returns: A promise that indicates that the connection profile is deployed Type Promise Example // Create a connection profile var adminConnection = new AdminConnection(); var adminOptions = { type: 'hlf', keyValStore: '/tmp/keyValStore', membershipServicesURL: 'grpc://membersrvc:7054', peerURL: 'grpc://vp0:7051', eventHubURL: 'grpc://vp0:7053' }; return adminConnection.createProfile('testprofile', adminOptions) .then(function(){ // Created profile }) .catch(function(error){ // Add optional error handling here. }); deleteProfile(connectionProfile) Deletes the specified connection profile from the profile store being used by thisAdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile Source: composer-admin/lib/adminconnection.js, line 141 Returns: A promise that indicates that the connection profile is deployed Type Promise Example // Delete a connection profile var adminConnection = new AdminConnection(); return adminConnection.deleteProfile('testprofile') .then(function(){ // Deleted profile }) .catch(function(error){ // Add optional error handling here. }); deploy(businessNetworkDefinition) Deploys a new BusinessNetworkDefinition to the Hyperledger Fabric. The connection mustbe connected for this method to succeed. Parameters: Name Type Description businessNetworkDefinition BusinessNetworkDefinition The business network to deploy Source: composer-admin/lib/adminconnection.js, line 226 Returns: A promise that will be fufilled when the business network has beendeployed. Type Promise Example // Deploy a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.deploy(businessNetworkDefinition) .then(function(){ // Business network definition deployed }) .catch(function(error){ // Add optional error handling here. }); disconnect() Disconnects this connection. Source: composer-admin/lib/adminconnection.js, line 197 Returns: A promise that will be resolved when the connection isterminated. Type Promise Example // Disconnect from a Business Network var adminConnection = new AdminConnection(); return adminConnection.disconnect() .then(function(){ // Disconnected. }) .catch(function(error){ // Add optional error handling here. }); getAllProfiles() Retrieve all connection profiles from the profile store being used by thisAdminConnection. Source: composer-admin/lib/adminconnection.js, line 178 Returns: A promise that is resolved with the connection profile data. Type Promise Example // Retrieve all the connection profiles. const adminConnection = new AdminConnection(); return adminConnection.getAllProfiles() .then((profiles) =&gt; { // Retrieved profiles for (let profile in profiles) { console.log(profile, profiles[profile]); } }); getProfile(connectionProfile) Retrieve the specified connection profile from the profile store beingused by this AdminConnection. Parameters: Name Type Description connectionProfile string The name of the connection profile Source: composer-admin/lib/adminconnection.js, line 159 Returns: A promise that is resolved with the connection profile data. Type Promise Example // Retrieve the connection profile. const adminConnection = new AdminConnection(); return adminConnection.getProfile('testprofile') .then((profile) =&gt; { // Retrieved profile console.log(profile); }); list() List all of the deployed business networks. The connection mustbe connected for this method to succeed. Source: composer-admin/lib/adminconnection.js, line 316 Returns: A promise that will be resolved with an array ofbusiness network identifiers, or rejected with an error. Type Promise Example // List all of the deployed business networks. var adminConnection = new AdminConnection(); return adminConnection.list() .then((businessNetworks) =&gt; { // Connection has been tested return businessNetworks.forEach((businessNetwork) =&gt; { console.log('Deployed business network', businessNetwork); }); }) .catch(function(error){ // Add optional error handling here. }); ping() Test the connection to the runtime and verify that the version of theruntime is compatible with this level of the node.js module. Source: composer-admin/lib/adminconnection.js, line 292 Returns: A promise that will be fufilled when the connection hasbeen tested. The promise will be rejected if the version is incompatible. Type Promise Example // Test the connection to the runtime var adminConnection = new AdminConnection(); return adminConnection.ping() .then(function(){ // Connection has been tested }) .catch(function(error){ // Add optional error handling here. }); undeploy(businessNetworkIdentifier) Undeploys a BusinessNetworkDefinition from the Hyperledger Fabric. The business network will nolonger be able to process transactions. Parameters: Name Type Description businessNetworkIdentifier string The identifier of the network to undeploy Source: composer-admin/lib/adminconnection.js, line 248 Returns: A promise that will be fufilled when the business network has beenundeployed. Type Promise Example // Undeploy a Business Network Definition var adminConnection = new AdminConnection(); return adminConnection.undeploy('identifier') .then(function(){ // Undeployed Business Network Definition }) .catch(function(error){ // Add optional error handling here. }) update(businessNetworkDefinition) Updates an existing BusinessNetworkDefinition on the Hyperledger Fabric. The BusinessNetworkDefinitionmust have been previously deployed. Parameters: Name Type Description businessNetworkDefinition BusinessNetworkDefinition The new BusinessNetworkDefinition Source: composer-admin/lib/adminconnection.js, line 271 Returns: A promise that will be fufilled when the business network has beenupdated. Type Promise Example // Updates a Business Network Definition var adminConnection = new AdminConnection(); var businessNetworkDefinition = BusinessNetworkDefinition.fromArchive(myArchive); return adminConnection.update(businessNetworkDefinition) .then(function(){ // Business network definition updated }) .catch(function(error){ // Add optional error handling here. }); × Search results Close "},"module-composer-client.html":{"id":"module-composer-client.html","title":"Module: composer-client","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-client The composer-client module. Defines the client API for Composer.Composer is a framework for creating blockchain backed digital networks andexchanging assets between participants via processing transactions.Applications interact with the framework by instantiating the BusinessNetworkConnectionclass. Source: composer-client/index.js, line 26 Classes AssetRegistry BusinessNetworkConnection ParticipantRegistry Query Query Registry TransactionRegistry × Search results Close "},"module-composer-client.AssetRegistry.html":{"id":"module-composer-client.AssetRegistry.html","title":"Class: AssetRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: AssetRegistry composer-client. AssetRegistry The AssetRegistry is used to manage a set of assets stored on the blockchain. new AssetRegistry(id, name, securityContext, modelManager, factory, serializer) Create an asset registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the asset registry. name string The display name for the asset registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this asset registry. factory Factory The factory to use for this asset registry. serializer Serializer The Serializer to use for this asset registry. Source: composer-client/lib/assetregistry.js, line 30 See: See Registry Extends Registry Methods add(resource [, options]) Add the specified resource to this registry. Parameters: Name Type Argument Description resource Resource The resource to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#add Source: composer-runtime/lib/registry.js, line 164 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addAll(resources [, options]) Add all of the specified resources to this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#addAll Source: composer-runtime/lib/registry.js, line 146 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 308 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 108 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 88 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 65 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise remove(resource) Remove the specified resource from this registry. Parameters: Name Type Description resource string | Resource The resource to remove from this registry. Inherited From: Registry#remove Source: composer-runtime/lib/registry.js, line 272 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise removeAll(resources) Remove all of the specified resources from this registry. Parameters: Name Type Description resources Array.&lt;string&gt; | Array.&lt;Resource&gt; The resources to remove from this registry. Inherited From: Registry#removeAll Source: composer-runtime/lib/registry.js, line 258 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 321 Returns: An object suitable for serialization. Type Object update(resource [, options]) Update the specified resource in this registry. Parameters: Name Type Argument Description resource Resource The resource to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#update Source: composer-runtime/lib/registry.js, line 218 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise updateAll(resources [, options]) Update all of the specified resources in this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#updateAll Source: composer-runtime/lib/registry.js, line 200 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise × Search results Close "},"module-composer-client.BusinessNetworkConnection.html":{"id":"module-composer-client.BusinessNetworkConnection.html","title":"Class: BusinessNetworkConnection","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BusinessNetworkConnection composer-client. BusinessNetworkConnection Use this class to connect to and then interact with a deployed BusinessNetworkDefinition.Use the AdminConnection class in the composer-admin module to deploy BusinessNetworksDefinitions. new BusinessNetworkConnection( [options]) Create an instance of the BusinessNetworkConnection class.must be called to connect to a deployed BusinessNetworkDefinition. Parameters: Name Type Argument Description options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description fs Object &lt;optional&gt; specify an fs implementation to use. developmentMode boolean &lt;optional&gt; specify whether or not the instanceis in development mode. Use only for testing purposes! Source: composer-client/lib/businessnetworkconnection.js, line 44 See: See EventEmitter Extends EventEmitter Methods addAssetRegistry(id, name) Add a new asset registry. Parameters: Name Type Description id string The unique identifier of the asset registry name string The name of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 175 Returns: A promise that will be resolved with the new assetregistry after it has been added. Type Promise Example // Add a new asset registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.addAssetRegistry('registryId','registryName'); }); addParticipantRegistry(id, name) Add a new participant registry. Parameters: Name Type Description id string The unique identifier of the participant registry name string The name of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 259 Returns: A promise that will be resolved with the new participantregistry after it has been added. Type Promise Example // Add a new participant registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.addParticipantRegistry('registryId','registryName'); }); assetRegistryExists(id) Determine whether a asset registry exists. Parameters: Name Type Description id string The unique identifier of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 156 Returns: A promise that will be resolved with a boolean indicating whether the assetregistry exists. Type Promise Example // Determine whether an asset registry exists var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.assetRegistryExists('businessNetworkIdentifier.registryId'); }) .then(function(exists){ // if (exists === true) { // logic here... //} }); buildQuery(query) Build a query ready for later execution. The specified query string must be writtenin the Composer query language. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Description query string The query string, written using the Composer query language. Source: composer-client/lib/businessnetworkconnection.js, line 447 Returns: The built query, which can be passed in a call to query. Type Query Example // Build and execute a query. var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function () { var query = businessNetwork.buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); return businessNetwork.query(query, { inputValue: 'blue' }) }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); connect(connectionProfile, businessNetwork, enrollmentID, enrollmentSecret [, additionalConnectOptions]) Connects to a business network using a connection profile, and authenticates to the Hyperledger Fabric. Parameters: Name Type Argument Description connectionProfile string The name of the connection profile businessNetwork string The identifier of the business network enrollmentID string the enrollment ID of the user enrollmentSecret string the enrollment secret of the user additionalConnectOptions Object &lt;optional&gt; Additional configuration options suppliedat runtime that override options set in the connection profile.which will override those in the specified connection profile. Source: composer-client/lib/businessnetworkconnection.js, line 309 Returns: A promise to a BusinessNetworkDefinition that indicates the connection is complete Type Promise Example // Connect and log in to HLF var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ // Connected }); disconnect() Disconnects from the Hyperledger Fabric. Source: composer-client/lib/businessnetworkconnection.js, line 358 Returns: A promise that will be resolved when the connection isterminated. Type Promise Example // Disconnects from HLF var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.disconnect(); }) .then(function(){ // Disconnected. }); getAllAssetRegistries(securityContext) Get a list of all existing asset registries. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: composer-client/lib/businessnetworkconnection.js, line 112 Returns: A promise that will be resolved with a list of existingasset registries Type Promise Example // Get all asset registries var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAllAssetRegistries(); }) .then(function(assetRegistries){ // Retrieved Asset Registries }); getAllParticipantRegistries(securityContext) Get a list of all existing participant registries. Parameters: Name Type Description securityContext SecurityContext The user's security context Source: composer-client/lib/businessnetworkconnection.js, line 196 Returns: A promise that will be resolved with a list of existingparticipant registries Type Promise Example // Get all participant registries var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAllParticipantRegistries(); }) .then(function(participantRegistries){ // Retrieved Participant Registries }); getAssetRegistry(id) Get an existing asset registry. Parameters: Name Type Description id string The unique identifier of the asset registry Source: composer-client/lib/businessnetworkconnection.js, line 133 Returns: A promise that will be resolved with the existing assetregistry, or rejected if the asset registry does not exist. Type Promise Example // Get a asset registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getAssetRegistry('businessNetworkIdentifier.registryId'); }) .then(function(assetRegistry){ // Retrieved Asset Registry }); getBusinessNetwork() Returns the currently connected BusinessNetworkDefinition Source: composer-client/lib/businessnetworkconnection.js, line 92 Returns: the business network Type BusinessNetworkDefinition Example // Get the Business Network Definition var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getBusinessNetwork(); }) .then(function(BusinessNetworkDefinition){ // Retrieved Business Network Definition }); getParticipantRegistry(id) Get an existing participant registry. Parameters: Name Type Description id string The unique identifier of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 217 Returns: A promise that will be resolved with the existing participantregistry, or rejected if the participant registry does not exist. Type Promise Example // Get a participant registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getParticipantRegistry('businessNetworkIdentifier.registryId'); }) .then(function(participantRegistry){ // Retrieved Participant Registry }); getTransactionRegistry() Get the transaction registry. Source: composer-client/lib/businessnetworkconnection.js, line 278 Returns: A promise that will be resolved to the TransactionRegistry Type Promise Example // Get the transaction registry var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.getTransactionRegistry(); }) .then(function(transactionRegistry){ // Retrieved Transaction Registry }); issueIdentity(participant, userID [, options]) Issue an identity with the specified user ID and map it to the specifiedparticipant. Parameters: Name Type Argument Description participant Resource | string The participant, or the fully qualifiedidentifier of the participant. The participant must already exist. userID string The user ID for the identity. options object &lt;optional&gt; Options for the new identity. Properties Name Type Argument Description issuer boolean &lt;optional&gt; Whether or not the new identity should havepermissions to create additional new identities. False by default. Source: composer-client/lib/businessnetworkconnection.js, line 546 Returns: A promise that will be fulfilled when the identity hasbeen added to the specified participant. The promise will be rejected ifthe participant does not exist, or if the identity is already mapped toanother participant. Type Promise participantRegistryExists(id) Determine whether a participant registry exists. Parameters: Name Type Description id string The unique identifier of the participant registry Source: composer-client/lib/businessnetworkconnection.js, line 240 Returns: A promise that will be resolved with a boolean indicating whether the participantregistry exists. Type Promise Example // Determine whether an asset registry exists var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetworkDefinition.participantRegistryExists('businessNetworkIdentifier.registryId'); }) .then(function(exists){ // if (exists === true) { // logic here... //} }); ping() Test the connection to the runtime and verify that the version of theruntime is compatible with this level of the client node.js module. Source: composer-client/lib/businessnetworkconnection.js, line 527 Returns: A promise that will be fufilled when the connection hasbeen tested. The promise will be rejected if the version is incompatible. Type Promise Example // Test the connection to the runtime var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ return businessNetwork.ping(); }) .then(function(){ // Connection tested. }); query(query [, parameters]) Execute a query defined in a Composer query file, or execute a query built with buildQuery. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Argument Description query string | Query The name of the query, or a built query. parameters Object &lt;optional&gt; The parameters for the query. Source: composer-client/lib/businessnetworkconnection.js, line 484 Returns: A promise that will be resolved with an array ofResource representing theresources returned by the query. Type Promise Example // Execute the query. var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function () { return query('Q1', { inputValue: 'blue' }) }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); revokeIdentity(identity) Revoke the specified identity by removing any existing mapping to a participant. Parameters: Name Type Description identity string The identity, for example the enrollment ID. Source: composer-client/lib/businessnetworkconnection.js, line 579 Returns: A promise that will be fulfilled when the identity hasbeen removed from the specified participant. The promise will be rejected ifthe participant does not exist, or if the identity is not mapped to theparticipant. Type Promise submitTransaction(transaction) Submit a transaction for processing by the currently connected business network. Parameters: Name Type Description transaction Resource The transaction to submit. Use {@linkFactory#newTransaction newTransaction} to create this object. Source: composer-client/lib/businessnetworkconnection.js, line 396 Returns: A promise that will be fulfilled when the transaction hasbeen processed. Type Promise Example // Submits a transaction var businessNetwork = new BusinessNetworkConnection(); return businessNetwork.connect('testprofile', 'businessNetworkIdentifier', 'WebAppAdmin', 'DJY27pEnl16d') .then(function(businessNetworkDefinition){ var factory = businessNetworkDefinition.getBusinessNetwork().getFactory(); var transaction = factory.newTransaction('network.transactions', 'TransactionType'); return businessNetworkDefinition.submitTransaction(transaction); }) .then(function(){ // Submitted a transaction. }); × Search results Close "},"module-composer-client.ParticipantRegistry.html":{"id":"module-composer-client.ParticipantRegistry.html","title":"Class: ParticipantRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ParticipantRegistry composer-client. ParticipantRegistry The ParticipantRegistry is used to manage a set of participants stored on the blockchain. new ParticipantRegistry(id, name, securityContext, modelManager, factory, serializer) Create an participant registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the participant registry. name string The display name for the participant registry. securityContext SecurityContext The security context to use for this participant registry. modelManager ModelManager The ModelManager to use for this participant registry. factory Factory The factory to use for this participant registry. serializer Serializer The Serializer to use for this participant registry. Source: composer-client/lib/participantregistry.js, line 30 See: See Registry Extends Registry Methods add(resource [, options]) Add the specified resource to this registry. Parameters: Name Type Argument Description resource Resource The resource to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#add Source: composer-runtime/lib/registry.js, line 164 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addAll(resources [, options]) Add all of the specified resources to this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to add to this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#addAll Source: composer-runtime/lib/registry.js, line 146 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 308 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 108 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 88 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 65 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise remove(resource) Remove the specified resource from this registry. Parameters: Name Type Description resource string | Resource The resource to remove from this registry. Inherited From: Registry#remove Source: composer-runtime/lib/registry.js, line 272 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise removeAll(resources) Remove all of the specified resources from this registry. Parameters: Name Type Description resources Array.&lt;string&gt; | Array.&lt;Resource&gt; The resources to remove from this registry. Inherited From: Registry#removeAll Source: composer-runtime/lib/registry.js, line 258 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 321 Returns: An object suitable for serialization. Type Object update(resource [, options]) Update the specified resource in this registry. Parameters: Name Type Argument Description resource Resource The resource to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#update Source: composer-runtime/lib/registry.js, line 218 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise updateAll(resources [, options]) Update all of the specified resources in this registry. Parameters: Name Type Argument Description resources Array.&lt;Resource&gt; The resources to update in this registry. options Object &lt;optional&gt; Options for processing the resources. Properties Name Type Argument Description convertResourcesToRelationships boolean &lt;optional&gt; Permit resourcesin the place of relationships, defaults to false. Inherited From: Registry#updateAll Source: composer-runtime/lib/registry.js, line 200 Returns: A promise that will be resolved when complete, or rejectedwith an error. Type Promise × Search results Close "},"module-composer-client.Query.html":{"id":"module-composer-client.Query.html","title":"Class: Query","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Query composer-client. Query The Query class represents a built query. A built query has been parsed and validated.Do not attempt to create an instance of this class.You must use the buildQuerymethod instead. new Query(identifier) Constructor. Parameters: Name Type Description identifier string The identifier of the built query. Source: composer-client/lib/query.js, line 40 Class: Query composer-client. Query A query represents a built query. new Query() Do not attempt to create an instance of this class.You must use the buildQuerymethod instead. Source: composer-client/lib/query.js, line 21 × Search results Close "},"module-composer-client.Registry.html":{"id":"module-composer-client.Registry.html","title":"Class: Registry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Registry composer-client. Registry Class representing an Abstract Registry. &lt;abstract&gt; new Registry(registryType, id, name, securityContext, modelManager, factory, serializer) Create a registry. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description registryType string The type of this registry. id string The unique identifier of the registry. name string The display name for the registry. securityContext SecurityContext The users security context. modelManager ModelManager The ModelManager to use for this registry. factory Factory The factory to use for this registry. serializer Serializer The Serializer to use for this registry. Source: composer-client/lib/registry.js, line 27 Methods add(resource) Adds a new resource to the registry. Parameters: Name Type Description resource Resource The resource to be added to the registry. Source: composer-client/lib/registry.js, line 189 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise addAll(resources) Adds a list of new resources to the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be added to the registry. Source: composer-client/lib/registry.js, line 171 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise exists(id) Determines whether a specific resource exists in the registry. Parameters: Name Type Description id string The unique identifier of the resource. Source: composer-client/lib/registry.js, line 321 Returns: A promise that will be resolved with true/false depending on whether the resource exists. Type Promise find(expression) Find resources in the registry that match the specified JSONata expression.The JSONata expression is applied to each resource in the registry, andresources are returned if the JSONata expression returns a truthy value for thatresource. Parameters: Name Type Description expression string The JSONata expression. Source: composer-client/lib/registry.js, line 343 Returns: A promise that will be resolved with an array of {@linkResource} instances representing the assets that match the query. Type Promise get(id) Get a specific resource in the registry. Parameters: Name Type Description id string The unique identifier of the resource. Source: composer-client/lib/registry.js, line 301 Returns: A promise that will be resolved with a JSON objectrepresenting the resource. Type Promise getAll() Get all of the resources in the registry. Source: composer-client/lib/registry.js, line 281 Returns: A promise that will be resolved with an array of JSONobjects representing the resources. Type Promise query(expression) Execute a query against all resources in the registry. The JSONataexpression is applied to each resource in the registry, and the resultof the JSONata expression is returned if the result is truthy. The resultis a JavaScript object, and should only be used for visualizationpurposes. You cannot use the add or update functions withdata returned by this function. Parameters: Name Type Description expression string The JSONata expression. Source: composer-client/lib/registry.js, line 371 Returns: A promise that will be resolved with an array of JavaScriptobjects representing the resources and all of their resolved relationships. Type Promise remove(resource) Remove an asset with a given type and id from the registry. Parameters: Name Type Description resource Resource | string The resource, or the unique identifier of the resource. Source: composer-client/lib/registry.js, line 261 Returns: A promise that will be resolved when the resource isremoved from the registry. Type Promise removeAll(resources) Removes a list of resources from the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; | Array.&lt;string&gt; The resources, or the unique identifiers of the resources. Source: composer-client/lib/registry.js, line 239 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise resolve(id) Get a specific resource in the registry, and resolve all of its relationshipsto other assets, participants, and transactions. The result is a JavaScriptobject, and should only be used for visualization purposes. You cannot usethe add or update functions with a resolved resource. Parameters: Name Type Description id string The unique identifier of the asset. Source: composer-client/lib/registry.js, line 409 Returns: A promise that will be resolved with a JavaScript objectrepresenting the resource and all of its resolved relationships. Type Promise resolveAll() Get all of the resources in the registry, and resolve all of their relationshipsto other assets, participants, and transactions. The result is a JavaScriptobject, and should only be used for visualization purposes. You cannot usethe add or update functions with a resolved resource. Source: composer-client/lib/registry.js, line 391 Returns: A promise that will be resolved with an array of JavaScriptobjects representing the resources and all of their resolved relationships. Type Promise update(resource) Updates a resource in the registry. Parameters: Name Type Description resource Resource The resource to be updated in the registry. Source: composer-client/lib/registry.js, line 223 Returns: A promise that will be resolved when the resource isupdated in the registry. Type Promise updateAll(resources) Updates a list of resources in the registry. Parameters: Name Type Description resources Array.&lt;Resource&gt; The resources to be updated in the asset registry. Source: composer-client/lib/registry.js, line 205 Returns: A promise that will be resolved when the resource isadded to the registry. Type Promise × Search results Close "},"module-composer-client.TransactionRegistry.html":{"id":"module-composer-client.TransactionRegistry.html","title":"Class: TransactionRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: TransactionRegistry composer-client. TransactionRegistry The TransactionRegistry is used to store a set of transactions on the blockchain. new TransactionRegistry(id, name, securityContext, modelManager, factory, serializer) Create an transaction registry.Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkConnection Parameters: Name Type Description id string The unique identifier of the transaction registry. name string The display name for the transaction registry. securityContext SecurityContext The security context to use for this asset registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 30 See: See Registry Extends Registry Methods &lt;static&gt; addTransactionRegistry(securityContext, id, name, modelManager, factory, serializer) Add a new transaction registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the transaction registry. name string The name of the transaction registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 99 Returns: A promise that will be resolved with a TransactionRegistryinstance representing the new transaction registry. Type Promise &lt;static&gt; getAllTransactionRegistries(securityContext, modelManager, factory, serializer) Get a list of all existing transaction registries. Parameters: Name Type Description securityContext SecurityContext The user's security context. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 42 Returns: A promise that will be resolved with a list of TransactionRegistryinstances representing the transaction registries. Type Promise &lt;static&gt; getTransactionRegistry(securityContext, id, modelManager, factory, serializer) Get an existing transaction registry. Parameters: Name Type Description securityContext SecurityContext The user's security context. id string The unique identifier of the transaction registry. modelManager ModelManager The ModelManager to use for this transaction registry. factory Factory The factory to use for this transaction registry. serializer Serializer The Serializer to use for this transaction registry. Source: composer-client/lib/transactionregistry.js, line 70 Returns: A promise that will be resolved with a TransactionRegistryinstance representing the transaction registry. Type Promise addInternalProperties(json) Add any internal properties to the specified JSON object beforepersisting it into a data collection. Parameters: Name Type Description json Object The JSON object. Inherited From: Registry#addInternalProperties Source: composer-runtime/lib/registry.js, line 308 Returns: The JSON object. Type Object exists(id) Determine whether the specified resource exists in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#exists Source: composer-runtime/lib/registry.js, line 108 Returns: A promise that will be resolved with a booleanindicating whether the asset exists. Type Promise get(id) Get the specified resource in this registry. Parameters: Name Type Description id string The ID of the resource. Inherited From: Registry#get Source: composer-runtime/lib/registry.js, line 88 Returns: A promise that will be resolved with a Resourceobject when complete, or rejected with an error. Type Promise getAll() Get all the resources in this registry. Inherited From: Registry#getAll Source: composer-runtime/lib/registry.js, line 65 Returns: A promise that will be resolved with an array of {@linkResource} objects when complete, or rejected with an error. Type Promise toJSON() Return an object suitable for serialization. Inherited From: Registry#toJSON Source: composer-runtime/lib/registry.js, line 321 Returns: An object suitable for serialization. Type Object × Search results Close "},"module-composer-common.html":{"id":"module-composer-common.html","title":"Module: composer-common","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-common Hyperledger-Composer module. Hyperledger-Composer is a framework for creatingblockchain backed digital networks and exchanging assets between participantsvia processing transactions. Source: composer-common/index.js, line 17 Classes BaseException BaseModelException BusinessNetworkDefinition BusinessNetworkMetadata Concept Factory Identifiable IllegalModelException Introspector ParseException Relationship Resource SecurityContext SecurityException Serializer Typed TypeNotFoundException ValidatedConcept ValidatedResource ValidationException Methods &lt;inner&gt; nodeHasNewBufferVersion() Check whether we're running in a version of node which has the updated Buffer implementationUsed above to fall back to the old version if needed. Source: composer-common/index.js, line 29 Returns: whether the new version is supported Type boolean × Search results Close "},"module-composer-common.BaseException.html":{"id":"module-composer-common.BaseException.html","title":"Class: BaseException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BaseException composer-common. BaseException A base class for all Composer exceptions new BaseException(message) Create the BaseException. Parameters: Name Type Description message string The exception message. Source: composer-common/lib/baseexception.js, line 24 Extends Error × Search results Close "},"module-composer-common.BaseModelException.html":{"id":"module-composer-common.BaseModelException.html","title":"Class: BaseModelException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BaseModelException composer-common. BaseModelException Exception throws when a composer file is semantically invalid new BaseModelException(message, fileLocation, fullMessage) Create an IllegalModelException Parameters: Name Type Description message string the message for the exception fileLocation string the optional file location associated with the exception fullMessage string the optional full message text Source: composer-common/lib/introspect/basemodelexception.js, line 26 See: See BaseException Extends BaseException Methods getFileLocation() Returns the file location associated with the exception or null Source: composer-common/lib/introspect/basemodelexception.js, line 44 Returns: the optional location associated with the exception Type string getShortMessage() Returns the error message without the location of the error Source: composer-common/lib/introspect/basemodelexception.js, line 52 Returns: the error message Type string × Search results Close "},"module-composer-common.BusinessNetworkDefinition.html":{"id":"module-composer-common.BusinessNetworkDefinition.html","title":"Class: BusinessNetworkDefinition","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BusinessNetworkDefinition composer-common. BusinessNetworkDefinition A BusinessNetworkDefinition defines a set of Participants that exchange Assets bysending Transactions. This class manages the metadata and domain-specific types forthe network as well as a set of executable scripts. new BusinessNetworkDefinition(identifier, description, packageJson, readme) Create the BusinessNetworkDefinition. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition.fromArchive Parameters: Name Type Description identifier String the identifier of the business network. Theidentifier is formed from a business network name + '@' + version. Theversion is a semver valid version string. If package.json is passed this is ignored. description String the description of the business network. If package.json is passed then this is ignored. packageJson object the JS object for package.json (optional) readme String the readme in markdown for the business network (optional) Source: composer-common/lib/businessnetworkdefinition.js, line 45 Methods &lt;static&gt; fromArchive(Buffer) Create a BusinessNetworkDefinition from an archive. Parameters: Name Type Description Buffer Buffer the Buffer to a zip archive Source: composer-common/lib/businessnetworkdefinition.js, line 149 Returns: a Promise to the instantiated business network Type Promise &lt;static&gt; fromDirectory(path [, options]) Builds a BusinessNetworkDefintion from the contents of a directory.The directory must include a package.json in the root (used to specifythe name, version and description of the business network). This methodis designed to work with business networks that refer to external modelsusing npm dependencies as well as business networks that staticallypackage their model files. If package.json contains a dependencies property then this method will search formodel (CTO) files under the node_modules directory for each dependency thatpasses the options.dependencyGlob pattern.If the network depends on an npm module its dependencies (transitive closure)will also be scanned for model (CTO) files.The directory may optionally contain a README.md file which is accessible from theBusinessNetworkMetadata.getREADME method.In addition all model files will be added that are not under node_modulesand that pass the options.modelFileGlob pattern. By default you should putmodel files under a directory called 'models'.All script (js) files will be added that are not under node_modules andthat pass the options.scriptGlob pattern. By default you should put Javascriptfiles under the 'lib' directory. Parameters: Name Type Argument Description path String to a local directory options Object &lt;optional&gt; an optional set of options to configure the instance. Properties Name Type Argument Description dependencyGlob Object &lt;optional&gt; specify the glob pattern used to matchthe npm dependencies to process. Defaults to ** modelFileGlob boolean &lt;optional&gt; specify the glob pattern used to matchthe model files to include. Defaults to \\/models/\\/*.cto scriptGlob boolean &lt;optional&gt; specify the glob pattern used to matchthe script files to include. Defaults to \\/lib/\\/*.js Source: composer-common/lib/businessnetworkdefinition.js, line 376 Returns: a Promise to the instantiated business network Type Promise getDescription() Returns the description for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 140 Returns: the description of this business network Type String getFactory() Provides access to the Factory for this business network. The Factoryis used to create the types defined in this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 635 Returns: the Factory for this business network Type Factory getIdentifier() Returns the identifier for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 106 Returns: the identifier of this business network Type String getIntrospector() Provides access to the Introspector for this business network. The Introspectoris used to reflect on the types defined within this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 626 Returns: the Introspector for this business network Type Introspector getMetadata() Returns the metadata for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 114 Returns: the metadata for this business network Type BusinessNetworkMetadata getName() Returns the name for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 122 Returns: the name of this business network Type String getSerializer() Provides access to the Serializer for this business network. The Serializeris used to serialize instances of the types defined within this business network. Source: composer-common/lib/businessnetworkdefinition.js, line 644 Returns: the Serializer for this business network Type Serializer getVersion() Returns the version for this business network Source: composer-common/lib/businessnetworkdefinition.js, line 131 Returns: the version of this business network. Use semver moduleto parse. Type String toArchive( [options]) Store a BusinessNetworkDefinition as an archive. Parameters: Name Type Argument Description options Object &lt;optional&gt; JSZip options Source: composer-common/lib/businessnetworkdefinition.js, line 275 Returns: buffer - the zlib buffer Type Buffer × Search results Close "},"module-composer-common.BusinessNetworkMetadata.html":{"id":"module-composer-common.BusinessNetworkMetadata.html","title":"Class: BusinessNetworkMetadata","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: BusinessNetworkMetadata composer-common. BusinessNetworkMetadata Defines the metadata for a BusinessNeworkDefinition. This includes: package.json README.md (optional) new BusinessNetworkMetadata(packageJson, readme) Create the BusinessNetworkMetadata. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition Parameters: Name Type Description packageJson object the JS object for package.json (required) readme String the README.md for the business network (may be null) Source: composer-common/lib/businessnetworkmetadata.js, line 31 Methods getDescription() Returns the description for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 115 Returns: the description of the business network Type string getIdentifier() Returns the identifier for this business network, formed from name@version. Source: composer-common/lib/businessnetworkmetadata.js, line 131 Returns: the identifier of the business network Type string getName() Returns the name for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 107 Returns: the name of the business network Type string getPackageJson() Returns the package.json for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 99 Returns: the Javascript object for package.json Type object getREADME() Returns the README.md for this business network. This may be null if the business network does not have a README.md Source: composer-common/lib/businessnetworkmetadata.js, line 91 Returns: the README.md file for the business network or null Type String getVersion() Returns the version for this business network. Source: composer-common/lib/businessnetworkmetadata.js, line 123 Returns: the description of the business network Type string × Search results Close "},"module-composer-common.Concept.html":{"id":"module-composer-common.Concept.html","title":"Class: Concept","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Concept composer-common. Concept Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new Concept(modelManager, ns, type) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. Source: composer-common/lib/model/concept.js, line 38 See: See Resource Extends Identifiable Methods isConcept() Determine if this typed is a concept. Source: composer-common/lib/model/concept.js, line 61 Returns: True if this typed is a concept,false if not. Type boolean × Search results Close "},"module-composer-common.Factory.html":{"id":"module-composer-common.Factory.html","title":"Class: Factory","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Factory composer-common. Factory Use the Factory to create instances of Resource: transactions, participantsand assets. new Factory(modelManager) Create the factory. Note: Only to be called by framework code. Applications shouldretrieve instances from Hyperledger-Composer Parameters: Name Type Description modelManager ModelManager The ModelManager to use for this registry Source: composer-common/lib/factory.js, line 46 Methods newConcept(ns, type [, options]) Create a new Resource with a given namespace, type name and id Parameters: Name Type Argument Description ns string the namespace of the Resource type string the type of the Resource options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description disableValidation boolean &lt;optional&gt; pass true if you want the factory toreturn a Resource instead of a ValidatedResource. Defaults to false. generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. Source: composer-common/lib/factory.js, line 159 Throws: if the type is not registered with the ModelManager Type TypeNotFoundException Returns: the new instance Type Resource newEvent(ns, type [, id] [, options]) Create a new event object. The identifier of the event isset to a UUID. Parameters: Name Type Argument Description ns string the namespace of the event. type string the type of the event. id string &lt;optional&gt; an optional identifier for the event; if you do not specifyone then an identifier will be automatically generated. options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. Source: composer-common/lib/factory.js, line 268 Returns: A resource for the new event. Type Resource newRelationship(ns, type, id) Create a new Relationship with a given namespace, type and identifier.A relationship is a typed pointer to an instance. I.e the relationshipwith namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' creates`a pointer that points at an instance of org.acme.Vehicle with the idABC. Parameters: Name Type Description ns string the namespace of the Resource type string the type of the Resource id string the identifier Source: composer-common/lib/factory.js, line 214 Throws: if the type is not registered with the ModelManager Type TypeNotFoundException Returns: the new relationship instance Type Relationship newResource(ns, type, id [, options]) Create a new Resource with a given namespace, type name and id Parameters: Name Type Argument Description ns string the namespace of the Resource type string the type of the Resource id string the identifier options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description disableValidation boolean &lt;optional&gt; pass true if you want the factory toreturn a Resource instead of a ValidatedResource. Defaults to false. generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. Source: composer-common/lib/factory.js, line 74 Throws: if the type is not registered with the ModelManager Type TypeNotFoundException Returns: the new instance Type Resource newTransaction(ns, type [, id] [, options]) Create a new transaction object. The identifier of the transaction isset to a UUID. Parameters: Name Type Argument Description ns string the namespace of the transaction. type string the type of the transaction. id string &lt;optional&gt; an optional identifier for the transaction; if you do not specifyone then an identifier will be automatically generated. options Object &lt;optional&gt; an optional set of options Properties Name Type Argument Description generate string &lt;optional&gt; Pass one of: samplereturn a resource instance with generated sample data. emptyreturn a resource instance with empty property values. Source: composer-common/lib/factory.js, line 235 Returns: A resource for the new transaction. Type Resource × Search results Close "},"module-composer-common.Identifiable.html":{"id":"module-composer-common.Identifiable.html","title":"Class: Identifiable","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Identifiable composer-common. Identifiable Identifiable is an entity with a namespace, type and an identifier. This class is abstract. &lt;abstract&gt; new Identifiable(modelManager, ns, type, id) Create an instance. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/identifiable.js, line 27 Methods getFullyQualifiedIdentifier() Get the fully qualified identifier of this instance.(namespace '.' type '#' identifier). Source: composer-common/lib/model/identifiable.js, line 71 Returns: the fully qualified identifier of this instance Type string getIdentifier() Get the identifier of this instance Source: composer-common/lib/model/identifiable.js, line 50 Returns: The identifier for this object Type string isRelationship() Determine if this identifiable is a relationship. Source: composer-common/lib/model/identifiable.js, line 88 Returns: True if this identifiable is a relationship,false if not. Type boolean isResource() Determine if this identifiable is a resource. Source: composer-common/lib/model/identifiable.js, line 97 Returns: True if this identifiable is a resource,false if not. Type boolean setIdentifier(id) Set the identifier of this instance Parameters: Name Type Description id string the new identifier for this object Source: composer-common/lib/model/identifiable.js, line 58 toString() Returns the string representation of this class Source: composer-common/lib/model/identifiable.js, line 79 Returns: the string representation of the class Type String toURI() Returns a URI representation of a reference to this identifiable Source: composer-common/lib/model/identifiable.js, line 105 Returns: the URI for the identifiable Type String × Search results Close "},"module-composer-common.IllegalModelException.html":{"id":"module-composer-common.IllegalModelException.html","title":"Class: IllegalModelException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: IllegalModelException composer-common. IllegalModelException Exception throws when a composer file is semantically invalid new IllegalModelException(message [, modelFile] [, fileLocation]) Create an IllegalModelException. Parameters: Name Type Argument Description message String the message for the exception modelFile ModelFile &lt;optional&gt; the optional modelfile associated with the exception fileLocation Object &lt;optional&gt; location details of the error within the model file. Properties Name Type Description start.line String start line of the error location. start.column String start column of the error location. end.line String end line of the error location. end.column String end column of the error location. Source: composer-common/lib/introspect/illegalmodelexception.js, line 26 See: See BaseModelException Extends BaseModelException Methods getModelFile() Returns the modelfile associated with the exception or null Source: composer-common/lib/introspect/illegalmodelexception.js, line 62 Returns: the optional filename associated with the model Type string × Search results Close "},"module-composer-common.Introspector.html":{"id":"module-composer-common.Introspector.html","title":"Class: Introspector","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Introspector composer-common. Introspector Provides access to the structure of transactions, assets and participants. new Introspector(modelManager) Create the Introspector. Note: Only to be called by framework code. Applications shouldretrieve instances from BusinessNetworkDefinition Parameters: Name Type Description modelManager ModelManager the ModelManager that backs this Introspector Source: composer-common/lib/introspect/introspector.js, line 24 Methods getClassDeclaration(fullyQualifiedTypeName) Returns the class declaration with the given fully qualified name.Throws an error if the class declaration does not exist. Parameters: Name Type Description fullyQualifiedTypeName String the fully qualified name of the type Source: composer-common/lib/introspect/introspector.js, line 69 Throws: if the class declaration does not exist Type Error Returns: the class declaration Type ClassDeclaration getClassDeclarations() Returns all the class declarations for the business network. Source: composer-common/lib/introspect/introspector.js, line 52 Returns: the array of class declarations Type Array.&lt;ClassDeclaration&gt; × Search results Close "},"module-composer-common.ParseException.html":{"id":"module-composer-common.ParseException.html","title":"Class: ParseException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ParseException composer-common. ParseException Exception throws when a Composer file is syntactically invalid new ParseException(message, fileLocation) Create an ParseException Parameters: Name Type Description message string the message for the exception fileLocation string the optional file location associated with the exception Source: composer-common/lib/introspect/parseexception.js, line 26 See: See BaseModelException Extends BaseModelException × Search results Close "},"module-composer-common.Relationship.html":{"id":"module-composer-common.Relationship.html","title":"Class: Relationship","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Relationship composer-common. Relationship A Relationship is a typed pointer to an instance. I.e the relationshipwith namespace = 'org.acme', type = 'Vehicle' and id = 'ABC' createsa pointer that points at an instance of org.acme.Vehicle with the idABC. new Relationship(modelManager, ns, type, id) Create an asset. Use the Factory to create instances. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/relationship.js, line 31 See: See Identifiable Extends Identifiable Methods &lt;static&gt; fromURI(modelManager, uriAsString, defaultNamespace, defaultType) Contructs a Relationship instance from a URI representation (created using toURI). Parameters: Name Type Description modelManager ModelManager the model manager to bind the relationship to uriAsString String the URI as a string, generated using Identifiable.toURI() defaultNamespace String default namespace to use for backwards compatability (optional) defaultType String default type to use for backwards compatability (optional) Source: composer-common/lib/model/relationship.js, line 76 Returns: the relationship Type Relationship isRelationship() Determine if this identifiable is a relationship. Source: composer-common/lib/model/relationship.js, line 64 Returns: True if this identifiable is a relationship,false if not. Type boolean toString() Returns the string representation of this class Source: composer-common/lib/model/relationship.js, line 55 Returns: the string representation of the class Type String × Search results Close "},"module-composer-common.Resource.html":{"id":"module-composer-common.Resource.html","title":"Class: Resource","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Resource composer-common. Resource Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new Resource(modelManager, ns, type, id) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. Source: composer-common/lib/model/resource.js, line 37 See: See Resource Extends Identifiable Methods isResource() Determine if this identifiable is a resource. Source: composer-common/lib/model/resource.js, line 68 Returns: True if this identifiable is a resource,false if not. Type boolean toString() Returns the string representation of this class Source: composer-common/lib/model/resource.js, line 59 Returns: the string representation of the class Type String × Search results Close "},"module-composer-common.SecurityContext.html":{"id":"module-composer-common.SecurityContext.html","title":"Class: SecurityContext","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: SecurityContext composer-common. SecurityContext SecurityContext is used to authenticate and manageuser credentials to the underlying blockchain fabric. &lt;abstract&gt; new SecurityContext(connection, user) Create the SecurityContext.Note: Only to be called by framework code. Applications shouldretrieve instances by calling login Parameters: Name Type Description connection Connection The owning connection. user string The user identifier. Source: composer-common/lib/securitycontext.js, line 25 Methods getConnection() Get the owning connection. Source: composer-common/lib/securitycontext.js, line 43 Returns: The owning connection. Type Connection &lt;abstract&gt; getUser() Get the current username. Source: composer-common/lib/securitycontext.js, line 52 Returns: The username Type string × Search results Close "},"module-composer-common.SecurityException.html":{"id":"module-composer-common.SecurityException.html","title":"Class: SecurityException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: SecurityException composer-common. SecurityException Class representing a security exception new SecurityException(message) Create the SecurityException. Parameters: Name Type Description message string The exception message. Source: composer-common/lib/securityexception.js, line 27 See: See BaseException Extends BaseException × Search results Close "},"module-composer-common.Serializer.html":{"id":"module-composer-common.Serializer.html","title":"Class: Serializer","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Serializer composer-common. Serializer Serialize Resources instances to/from various formats for long-term storage(e.g. on the blockchain). new Serializer(factory, modelManager) Create a Serializer.Note: Only to be called by framework code. Applications shouldretrieve instances from Composer Parameters: Name Type Description factory Factory The Factory to use to create instances modelManager ModelManager The ModelManager to use for validation etc. Source: composer-common/lib/serializer.js, line 34 Methods fromJSON(jsonObject, options) Create a Resource from a JavaScript Object representation.The JavaScript Object should have been created by calling thetoJSON API. The Resource is populated based on the JavaScript object. Parameters: Name Type Description jsonObject Object The JavaScript Object for a Resource options Object the optional serialization options Properties Name Type Description acceptResourcesForRelationships boolean handle JSON objectsin the place of strings for relationships, defaults to false. Source: composer-common/lib/serializer.js, line 125 Returns: The new populated resource Type Resource toJSON(resource, options) Convert a Resource to a JavaScript object suitable for long-termperistent storage. Parameters: Name Type Description resource Resource The instance to convert to JSON options Object the optional serialization options. Properties Name Type Description validate boolean validate the structure of the Resourcewith its model prior to serialization (default to true) convertResourcesToRelationships boolean Convert resources thatare specified for relationship fields into relationships, false by default. permitResourcesForRelationships boolean Permit resources in theplace of relationships (serializing them as resources), false by default. Source: composer-common/lib/serializer.js, line 72 Throws: throws an exception if resource is not an instance ofResource or fails validation. Type Error Returns: The Javascript Object that represents the resource Type Object × Search results Close "},"module-composer-common.Typed.html":{"id":"module-composer-common.Typed.html","title":"Class: Typed","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Typed composer-common. Typed Object is an instance with a namespace and a type. This class is abstract. &lt;abstract&gt; new Typed(modelManager, ns, type) Create an instance. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. Source: composer-common/lib/model/typed.js, line 27 Methods addArrayValue(propName, value) Adds a value to an array property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/typed.js, line 129 getFullyQualifiedType() Get the fully-qualified type name of the instance (including namespace). Source: composer-common/lib/model/typed.js, line 78 Returns: The fully-qualified type name of this object Type string getNamespace() Get the namespace of the instance. Source: composer-common/lib/model/typed.js, line 86 Returns: The namespace of this object Type string getType() Get the type of the instance (a short name, not including namespace). Source: composer-common/lib/model/typed.js, line 70 Returns: The type of this object Type string instanceOf(fqt) Check to see if this instance is an instance of the specified fully qualifiedtype name. Parameters: Name Type Description fqt String The fully qualified type name. Source: composer-common/lib/model/typed.js, line 179 Returns: True if this instance is an instance of the specified fullyqualified type name, false otherwise. Type boolean setPropertyValue(propName, value) Sets a property on this Resource Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/typed.js, line 120 × Search results Close "},"module-composer-common.TypeNotFoundException.html":{"id":"module-composer-common.TypeNotFoundException.html","title":"Class: TypeNotFoundException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: TypeNotFoundException composer-common. TypeNotFoundException Error thrown when a Composer type does not exist. new TypeNotFoundException(typeName [, message]) Constructor. If the optional 'message' argument is not supplied, it will be set to a default value thatincludes the type name. Parameters: Name Type Argument Description typeName String fully qualified type name. message String &lt;optional&gt; error message. Source: composer-common/lib/typenotfoundexception.js, line 27 See: See BaseException Extends BaseException Methods getTypeName() Get the name of the type that was not found. Source: composer-common/lib/typenotfoundexception.js, line 50 Returns: fully qualified type name. Type string × Search results Close "},"module-composer-common.ValidatedConcept.html":{"id":"module-composer-common.ValidatedConcept.html","title":"Class: ValidatedConcept","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ValidatedConcept composer-common. ValidatedConcept Resource is an instance that has a type. The type of the resourcespecifies a set of properites (which themselves have types).Type information in Composer is used to validate the structure ofResource instances and for serialization.Resources are used in Composer to represent Assets, Participants, Transactions andother domain classes that can be serialized for long-term persistent storage. new ValidatedConcept(modelManager, ns, type, resourceValidator) This constructor should not be called directly. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. resourceValidator ResourceValidator The validator to use for this instance Source: composer-common/lib/model/validatedconcept.js, line 38 See: See Resource Extends Identifiable Methods addArrayValue(propName, value) Adds an array property value, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedconcept.js, line 89 Throws: if the value is not compatible with the model definition for the field Type Error setPropertyValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedconcept.js, line 63 Throws: if the value is not compatible with the model definition for the field Type Error validate() Validates the instance against its model. Source: composer-common/lib/model/validatedconcept.js, line 121 Throws: if the instance if invalid with respect to the model Type Error × Search results Close "},"module-composer-common.ValidatedResource.html":{"id":"module-composer-common.ValidatedResource.html","title":"Class: ValidatedResource","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ValidatedResource composer-common. ValidatedResource ValidatedResource is a Resource that can validate that propertychanges (or the whole instance) do not violate the structure ofthe type information associated with the instance. new ValidatedResource(modelManager, ns, type, id, resourceValidator) This constructor should not be called directly.Use the Factory class to create instances. Note: Only to be called by framework code. Applications shouldretrieve instances from Factory Parameters: Name Type Description modelManager ModelManager The ModelManager for this instance ns string The namespace this instance. type string The type this instance. id string The identifier of this instance. resourceValidator ResourceValidator The validator to use for this instance Source: composer-common/lib/model/validatedresource.js, line 29 See: See Resource Extends Resource Methods addArrayValue(propName, value) Adds an array property value, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedresource.js, line 83 Throws: if the value is not compatible with the model definition for the field Type Error setPropertyValue(propName, value) Sets a property, validating that it does not violate the model Parameters: Name Type Description propName string the name of the field value string the value of the property Source: composer-common/lib/model/validatedresource.js, line 56 Throws: if the value is not compatible with the model definition for the field Type Error validate() Validates the instance against its model. Source: composer-common/lib/model/validatedresource.js, line 117 Throws: if the instance if invalid with respect to the model Type Error × Search results Close "},"module-composer-common.ValidationException.html":{"id":"module-composer-common.ValidationException.html","title":"Class: ValidationException","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ValidationException composer-common. ValidationException Exception thrown when a resource fails to model against the model new ValidationException(message) Create an ParseException Parameters: Name Type Description message string the message for the exception Source: composer-common/lib/serializer/validationexception.js, line 26 See: See BaseException Extends BaseException × Search results Close "},"module-composer-runtime.html":{"id":"module-composer-runtime.html","title":"Module: composer-runtime","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Module: composer-runtime The runtime module provides the API that is made available to transactionprocessing functions. Source: composer-runtime/index.js, line 17 Classes AssetRegistry Factory ParticipantRegistry Query Serializer Methods buildQuery(query) Build a query ready for later execution. The specified query string must be writtenin the Composer query language. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Description query string The query string, written using the Composer query language. Source: composer-runtime/lib/api.js, line 257 Returns: The built query, which can be passed in a call to query. Type Query Example // Build a query. var query = buildQuery('SELECT org.acme.sample.SampleAsset WHERE (value == _$inputValue)'); // Execute the query. return query(query, { inputValue: 'blue' }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); emit(event) Emit an event defined in the transaction Parameters: Name Type Description event Resource The event to be emitted Source: composer-runtime/lib/api.js, line 238 getAssetRegistry(id) Get an existing asset registry using the unique identifier of the assetregistry. An asset registry can be used to retrieve, update, or deleteexisting assets, or create new assets. Parameters: Name Type Description id string The ID of the asset registry. Source: composer-runtime/lib/api.js, line 115 Returns: A promise. The promise is resolved with an {@linkmodule:composer-runtime.AssetRegistry AssetRegistry} instancerepresenting the asset registry if it exists. If the asset registrydoes not exist, or the current user does not have access to the assetregistry, then the promise will be rejected with an error that describesthe problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Call methods on the vehicle asset registry. }) .catch(function (error) { // Add optional error handling here. }); getCurrentParticipant() Get the current participant. The current participant is determined bythe identity that was used to submit the current transaction. Source: composer-runtime/lib/api.js, line 183 Returns: The current participant,or null if the transaction was submitted using an identity that doesnot map to a participant. Type module:composer-common.Resource Example // Get the current participant. var currentParticipant = getCurrentParticipant(); // Check to see if the current participant is a driver. if (currentParticipant.getFullyQualifiedType() !== 'org.acme.Driver') { // Throw an error as the current participant is not a driver. throw new Error('Current participant is not a driver'); } // Check to see if the current participant is the first driver. if (currentParticipant.getFullyQualifiedIdentifier() !== 'org.acme.Driver#DRIVER_1') { // Throw an error as the current participant is not a driver. throw new Error('Current participant is not the first driver'); } getFactory() Get the factory. The factory can be used to create new instances ofassets, participants, and transactions for storing in registries. Thefactory can also be used for creating relationships to assets, particpants,and transactions. Source: composer-runtime/lib/api.js, line 76 Returns: The factory. Type module:composer-runtime.Factory Example // Get the factory. var factory = getFactory(); getParticipantRegistry(id) Get an existing participant registry using the unique identifier of the participantregistry. An participant registry can be used to retrieve, update, or deleteexisting participants, or create new participants. Parameters: Name Type Description id string The ID of the participant registry. Source: composer-runtime/lib/api.js, line 149 Returns: A promise. The promise is resolved with an {@linkmodule:composer-runtime.ParticipantRegistry ParticipantRegistry} instancerepresenting the participant registry if it exists. If the participant registrydoes not exist, or the current user does not have access to the participantregistry, then the promise will be rejected with an error that describesthe problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (driverParticipantRegistry) { // Call methods on the driver participant registry. }) .catch(function (error) { // Add optional error handling here. }); getSerializer() Get the serializer. The serializer can be used to create new instances ofassets, participants, and transactions from a JavaScript object, or to createa JavaScript object suitable for long-lived persistence. Source: composer-runtime/lib/api.js, line 96 Returns: The serializer. Type module:composer-common.Serializer Example // Get the serializer. var ser = getSerializer(); post(url, typed) Post a typed instance to a HTTP URL Parameters: Name Type Description url string The URL to post the data to typed Typed The typed instance to be posted. The instance will be serialized to JSON. Source: composer-runtime/lib/api.js, line 213 Returns: A promise. The promise is resolved with a HttpResponsethat represents the result of the HTTP POST. Type Promise query(query [, parameters]) Execute a query defined in a Composer query file, or execute a query built with buildQuery. This functionality is Blockchain platform dependent. For example, when a Composerbusiness network is deployed to Hyperledger Fabric v1.0, Hyperledger Fabric must beconfigured with the CouchDB database for the world state. Parameters: Name Type Argument Description query string | Query The name of the query, or a built query. parameters Object &lt;optional&gt; The parameters for the query. Source: composer-runtime/lib/api.js, line 291 Returns: A promise that will be resolved with an array ofResource representing theresources returned by the query. Type Promise Example // Execute the query. return query('Q1', { inputValue: 'blue' }) .then(function (assets) { assets.forEach(function (asset) { // Process each asset. }); }) .catch(function (error) { // Add optional error handling here. }); × Search results Close "},"module-composer-runtime.AssetRegistry.html":{"id":"module-composer-runtime.AssetRegistry.html","title":"Class: AssetRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: AssetRegistry composer-runtime. AssetRegistry An asset registry manages a set of assets. new AssetRegistry() Do not attempt to create an instance of this class.You must use the getAssetRegistrymethod instead. Source: composer-runtime/lib/api/assetregistry.js, line 21 Methods add(asset) Add the specified asset to this asset registry. Parameters: Name Type Description asset Resource The assets to add to this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 169 Returns: A promise. The promise is resolved when the asset hasbeen added to this asset registry. If the asset cannot be added to thisasset registry, or if the asset already exists in the asset registry,then the promise will be rejected with an error that describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Create the vehicle. var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); vehicle.colour = 'BLUE'; // Add the vehicle to the vehicle asset registry. return vehicleAssetRegistry.add(vehicle); }) .catch(function (error) { // Add optional error handling here. }); addAll(assets) Add all of the specified assets to this asset registry. Parameters: Name Type Description assets Array.&lt;Resource&gt; The assets to add to this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 136 Returns: A promise. The promise is resolved when all of theassets have been added to this asset registry. If the assets cannot beadded to this asset registry, or if the assets already exist in theasset registry, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Create the first vehicle. var vehicle1 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); vehicle1.colour = 'BLUE'; // Create the second vehicle. var vehicle2 = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_2'); vehicle2.colour = 'GREEN'; // Add the vehicles to the vehicle asset registry. return vehicleAssetRegistry.addAll([vehicle1, vehicle2]); }) .catch(function (error) { // Add optional error handling here. }); exists(id) Determines whether a specific asset exists in this asset registry. Parameters: Name Type Description id string The ID of the asset. Source: composer-runtime/lib/api/assetregistry.js, line 109 Returns: A promise. The promise is resolved with a boolean whichis true if the specified asset exists in this asset registry, and falseif the specified participant does not exist. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Determine if the specific vehicle exists in the vehicle asset registry. return assetRegistry.exists('VEHICLE_1'); }) .then(function (exists) { // Process the the boolean result. console.log('Vehicle exists', exists); }) .catch(function (error) { // Add optional error handling here. }); get(id) Get the specified asset in this asset registry using the unique identifierof the asset. Parameters: Name Type Description id string The ID of the asset. Source: composer-runtime/lib/api/assetregistry.js, line 79 Returns: A promise. The promise is resolved with a Resourceinstance representing the specified asset in this asset registry. If thespecified asset does not exist, or the current user does not have accessto the specified asset, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the specific vehicle from the vehicle asset registry. return assetRegistry.get('VEHICLE_1'); }) .then(function (vehicle) { // Process the the vehicle object. console.log(vehicle.vehicleId); }) .catch(function (error) { // Add optional error handling here. }); getAll() Get a list of all of the existing assets in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 49 Returns: A promise. The promise is resolved with an array ofResource instances representing all of the assets stored in thisasset registry. If the asset registry does not exist, or the currentuser does not have access to the asset registry, then the promise willbe rejected with an error that describes the problem. Type Promise Example // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get all of the vehicles in the vehicle asset registry. return assetRegistry.getAll(); }) .then(function (vehicles) { // Process the array of vehicle objects. vehicles.forEach(function (vehicle) { console.log(vehicle.vehicleId); }); }) .catch(function (error) { // Add optional error handling here. }); remove(asset) Remove the specified asset from this asset registry. Parameters: Name Type Description asset string | Resource The asset, or ID of the asset, to removefrom this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 295 Returns: A promise. The promise is resolved when the assethas been removed from this asset registry. If the asset cannot beremoved from this asset registry, or if the asset does not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicle that has come from elsewhere. var vehicle; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Remove the vehicle from the vehicle asset registry. return vehicleAssetRegistry.remove(vehicle); }) .catch(function (error) { // Add optional error handling here. }); removeAll(assets) Remove all of the specified assets from this asset registry. Parameters: Name Type Description assets Array.&lt;string&gt; | Array.&lt;Resource&gt; The assets, or the IDs of the assets,to remove from this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 263 Returns: A promise. The promise is resolved when all of theassets have been removed from this asset registry. If the assets cannot beremoved from this asset registry, or if the assets do not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicles that have come from elsewhere. var vehicle1; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Remove the vehicles from the vehicle asset registry. Note that // one vehicle is specified as a vehicle instance, and the other // vehicle is specified by the ID of the vehicle. return vehicleAssetRegistry.removeAll([vehicle1, 'VEHICLE_2']); }) .catch(function (error) { // Add optional error handling here. }); update(asset) Update the specified asset in this asset registry. Parameters: Name Type Description asset Resource The asset to update in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 232 Returns: A promise. The promise is resolved when the assethave been updated in this asset registry. If the asset cannot beupdated in this asset registry, or if the asset does not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicle that has come from elsewhere. var vehicle; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Modify the properties of the vehicle. vehicle.colour = 'PURPLE'; // Update the vehicle in the vehicle asset registry. return vehicleAssetRegistry.update(vehicle); }) .catch(function (error) { // Add optional error handling here. }); updateAll(assets) Update all of the specified assets in this asset registry. Parameters: Name Type Description assets Array.&lt;Resource&gt; The assets to update in this asset registry. Source: composer-runtime/lib/api/assetregistry.js, line 198 Returns: A promise. The promise is resolved when all of theassets have been updated in this asset registry. If the assets cannot beupdated in this asset registry, or if the assets do not exist in theasset registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing vehicles that have come from elsewhere. var vehicle1; var vehicle2; // Get the vehicle asset registry. return getAssetRegistry('org.acme.Vehicle') .then(function (vehicleAssetRegistry) { // Get the factory for creating new asset instances. var factory = getFactory(); // Modify the properties of the first vehicle. vehicle1.colour = 'PURPLE'; // Modify the properties of the second vehicle. vehicle2.colour = 'ORANGE'; // Update the vehicles in the vehicle asset registry. return vehicleAssetRegistry.updateAll([vehicle1, vehicle2]); }) .catch(function (error) { // Add optional error handling here. }); × Search results Close "},"module-composer-runtime.Factory.html":{"id":"module-composer-runtime.Factory.html","title":"Class: Factory","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Factory composer-runtime. Factory A factory creates new instances of assets, participants, transactions,and relationships. new Factory() Do not attempt to create an instance of this class.You must use the getFactorymethod instead. Source: composer-runtime/lib/api/factory.js, line 21 Methods newConcept(ns, type) Create a new concept with a given namespace, type, and identifier.A concept is an advanced data structure Parameters: Name Type Description ns string The namespace of the concept. type string The type of the concept. Source: composer-runtime/lib/api/factory.js, line 105 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the concept. Type Concept Example // The existing driver of the vehicle. var person; // Get the factory. var factory = getFactory(); // Create a new relationship to the vehicle. var record = factory.newConcept('org.acme', 'Record'); // Add the record to the persons array of records. person.records.push(record); newEvent(ns, type) Create a new type with a given namespace and type Parameters: Name Type Description ns string The namespace of the event. type string The type of the event. Source: composer-runtime/lib/api/factory.js, line 129 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the event. Type Resource newRelationship(ns, type, id) Create a new relationship with a given namespace, type, and identifier.A relationship is a typed pointer to an instance. For example, a newrelationship with namespace 'org.acme', type 'Vehicle' and identifier'VEHICLE_1' creates` a pointer that points at an existing instance oforg.acme.Vehicle with the identifier 'VEHICLE_1'. Parameters: Name Type Description ns string The namespace of the resource referenced by the relationship. type string The type of the resource referenced by the relationship. id string The identifier of the resource referenced by the relationship. Source: composer-runtime/lib/api/factory.js, line 77 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the relationship. Type Relationship Example // The existing driver of the vehicle. var driver; // Get the factory. var factory = getFactory(); // Create a new relationship to the vehicle. var vehicle = factory.newRelationship('org.acme', 'Vehicle', 'VEHICLE_1'); // Set the relationship as the value of the vehicle property of the driver. driver.vehicle = vehicle; newResource(ns, type, id) Create a new resource (an instance of an asset, participant, or transaction). Theproperties of the new instance should be set as standard JavaScriptobject properties. The new instance can then be stored in a registryusing the appropriate registry APIs, for example {@linkmodule:composer-runtime.AssetRegistry AssetRegistry}. Parameters: Name Type Description ns string The namespace of the resource to create. type string The type of the resource to create. id string The identifier of the new resource. Source: composer-runtime/lib/api/factory.js, line 50 Throws: If the specified type (specified by the namespace andtype) is not defined in the current version of the business network. Type Error Returns: The new instance of the resource. Type Resource Example // Get the factory. var factory = getFactory(); // Create a new vehicle. var vehicle = factory.newResource('org.acme', 'Vehicle', 'VEHICLE_1'); // Set the properties of the new vehicle. vehicle.colour = 'BLUE'; vehicle.manufacturer = 'Toyota'; × Search results Close "},"module-composer-runtime.ParticipantRegistry.html":{"id":"module-composer-runtime.ParticipantRegistry.html","title":"Class: ParticipantRegistry","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: ParticipantRegistry composer-runtime. ParticipantRegistry An participant registry manages a set of participants. new ParticipantRegistry() Do not attempt to create an instance of this class.You must use the getParticipantRegistrymethod instead. Source: composer-runtime/lib/api/participantregistry.js, line 21 Methods add(participant) Add the specified participant to this participant registry. Parameters: Name Type Description participant Resource The participants to add to this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 169 Returns: A promise. The promise is resolved when the participant hasbeen added to this participant registry. If the participant cannot be added to thisparticipant registry, or if the participant already exists in the participant registry,then the promise will be rejected with an error that describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Create the driver. var driver = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); driver.location = 'Southampton'; // Add the driver to the driver participant registry. return participantRegistry.add(driver); }) .catch(function (error) { // Add optional error handling here. }); addAll(participants) Add all of the specified participants to this participant registry. Parameters: Name Type Description participants Array.&lt;Resource&gt; The participants to add to this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 136 Returns: A promise. The promise is resolved when all of theparticipants have been added to this participant registry. If the participants cannot beadded to this participant registry, or if the participants already exist in theparticipant registry, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Create the first driver. var driver1 = factory.newResource('org.acme', 'Driver', 'VEHICLE_1'); driver1.location = 'Southampton'; // Create the second driver. var driver2 = factory.newResource('org.acme', 'Driver', 'VEHICLE_2'); driver2.location = 'GREEN'; // Add the drivers to the driver participant registry. return participantRegistry.addAll([driver1, driver2]); }) .catch(function (error) { // Add optional error handling here. }); exists(id) Determines whether a specific participant exists in this participant registry. Parameters: Name Type Description id string The ID of the participant. Source: composer-runtime/lib/api/participantregistry.js, line 109 Returns: A promise. The promise is resolved with a boolean whichis true if the specified participant exists in this participant registry,and false if the specified participant does not exist. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Determine if the specific driver exists in the driver participant registry. return participantRegistry.exists('VEHICLE_1'); }) .then(function (exists) { // Process the the boolean result. console.log('Driver exists', exists); }) .catch(function (error) { // Add optional error handling here. }); get(id) Get the specified participant in this participant registry using the unique identifierof the participant. Parameters: Name Type Description id string The ID of the participant. Source: composer-runtime/lib/api/participantregistry.js, line 79 Returns: A promise. The promise is resolved with a Resourceinstance representing the specified participant in this participant registry. If thespecified participant does not exist, or the current user does not have accessto the specified participant, then the promise will be rejected with an errorthat describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the specific driver from the driver participant registry. return participantRegistry.get('VEHICLE_1'); }) .then(function (driver) { // Process the the driver object. console.log(driver.driverId); }) .catch(function (error) { // Add optional error handling here. }); getAll() Get a list of all of the existing participants in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 49 Returns: A promise. The promise is resolved with an array ofResource instances representing all of the participants stored in thisparticipant registry. If the participant registry does not exist, or the currentuser does not have access to the participant registry, then the promise willbe rejected with an error that describes the problem. Type Promise Example // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get all of the drivers in the driver participant registry. return participantRegistry.getAll(); }) .then(function (drivers) { // Process the array of driver objects. drivers.forEach(function (driver) { console.log(driver.driverId); }); }) .catch(function (error) { // Add optional error handling here. }); remove(participant) Remove the specified participant from this participant registry. Parameters: Name Type Description participant string | Resource The participant, or ID of the participant, to removefrom this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 295 Returns: A promise. The promise is resolved when the participanthas been removed from this participant registry. If the participant cannot beremoved from this participant registry, or if the participant does not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing driver that has come from elsewhere. var driver; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Remove the driver from the driver participant registry. return participantRegistry.remove(driver); }) .catch(function (error) { // Add optional error handling here. }); removeAll(participants) Remove all of the specified participants from this participant registry. Parameters: Name Type Description participants Array.&lt;string&gt; | Array.&lt;Resource&gt; The participants, or the IDs of the participants,to remove from this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 263 Returns: A promise. The promise is resolved when all of theparticipants have been removed from this participant registry. If the participants cannot beremoved from this participant registry, or if the participants do not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing drivers that have come from elsewhere. var driver1; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Remove the drivers from the driver participant registry. Note that // one driver is specified as a driver instance, and the other // driver is specified by the ID of the driver. return participantRegistry.removeAll([driver1, 'VEHICLE_2']); }) .catch(function (error) { // Add optional error handling here. }); update(participant) Update the specified participant in this participant registry. Parameters: Name Type Description participant Resource The participant to update in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 232 Returns: A promise. The promise is resolved when the participanthave been updated in this participant registry. If the participant cannot beupdated in this participant registry, or if the participant does not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing driver that has come from elsewhere. var driver; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Modify the properties of the driver. driver.location = 'Hursley'; // Update the driver in the driver participant registry. return participantRegistry.update(driver); }) .catch(function (error) { // Add optional error handling here. }); updateAll(participants) Update all of the specified participants in this participant registry. Parameters: Name Type Description participants Array.&lt;Resource&gt; The participants to update in this participant registry. Source: composer-runtime/lib/api/participantregistry.js, line 198 Returns: A promise. The promise is resolved when all of theparticipants have been updated in this participant registry. If the participants cannot beupdated in this participant registry, or if the participants do not exist in theparticipant registry, then the promise will be rejected with an error thatdescribes the problem. Type Promise Example // The existing drivers that have come from elsewhere. var driver1; var driver2; // Get the driver participant registry. return getParticipantRegistry('org.acme.Driver') .then(function (participantRegistry) { // Get the factory for creating new participant instances. var factory = getFactory(); // Modify the properties of the first driver. driver1.location = 'Hursley'; // Modify the properties of the second driver. driver2.location = 'London'; // Update the drivers in the driver participant registry. return participantRegistry.updateAll([driver1, driver2]); }) .catch(function (error) { // Add optional error handling here. }); × Search results Close "},"module-composer-runtime.Query.html":{"id":"module-composer-runtime.Query.html","title":"Class: Query","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Query composer-runtime. Query A query represents a built query. new Query() Do not attempt to create an instance of this class.You must use the buildQuerymethod instead. Source: composer-runtime/lib/api/query.js, line 21 × Search results Close "},"module-composer-runtime.Serializer.html":{"id":"module-composer-runtime.Serializer.html","title":"Class: Serializer","body":" Hyperledger Composer Modules composer-admincomposer-clientcomposer-commoncomposer-runtime Classes ConsoleLoggercomposer-admin.AdminConnectioncomposer-client.AssetRegistrycomposer-client.BusinessNetworkConnectioncomposer-client.ParticipantRegistrycomposer-client.Querycomposer-client.Registrycomposer-client.TransactionRegistrycomposer-common.BaseExceptioncomposer-common.BaseModelExceptioncomposer-common.BusinessNetworkDefinitioncomposer-common.BusinessNetworkMetadatacomposer-common.Conceptcomposer-common.Factorycomposer-common.Identifiablecomposer-common.IllegalModelExceptioncomposer-common.Introspectorcomposer-common.ParseExceptioncomposer-common.Relationshipcomposer-common.Resourcecomposer-common.SecurityContextcomposer-common.SecurityExceptioncomposer-common.Serializercomposer-common.Typedcomposer-common.TypeNotFoundExceptioncomposer-common.ValidatedConceptcomposer-common.ValidatedResourcecomposer-common.ValidationExceptioncomposer-runtime.AssetRegistrycomposer-runtime.Factorycomposer-runtime.ParticipantRegistrycomposer-runtime.Querycomposer-runtime.Serializer Global getLoggertheWallet Class: Serializer composer-runtime. Serializer A serializer serializes instances of assets, participants, transactions,and relationships to and from a JSON serialization format. new Serializer() Do not attempt to create an instance of this class.You must use the getSerializermethod instead. Source: composer-runtime/lib/api/serializer.js, line 21 Methods fromJSON(json [, options]) Create a Resource from a JavaScript object representation.The JavaScript object should have been created by calling thetoJSON API.The Resource is populated based on the JavaScript object. Parameters: Name Type Argument Description json Object The JavaScript object for the resource. options Object &lt;optional&gt; The optional serialization options. Properties Name Type Argument Description acceptResourcesForRelationships boolean &lt;optional&gt; Handle JSON objectsin the place of strings for relationships, false by default. Source: composer-runtime/lib/api/serializer.js, line 76 Throws: If the specified resource is not an instance ofResource or if it fails validation during serialization. Type Error Returns: The resource. Type Resource Example // Get the serializer. var serializer = getSerializer(); // Serialize a vehicle. var vehicle = serializer.fromJSON(json); toJSON(resource [, options]) Convert a Resource to a JavaScript object suitable for long-termperistent storage. Parameters: Name Type Argument Description resource Resource The resource instance to convert to JSON. options Object &lt;optional&gt; The optional serialization options. Properties Name Type Argument Description validate boolean &lt;optional&gt; Validate the structure of the resourcewith its model prior to serialization, true by default. convertResourcesToRelationships boolean &lt;optional&gt; Convert resources thatare specified for relationship fields into relationships, false by default. permitResourcesForRelationships boolean &lt;optional&gt; Permit resources in theplace of relationships (serializing them as resources), false by default. Source: composer-runtime/lib/api/serializer.js, line 50 Throws: If the specified resource is not an instance ofResource or if it fails validation during serialization. Type Error Returns: The JavaScript object that represents the resource Type Object Example // Get the serializer. var serializer = getSerializer(); // Serialize a vehicle. var json = serializer.toJSON(vehicle); × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
